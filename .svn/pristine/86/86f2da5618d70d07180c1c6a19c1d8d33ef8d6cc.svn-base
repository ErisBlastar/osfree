/* Generated by the New Jersey Machine-Code Toolkit, version 0.5 */
/* command line: tools -encoder sparc-encoder -byteorder b -indirect sparc_enc:sparc_enc_t machine/sparc/sparc-core.spec machine/sparc/sparc-synth.spec */
#include <mclib.h>
#include "sparc-encoder.h"
#define sign_extend(N,SIZE) \
  (((int)((N) << (sizeof(unsigned)*8-(SIZE)))) >> (sizeof(unsigned)*8-(SIZE)))
#define dispA_TAG 1
#define absoluteA_TAG 2
#define indexA_TAG 3
#define indirectA_TAG 4
#define imode_TAG 1
#define rmode_TAG 2
#define indexR_TAG 1
#define indirectR_TAG 2
/**************

dispA rs1 + simm13! is (?noname?) i ==  1 & rs1 = rs1 & simm13 = simm13

***********/
static address__Instance dispA(unsigned /* [0..31] */ rs1, int simm13) {
  address__Instance _i = { dispA_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  if (!((unsigned)(simm13 + 4096) < 0x2000)) 
    (*fail) ("simm13 = %d won't fit in 13 signed bits");
  _i.u.dispA.rs1 = rs1;
  _i.u.dispA.simm13 = simm13;
  return _i;
}
/**************

absoluteA simm13! is (?noname?) i ==  1 & rs1 ==  0 & simm13 = simm13

***********/
static address__Instance absoluteA(int simm13) {
  address__Instance _i = { absoluteA_TAG };
  if (!((unsigned)(simm13 + 4096) < 0x2000)) 
    (*fail) ("simm13 = %d won't fit in 13 signed bits");
  _i.u.absoluteA.simm13 = simm13;
  return _i;
}
/**************

indexA rs1 + rs2 is (?noname?) i ==  0 & rs1 = rs1 & rs2 = rs2

***********/
static address__Instance indexA(unsigned /* [0..31] */ rs1, unsigned /* [0..31] */ rs2) {
  address__Instance _i = { indexA_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  if (!((unsigned)(rs2) < 0x20)) 
    (*fail) ("rs2 = %d won't fit in 5 unsigned bits");
  _i.u.indexA.rs1 = rs1;
  _i.u.indexA.rs2 = rs2;
  return _i;
}
/**************

indirectA rs1 is (?noname?) i ==  0 & rs2 ==  0 & rs1 = rs1

***********/
static address__Instance indirectA(unsigned /* [0..31] */ rs1) {
  address__Instance _i = { indirectA_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  _i.u.indirectA.rs1 = rs1;
  return _i;
}
/**************

imode simm13! is (?noname?) i ==  1 & simm13 = simm13

***********/
static reg_or_imm_Instance imode(int simm13) {
  reg_or_imm_Instance _i = { imode_TAG };
  if (!((unsigned)(simm13 + 4096) < 0x2000)) 
    (*fail) ("simm13 = %d won't fit in 13 signed bits");
  _i.u.imode.simm13 = simm13;
  return _i;
}
/**************

rmode rs2 is (?noname?) i ==  0 & rs2 = rs2

***********/
static reg_or_imm_Instance rmode(unsigned /* [0..31] */ rs2) {
  reg_or_imm_Instance _i = { rmode_TAG };
  if (!((unsigned)(rs2) < 0x20)) 
    (*fail) ("rs2 = %d won't fit in 5 unsigned bits");
  _i.u.rmode.rs2 = rs2;
  return _i;
}
/**************

LDSB [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  9 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void LDSB(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 9 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 9 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 9 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 9 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDSH [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 10 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void LDSH(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 10 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 10 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 10 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 10 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDUB [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  1 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void LDUB(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 1 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 1 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 1 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 1 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDUH [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  2 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void LDUH(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 2 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 2 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 2 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 2 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LD [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  0 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void LD(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 0 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 0 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 0 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 0 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDSTUB [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 13 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void LDSTUB(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 13 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 13 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 13 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 13 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

SWAP_ [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 15 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void SWAP_(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 15 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 15 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 15 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 15 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDD [address_], rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  3 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void LDD(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 3 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 3 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 3 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 3 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDF [address_], fds is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & fds = fds
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fds = fds
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fds = fds
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 32 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & fds = fds
  END (* address_ *)

***********/
static void LDF(address__Instance address_, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 32 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fds & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 32 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fds & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 32 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fds & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 32 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fds & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDDF [address_], fdd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & fdd = fdd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fdd = fdd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fdd = fdd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 35 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & fdd = fdd
  END (* address_ *)

***********/
static void LDDF(address__Instance address_, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 35 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fdd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 35 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fdd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 35 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fdd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 35 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fdd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDC [address_], cd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 48 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
static void LDC(address__Instance address_, unsigned /* [0..31] */ cd) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 48 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 48 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 48 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 48 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

LDDC [address_], cd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 51 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
static void LDDC(address__Instance address_, unsigned /* [0..31] */ cd) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 51 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 51 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 51 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 51 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STB rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void STB(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 5 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 5 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STH rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void STH(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 6 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 6 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

ST rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void ST(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 4 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 4 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STD rd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 ==  7 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void STD(unsigned /* [0..31] */ rd, address__Instance address_) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 7 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 7 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 7 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 7 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STF fds, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & fds = fds
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fds = fds
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fds = fds
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 36 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & fds = fds
  END (* address_ *)

***********/
static void STF(unsigned /* [0..31] */ fds, address__Instance address_) {
  if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 36 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fds & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 36 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fds & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 36 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fds & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 36 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fds & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STDF fdd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & fdd = fdd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & fdd = fdd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & fdd = fdd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 39 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & fdd = fdd
  END (* address_ *)

***********/
static void STDF(unsigned /* [0..31] */ fdd, address__Instance address_) {
  if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 39 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (fdd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 39 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (fdd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 39 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (fdd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 39 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (fdd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STC cd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 52 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
static void STC(unsigned /* [0..31] */ cd, address__Instance address_) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 52 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 52 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 52 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 52 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

STDC cd, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & cd = cd
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & cd = cd
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & cd = cd
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 55 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & cd = cd
  END (* address_ *)

***********/
static void STDC(unsigned /* [0..31] */ cd, address__Instance address_) {
  if (!((unsigned)(cd) < 0x20)) 
    fail("field cd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(3 << 30 | 55 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(3 << 30 | 55 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (cd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(3 << 30 | 55 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (cd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(3 << 30 | 55 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (cd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

indexR rs1 + rs2 is (?noname?) i ==  0 & rs1 = rs1 & rs2 = rs2

***********/
static regaddr_Instance indexR(unsigned /* [0..31] */ rs1, unsigned /* [0..31] */ rs2) {
  regaddr_Instance _i = { indexR_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  if (!((unsigned)(rs2) < 0x20)) 
    (*fail) ("rs2 = %d won't fit in 5 unsigned bits");
  _i.u.indexR.rs1 = rs1;
  _i.u.indexR.rs2 = rs2;
  return _i;
}
/**************

indirectR rs1 is (?noname?) i ==  0 & rs2 ==  0 & rs1 = rs1

***********/
static regaddr_Instance indirectR(unsigned /* [0..31] */ rs1) {
  regaddr_Instance _i = { indirectR_TAG };
  if (!((unsigned)(rs1) < 0x20)) 
    (*fail) ("rs1 = %d won't fit in 5 unsigned bits");
  _i.u.indirectR.rs1 = rs1;
  return _i;
}
/**************

LDSBA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 25 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 25 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void LDSBA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 25 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 25 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDSHA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 26 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 26 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void LDSHA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 26 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 26 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDUBA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 17 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 17 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void LDUBA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 17 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 17 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDUHA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 18 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 18 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void LDUHA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 18 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 18 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 16 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 16 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void LDA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 16 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 16 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDSTUBA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 29 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 29 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void LDSTUBA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 29 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 29 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

SWAPA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 31 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 31 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void SWAPA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 31 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 31 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDDA [regaddr]asi, rd is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 19 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & asi = asi & rd = rd
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 19 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & asi = asi & rd = rd
  END (* regaddr *)

***********/
static void LDDA(regaddr_Instance regaddr, unsigned /* [0..255] */ asi, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 19 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 19 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (asi & 0xff) << 5 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STBA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 21 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 21 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
static void STBA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 21 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 21 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STHA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 22 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 22 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
static void STHA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 22 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 22 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 20 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 20 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
static void STA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 20 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 20 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

STDA rd, [regaddr]asi is 
  
  CASE regaddr OF 
  | indexR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 23 & i ==  0 & 
      rs1 = regaddr.indexR.rs1 & rs2 = regaddr.indexR.rs2 & rd = rd & asi = asi
  | indirectR => 
      (?noname?) (?regaddr:): op ==  3 & op3 == 23 & i ==  0 & rs2 ==  0 & 
      rs1 = regaddr.indirectR.rs1 & rd = rd & asi = asi
  END (* regaddr *)

***********/
static void STDA(unsigned /* [0..31] */ rd, regaddr_Instance regaddr, unsigned /* [0..255] */ asi) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(asi) < 0x100)) 
    fail("field asi does not fit in 8 unsigned bits"); 
  else 
    switch (regaddr.tag) {
      case indexR_TAG: 
        
        emitb(3 << 30 | 23 << 19 | 0 << 13 | regaddr.u.indexR.rs1 << 14 | 
          regaddr.u.indexR.rs2 | (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      case indirectR_TAG: 
        
        emitb(3 << 30 | 23 << 19 | 0 << 13 | regaddr.u.indirectR.rs1 << 14 | 
          (rd & 0x1f) << 25 | (asi & 0xff) << 5, 4); 
        break;
      default: assert(0);
    } /* regaddr */ 
}
/**************

LDFSR [address_], %fsr is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 33 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void LDFSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 33 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 33 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 33 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(3 << 30 | 33 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

LDCSR [address_], %csr is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 49 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void LDCSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 49 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 49 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 49 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(3 << 30 | 49 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STFSR %fsr, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 37 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void STFSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 37 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 37 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 37 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(3 << 30 | 37 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STCSR %csr, [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 53 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void STCSR(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 53 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 53 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 53 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(3 << 30 | 53 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STDFQ %fq,  [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 38 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void STDFQ(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 38 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 38 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 38 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(3 << 30 | 38 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

STDCQ %cq,  [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  3 & op3 == 54 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void STDCQ(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 54 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 54 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 54 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(3 << 30 | 54 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

RDY %y,   rd is (RDY) op ==  2 & op3 == 40 & rs1 ==  0 & rd = rd

***********/
static void RDY(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 40 << 19 | 0 << 14 | (rd & 0x1f) << 25, 4); 
}
/**************

RDPSR %psr, rd is (RDPSR) op ==  2 & op3 == 41 & rd = rd

***********/
static void RDPSR(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 41 << 19 | (rd & 0x1f) << 25, 4); 
}
/**************

RDWIM %wim, rd is (RDWIM) op ==  2 & op3 == 42 & rd = rd

***********/
static void RDWIM(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 42 << 19 | (rd & 0x1f) << 25, 4); 
}
/**************

RDTBR %tbr, rd is (RDTBR) op ==  2 & op3 == 43 & rd = rd

***********/
static void RDTBR(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 43 << 19 | (rd & 0x1f) << 25, 4); 
}
/**************

WRY rs1, reg_or_imm, %y is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 & rd ==  0 & i ==  1 & 
      rs1 = rs1 & simm13 = reg_or_imm.imode.simm13
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 & rd ==  0 & i ==  0 & 
      rs1 = rs1 & rs2 = reg_or_imm.rmode.rs2
  END (* reg_or_imm *)

***********/
static void WRY(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 48 << 19 | 0 << 25 | 1 << 13 | (rs1 & 0x1f) << 14 | 
          reg_or_imm.u.imode.simm13 & 0x1fff, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 48 << 19 | 0 << 25 | 0 << 13 | (rs1 & 0x1f) << 14 | 
          reg_or_imm.u.rmode.rs2, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

WRPSR rs1, reg_or_imm, %psr is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 49 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 49 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
static void WRPSR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 49 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 49 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

WRWIM rs1, reg_or_imm, %wim is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 50 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 50 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
static void WRWIM(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 50 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 50 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

WRTBR rs1, reg_or_imm, %tbr is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 51 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 51 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1
  END (* reg_or_imm *)

***********/
static void WRTBR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 51 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 51 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

RDASR %asrrs1i, rd is 
  (RDASR) op ==  2 & op3 == 40 &  1 <= rs1  < 32 & rs1i = rs1i & rd = rd

***********/
static void RDASR(unsigned /* [0..31] */ rs1i, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1i) < 0x20)) 
    fail("field rs1i does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 40 << 19 | (rs1i & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
}
/**************

WRASR rs1, reg_or_imm, %asrrdi is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 &  1 <= rd  < 32 & 
      i ==  1 & simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rdi = rdi
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 48 &  1 <= rd  < 32 & 
      i ==  0 & rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rdi = rdi
  END (* reg_or_imm *)

***********/
static void WRASR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rdi) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rdi) < 0x20)) 
    fail("field rdi does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 48 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rdi & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 48 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rdi & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

STBAR  is (STBAR) op ==  2 & op3 == 40 & rs1 == 15 & rd ==  0

***********/
static void STBAR(void) {
  emitb(2 << 30 | 40 << 19 | 15 << 14 | 0 << 25, 4);
}
/**************

AND rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  1 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  1 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void AND(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 1 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 1 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ANDcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ANDcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 17 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 17 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ANDN rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ANDN(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 5 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 5 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ANDNcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 21 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 21 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ANDNcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 21 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 21 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

OR rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void OR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 2 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 2 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ORcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 18 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 18 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ORcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 18 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 18 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ORN rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  6 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  6 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ORN(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 6 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 6 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ORNcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 22 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 22 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ORNcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 22 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 22 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XOR rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void XOR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 3 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 3 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XORcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 19 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 19 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void XORcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 19 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 19 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XNOR rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  7 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  7 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void XNOR(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 7 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 7 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

XNORcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 23 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 23 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void XNORcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 23 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 23 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SLL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 37 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 37 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SLL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 37 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 37 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SRL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 38 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 38 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SRL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 38 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 38 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SRA rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 39 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 39 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SRA(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 39 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 39 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADD rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  0 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  0 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ADD(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 0 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 0 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADDcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 16 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 16 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ADDcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 16 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 16 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADDX rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  8 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  8 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ADDX(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 8 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 8 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

ADDXcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 24 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 24 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void ADDXcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 24 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 24 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TADDcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 32 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 32 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void TADDcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 32 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 32 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TADDccTV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 34 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 34 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void TADDccTV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 34 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 34 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUB rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  4 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 ==  4 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SUB(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 4 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 4 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUBcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SUBcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 20 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 20 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUBX rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 12 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 12 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SUBX(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 12 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 12 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SUBXcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 28 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 28 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SUBXcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 28 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 28 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TSUBcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 33 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 33 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void TSUBcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 33 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 33 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

TSUBccTV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 35 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 35 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void TSUBccTV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 35 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 35 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

MULScc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 36 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 36 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void MULScc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 36 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 36 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UMUL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 10 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 10 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void UMUL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 10 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 10 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SMUL rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 11 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 11 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SMUL(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 11 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 11 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UMULcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 26 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 26 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void UMULcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 26 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 26 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SMULcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 27 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 27 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SMULcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 27 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 27 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UDIV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 14 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 14 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void UDIV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 14 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 14 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SDIV rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 15 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 15 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SDIV(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 15 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 15 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

UDIVcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 30 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 30 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void UDIVcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 30 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 30 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SDIVcc rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 31 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 31 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SDIVcc(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 31 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 31 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

SAVE rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 60 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 60 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void SAVE(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 60 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 60 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

RESTORE rs1, reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 61 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = rd
  | rmode => 
      (?noname?) (?reg_or_imm:): op ==  2 & op3 == 61 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = rd
  END (* reg_or_imm *)

***********/
static void RESTORE(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 61 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 61 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

BN_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#1:)) MOD 4 = 0} => 
    L#1:: op ==  0 & op2 ==  2 & cond ==  0 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#1:)) DIV 4)[22!]

***********/
typedef struct O1_1_closure {
  ClosureHeader h;
  ClosureLocation loc;
  struct {  RAddr a1; unsigned u1; } v;
} *O1_1_Closure;
static void O1_1_relocfn(RClosure c, RelocCallback f, void *closure) {
  O1_1_Closure _c = (O1_1_Closure) c;
  (*f)(closure, _c->v.a1);
  }
/* CLOSURE FUNCTION _clofun_1 is 
  [
  1 cla force cl-loc force sub 0 1 bitslice 0 eq
  	{1 cla force cl-loc force sub -2 bitshift 22 narrows 1 clv orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (24) is "\r\x15\v'\n\x03n]\x15\v'\xec\xb0%\x07\x85-~]\x01-M?\x00" */
static void _clofun_1(RClosure c, Emitter emitter, FailCont fail) {
  O1_1_Closure _c = (O1_1_Closure) c;
  
  if ((location(_c->v.a1) - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u1 | 
      location(_c->v.a1) - pc_location(_c->loc) >> 2 & 0x3fffff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_1_closure_header = 
  { _clofun_1, O1_1_relocfn, 1, sizeof (struct O1_1_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 0 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BN_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BN_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 0 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#2:)) MOD 4 = 0} => 
    L#2:: op ==  0 & op2 ==  2 & cond ==  1 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#2:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 1 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 1 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#3:)) MOD 4 = 0} => 
    L#3:: op ==  0 & op2 ==  2 & cond ==  2 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#3:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 2 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BLE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 2 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BL_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#4:)) MOD 4 = 0} => 
    L#4:: op ==  0 & op2 ==  2 & cond ==  3 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#4:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 3 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BL_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BL_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 3 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLEU_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#5:)) MOD 4 = 0} => 
    L#5:: op ==  0 & op2 ==  2 & cond ==  4 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#5:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 4 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BLEU_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLEU_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 4 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCS_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#6:)) MOD 4 = 0} => 
    L#6:: op ==  0 & op2 ==  2 & cond ==  5 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#6:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 5 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BCS_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCS_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 5 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNEG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#7:)) MOD 4 = 0} => 
    L#7:: op ==  0 & op2 ==  2 & cond ==  6 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#7:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 6 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BNEG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNEG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 6 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVS_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#8:)) MOD 4 = 0} => 
    L#8:: op ==  0 & op2 ==  2 & cond ==  7 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#8:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 7 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BVS_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVS_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 7 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BA_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#9:)) MOD 4 = 0} => 
    L#9:: op ==  0 & op2 ==  2 & cond ==  8 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#9:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 8 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BA_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BA_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 8 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#10:)) MOD 4 = 0} => 
    L#10:: op ==  0 & op2 ==  2 & cond ==  9 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#10:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 9 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BNE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 9 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#11:)) MOD 4 = 0} => 
    L#11:: op ==  0 & op2 ==  2 & cond == 10 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#11:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 10 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 10 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#12:)) MOD 4 = 0} => 
    L#12:: op ==  0 & op2 ==  2 & cond == 11 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#12:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 11 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BGE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 11 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGU_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#13:)) MOD 4 = 0} => 
    L#13:: op ==  0 & op2 ==  2 & cond == 12 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#13:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 12 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BGU_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGU_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 12 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCC_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#14:)) MOD 4 = 0} => 
    L#14:: op ==  0 & op2 ==  2 & cond == 13 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#14:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 13 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BCC_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCC_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 13 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BPOS_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#15:)) MOD 4 = 0} => 
    L#15:: op ==  0 & op2 ==  2 & cond == 14 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#15:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 14 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BPOS_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BPOS_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 14 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVC_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#16:)) MOD 4 = 0} => 
    L#16:: op ==  0 & op2 ==  2 & cond == 15 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#16:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 15 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void BVC_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVC_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 15 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBN_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#17:)) MOD 4 = 0} => 
    L#17:: op ==  0 & op2 ==  6 & cond ==  0 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#17:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 0 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBN_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBN_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 0 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBNE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#18:)) MOD 4 = 0} => 
    L#18:: op ==  0 & op2 ==  6 & cond ==  1 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#18:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 1 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBNE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBNE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 1 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#19:)) MOD 4 = 0} => 
    L#19:: op ==  0 & op2 ==  6 & cond ==  2 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#19:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 2 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBLG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 2 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUL_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#20:)) MOD 4 = 0} => 
    L#20:: op ==  0 & op2 ==  6 & cond ==  3 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#20:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 3 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBUL_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUL_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 3 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBL_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#21:)) MOD 4 = 0} => 
    L#21:: op ==  0 & op2 ==  6 & cond ==  4 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#21:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 4 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBL_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBL_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 4 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#22:)) MOD 4 = 0} => 
    L#22:: op ==  0 & op2 ==  6 & cond ==  5 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#22:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 5 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBUG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 5 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBG_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#23:)) MOD 4 = 0} => 
    L#23:: op ==  0 & op2 ==  6 & cond ==  6 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#23:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 6 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBG_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBG_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 6 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBU_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#24:)) MOD 4 = 0} => 
    L#24:: op ==  0 & op2 ==  6 & cond ==  7 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#24:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 7 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBU_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBU_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 7 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBA_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#25:)) MOD 4 = 0} => 
    L#25:: op ==  0 & op2 ==  6 & cond ==  8 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#25:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 8 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBA_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBA_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 8 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#26:)) MOD 4 = 0} => 
    L#26:: op ==  0 & op2 ==  6 & cond ==  9 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#26:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 9 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 9 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#27:)) MOD 4 = 0} => 
    L#27:: op ==  0 & op2 ==  6 & cond == 10 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#27:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 10 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBUE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 10 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBGE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#28:)) MOD 4 = 0} => 
    L#28:: op ==  0 & op2 ==  6 & cond == 11 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#28:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 11 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBGE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBGE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 11 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUGE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#29:)) MOD 4 = 0} => 
    L#29:: op ==  0 & op2 ==  6 & cond == 12 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#29:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 12 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBUGE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUGE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 12 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#30:)) MOD 4 = 0} => 
    L#30:: op ==  0 & op2 ==  6 & cond == 13 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#30:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 13 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBLE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 13 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBULE_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#31:)) MOD 4 = 0} => 
    L#31:: op ==  0 & op2 ==  6 & cond == 14 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#31:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 14 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBULE_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBULE_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 14 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBO_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#32:)) MOD 4 = 0} => 
    L#32:: op ==  0 & op2 ==  6 & cond == 15 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#32:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 15 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void FBO_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBO_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 15 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBN_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#33:)) MOD 4 = 0} => 
    L#33:: op ==  0 & op2 ==  7 & cond ==  0 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#33:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 0 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CBN_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 0 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBN_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 0 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB123_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#34:)) MOD 4 = 0} => 
    L#34:: op ==  0 & op2 ==  7 & cond ==  1 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#34:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 1 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB123_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 1 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB123_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 1 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB12_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#35:)) MOD 4 = 0} => 
    L#35:: op ==  0 & op2 ==  7 & cond ==  2 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#35:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 2 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB12_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 2 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB12_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 2 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB13_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#36:)) MOD 4 = 0} => 
    L#36:: op ==  0 & op2 ==  7 & cond ==  3 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#36:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 3 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB13_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 3 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB13_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 3 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB1_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#37:)) MOD 4 = 0} => 
    L#37:: op ==  0 & op2 ==  7 & cond ==  4 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#37:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 4 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB1_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 4 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB1_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 4 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB23_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#38:)) MOD 4 = 0} => 
    L#38:: op ==  0 & op2 ==  7 & cond ==  5 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#38:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 5 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB23_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 5 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB23_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 5 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB2_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#39:)) MOD 4 = 0} => 
    L#39:: op ==  0 & op2 ==  7 & cond ==  6 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#39:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 6 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB2_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 6 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB2_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 6 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB3_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#40:)) MOD 4 = 0} => 
    L#40:: op ==  0 & op2 ==  7 & cond ==  7 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#40:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 7 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB3_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 7 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB3_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 7 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBA_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#41:)) MOD 4 = 0} => 
    L#41:: op ==  0 & op2 ==  7 & cond ==  8 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#41:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 8 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CBA_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 8 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBA_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 8 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB0_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#42:)) MOD 4 = 0} => 
    L#42:: op ==  0 & op2 ==  7 & cond ==  9 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#42:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 9 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB0_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 9 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB0_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 9 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB03_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#43:)) MOD 4 = 0} => 
    L#43:: op ==  0 & op2 ==  7 & cond == 10 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#43:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 10 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB03_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 10 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB03_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 10 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB02_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#44:)) MOD 4 = 0} => 
    L#44:: op ==  0 & op2 ==  7 & cond == 11 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#44:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 11 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB02_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 11 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB02_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 11 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB023_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#45:)) MOD 4 = 0} => 
    L#45:: op ==  0 & op2 ==  7 & cond == 12 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#45:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 12 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB023_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 12 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB023_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 12 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB01_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#46:)) MOD 4 = 0} => 
    L#46:: op ==  0 & op2 ==  7 & cond == 13 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#46:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 13 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB01_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 13 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB01_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 13 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB013_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#47:)) MOD 4 = 0} => 
    L#47:: op ==  0 & op2 ==  7 & cond == 14 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#47:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 14 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB013_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 14 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB013_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 14 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB012_a reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#48:)) MOD 4 = 0} => 
    L#48:: op ==  0 & op2 ==  7 & cond == 15 & a ==  1 & disp22 = ((reloc - 
      LOCATION_OF(L#48:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 15 << 25 ORB 1 << 29}, 
    addresses = {reloc})
****************/
static void CB012_a(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 15 << 25 | 1 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB012_a");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 15 << 25 | 1 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BN reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#49:)) MOD 4 = 0} => 
    L#49:: op ==  0 & op2 ==  2 & cond ==  0 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#49:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 0 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BN(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BN");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 0 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#50:)) MOD 4 = 0} => 
    L#50:: op ==  0 & op2 ==  2 & cond ==  1 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#50:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 1 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 1 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#51:)) MOD 4 = 0} => 
    L#51:: op ==  0 & op2 ==  2 & cond ==  2 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#51:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 2 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BLE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 2 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BL reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#52:)) MOD 4 = 0} => 
    L#52:: op ==  0 & op2 ==  2 & cond ==  3 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#52:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 3 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BL(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BL");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 3 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BLEU reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#53:)) MOD 4 = 0} => 
    L#53:: op ==  0 & op2 ==  2 & cond ==  4 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#53:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 4 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BLEU(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BLEU");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 4 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCS reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#54:)) MOD 4 = 0} => 
    L#54:: op ==  0 & op2 ==  2 & cond ==  5 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#54:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 5 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BCS(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCS");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 5 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNEG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#55:)) MOD 4 = 0} => 
    L#55:: op ==  0 & op2 ==  2 & cond ==  6 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#55:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 6 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BNEG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNEG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 6 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVS reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#56:)) MOD 4 = 0} => 
    L#56:: op ==  0 & op2 ==  2 & cond ==  7 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#56:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 7 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BVS(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVS");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 7 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BA reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#57:)) MOD 4 = 0} => 
    L#57:: op ==  0 & op2 ==  2 & cond ==  8 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#57:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 8 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BA(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BA");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 8 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BNE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#58:)) MOD 4 = 0} => 
    L#58:: op ==  0 & op2 ==  2 & cond ==  9 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#58:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 9 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BNE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BNE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 9 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#59:)) MOD 4 = 0} => 
    L#59:: op ==  0 & op2 ==  2 & cond == 10 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#59:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 10 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 10 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#60:)) MOD 4 = 0} => 
    L#60:: op ==  0 & op2 ==  2 & cond == 11 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#60:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 11 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BGE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 11 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BGU reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#61:)) MOD 4 = 0} => 
    L#61:: op ==  0 & op2 ==  2 & cond == 12 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#61:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 12 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BGU(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BGU");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 12 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BCC reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#62:)) MOD 4 = 0} => 
    L#62:: op ==  0 & op2 ==  2 & cond == 13 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#62:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 13 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BCC(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BCC");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 13 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BPOS reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#63:)) MOD 4 = 0} => 
    L#63:: op ==  0 & op2 ==  2 & cond == 14 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#63:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 14 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BPOS(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BPOS");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 14 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

BVC reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#64:)) MOD 4 = 0} => 
    L#64:: op ==  0 & op2 ==  2 & cond == 15 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#64:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 2 << 22 ORB 15 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void BVC(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 2 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor BVC");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 2 << 22 | 15 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBN reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#65:)) MOD 4 = 0} => 
    L#65:: op ==  0 & op2 ==  6 & cond ==  0 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#65:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 0 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBN(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBN");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 0 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBNE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#66:)) MOD 4 = 0} => 
    L#66:: op ==  0 & op2 ==  6 & cond ==  1 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#66:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 1 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBNE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBNE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 1 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#67:)) MOD 4 = 0} => 
    L#67:: op ==  0 & op2 ==  6 & cond ==  2 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#67:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 2 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBLG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 2 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUL reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#68:)) MOD 4 = 0} => 
    L#68:: op ==  0 & op2 ==  6 & cond ==  3 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#68:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 3 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBUL(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUL");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 3 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBL reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#69:)) MOD 4 = 0} => 
    L#69:: op ==  0 & op2 ==  6 & cond ==  4 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#69:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 4 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBL(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBL");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 4 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#70:)) MOD 4 = 0} => 
    L#70:: op ==  0 & op2 ==  6 & cond ==  5 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#70:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 5 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBUG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 5 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBG reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#71:)) MOD 4 = 0} => 
    L#71:: op ==  0 & op2 ==  6 & cond ==  6 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#71:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 6 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBG(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBG");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 6 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBU reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#72:)) MOD 4 = 0} => 
    L#72:: op ==  0 & op2 ==  6 & cond ==  7 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#72:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 7 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBU(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBU");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 7 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBA reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#73:)) MOD 4 = 0} => 
    L#73:: op ==  0 & op2 ==  6 & cond ==  8 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#73:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 8 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBA(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBA");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 8 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#74:)) MOD 4 = 0} => 
    L#74:: op ==  0 & op2 ==  6 & cond ==  9 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#74:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 9 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 9 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#75:)) MOD 4 = 0} => 
    L#75:: op ==  0 & op2 ==  6 & cond == 10 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#75:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 10 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBUE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 10 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBGE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#76:)) MOD 4 = 0} => 
    L#76:: op ==  0 & op2 ==  6 & cond == 11 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#76:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 11 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBGE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBGE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 11 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBUGE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#77:)) MOD 4 = 0} => 
    L#77:: op ==  0 & op2 ==  6 & cond == 12 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#77:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 12 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBUGE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBUGE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 12 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBLE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#78:)) MOD 4 = 0} => 
    L#78:: op ==  0 & op2 ==  6 & cond == 13 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#78:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 13 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBLE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBLE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 13 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBULE reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#79:)) MOD 4 = 0} => 
    L#79:: op ==  0 & op2 ==  6 & cond == 14 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#79:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 14 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBULE(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBULE");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 14 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FBO reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#80:)) MOD 4 = 0} => 
    L#80:: op ==  0 & op2 ==  6 & cond == 15 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#80:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 6 << 22 ORB 15 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void FBO(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 6 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor FBO");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 6 << 22 | 15 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBN reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#81:)) MOD 4 = 0} => 
    L#81:: op ==  0 & op2 ==  7 & cond ==  0 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#81:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 0 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CBN(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 0 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBN");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 0 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB123 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#82:)) MOD 4 = 0} => 
    L#82:: op ==  0 & op2 ==  7 & cond ==  1 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#82:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 1 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB123(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 1 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB123");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 1 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB12 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#83:)) MOD 4 = 0} => 
    L#83:: op ==  0 & op2 ==  7 & cond ==  2 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#83:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 2 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB12(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 2 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB12");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 2 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB13 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#84:)) MOD 4 = 0} => 
    L#84:: op ==  0 & op2 ==  7 & cond ==  3 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#84:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 3 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB13(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 3 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB13");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 3 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB1 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#85:)) MOD 4 = 0} => 
    L#85:: op ==  0 & op2 ==  7 & cond ==  4 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#85:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 4 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB1(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 4 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB1");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 4 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB23 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#86:)) MOD 4 = 0} => 
    L#86:: op ==  0 & op2 ==  7 & cond ==  5 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#86:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 5 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB23(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 5 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB23");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 5 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB2 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#87:)) MOD 4 = 0} => 
    L#87:: op ==  0 & op2 ==  7 & cond ==  6 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#87:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 6 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB2(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 6 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB2");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 6 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB3 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#88:)) MOD 4 = 0} => 
    L#88:: op ==  0 & op2 ==  7 & cond ==  7 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#88:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 7 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB3(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 7 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB3");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 7 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CBA reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#89:)) MOD 4 = 0} => 
    L#89:: op ==  0 & op2 ==  7 & cond ==  8 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#89:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 8 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CBA(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 8 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CBA");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 8 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB0 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#90:)) MOD 4 = 0} => 
    L#90:: op ==  0 & op2 ==  7 & cond ==  9 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#90:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 9 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB0(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 9 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB0");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 9 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB03 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#91:)) MOD 4 = 0} => 
    L#91:: op ==  0 & op2 ==  7 & cond == 10 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#91:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 10 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB03(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 10 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB03");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 10 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB02 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#92:)) MOD 4 = 0} => 
    L#92:: op ==  0 & op2 ==  7 & cond == 11 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#92:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 11 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB02(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 11 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB02");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 11 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB023 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#93:)) MOD 4 = 0} => 
    L#93:: op ==  0 & op2 ==  7 & cond == 12 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#93:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 12 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB023(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 12 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB023");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 12 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB01 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#94:)) MOD 4 = 0} => 
    L#94:: op ==  0 & op2 ==  7 & cond == 13 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#94:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 13 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB01(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 13 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB01");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 13 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB013 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#95:)) MOD 4 = 0} => 
    L#95:: op ==  0 & op2 ==  7 & cond == 14 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#95:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 14 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB013(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 14 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB013");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 14 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

CB012 reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#96:)) MOD 4 = 0} => 
    L#96:: op ==  0 & op2 ==  7 & cond == 15 & a ==  0 & disp22 = ((reloc - 
      LOCATION_OF(L#96:)) DIV 4)[22!]

***********/
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_1, 
    header = _clofun_1_closure_header, 
    values = {0 << 30 ORB 7 << 22 ORB 15 << 25 ORB 0 << 29}, 
    addresses = {reloc})
****************/
static void CB012(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      if (!((unsigned)(location(reloc) + 8388608 - cur_pc()) < 0x1000000)) 
        fail("`FORCE(reloc) - FORCE(<program counter>)' = %d won't fit in 24 signed bits.", 
          location(reloc) - cur_pc()); 
      else 
        
        emitb(0 << 30 | 7 << 22 | 15 << 25 | 0 << 29 | location(reloc) - 
            cur_pc() >> 2 & 0x3fffff, 4);  
    else 
      fail("Conditions not satisfied for constructor CB012");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_1_closure_header);
        _c->v.u1 = 0 << 30 | 7 << 22 | 15 << 25 | 0 << 29;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

call__ reloc is 
  (?noname?) {(reloc - LOCATION_OF(L#97:)) MOD 4 = 0} => 
    L#97:: op ==  1 & disp30 = ((reloc - LOCATION_OF(L#97:)) DIV 4)[30!]

***********/
/* CLOSURE FUNCTION _clofun_2 is 
  [
  1 cla force cl-loc force sub 0 1 bitslice 0 eq
  	{1 cla force cl-loc force sub -2 bitshift 30 narrows 1 clv orb cl-loc force 4 emit-at
  }
  true
  	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
  ] if-guard
 */
/* bytecode (24) is "\r\x15\v'\n\x03n]\x15\v'\xec\xf0%\x07\x85-~]\x01-M?\x00" */
static void _clofun_2(RClosure c, Emitter emitter, FailCont fail) {
  O1_1_Closure _c = (O1_1_Closure) c;
  
  if ((location(_c->v.a1) - pc_location(_c->loc) & 0x3) == 0) 
    
    emitter(_c->loc.dest_block, _c->loc.dest_lc, _c->v.u1 | 
      location(_c->v.a1) - pc_location(_c->loc) >> 2 & 0x3fffffff, 4); 
  else 
    fail("Conditions not satisfied for unnamed constructor"); 
  
}
static struct closure_header _clofun_2_closure_header = 
  { _clofun_2, O1_1_relocfn, 1, sizeof (struct O1_1_closure) };
/****************
CLOSURE IS: CLOSURE(
    type = O1_1, 
    fun = _clofun_2, 
    header = _clofun_2_closure_header, 
    values = {1 << 30}, 
    addresses = {reloc})
****************/
static void call__(RAddr reloc) {
  if (location_known(reloc) && cur_pc_known()) 
    if ((location(reloc) - cur_pc() & 0x3) == 0) 
      emitb(1 << 30 | location(reloc) - cur_pc() >> 2 & 0x3fffffff, 4); 
    else 
      fail("Conditions not satisfied for constructor call__");  
  else 
    { 
      { O1_1_Closure _c;
        _c = (O1_1_Closure) mc_create_closure_here(sizeof *_c, &_clofun_2_closure_header);
        _c->v.u1 = 1 << 30;
        _c->v.a1 = reloc;
        /* this line intentionally left blank */
      }  
       
      emitb(0 << 30 | 0 << 22 | 2989, 4); 
    } 
}
/**************

FMOVs fs2s, fds is 
  (FMOVs) op ==  2 & op3 == 52 & opf ==  1 & fs2s = fs2s & fds = fds

***********/
static void FMOVs(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 1 << 5 | fs2s & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FNEGs fs2s, fds is 
  (FNEGs) op ==  2 & op3 == 52 & opf ==  5 & fs2s = fs2s & fds = fds

***********/
static void FNEGs(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 5 << 5 | fs2s & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FABSs fs2s, fds is 
  (FABSs) op ==  2 & op3 == 52 & opf ==  9 & fs2s = fs2s & fds = fds

***********/
static void FABSs(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 9 << 5 | fs2s & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FSQRTs fs2s, fds is 
  (FSQRTs) op ==  2 & op3 == 52 & opf == 41 & fs2s = fs2s & fds = fds

***********/
static void FSQRTs(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 41 << 5 | fs2s & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FSQRTd fs2d, fdd is 
  (FSQRTd) op ==  2 & op3 == 52 & opf == 42 & fs2d = fs2d & fdd = fdd

***********/
static void FSQRTd(unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 42 << 5 | fs2d & 0x1f | (fdd & 0x1f) << 25, 4); 
}
/**************

FSQRTq fs2q, fdq is 
  (FSQRTq) op ==  2 & op3 == 52 & opf == 43 & fs2q = fs2q & fdq = fdq

***********/
static void FSQRTq(unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 43 << 5 | fs2q & 0x1f | (fdq & 0x1f) << 25, 4); 
}
/**************

FiTOs fs2s, fds is 
  (FiTOs) op ==  2 & op3 == 52 & opf == 196 & fs2s = fs2s & fds = fds

***********/
static void FiTOs(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 196 << 5 | fs2s & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FsTOi fs2s, fds is 
  (FsTOi) op ==  2 & op3 == 52 & opf == 209 & fs2s = fs2s & fds = fds

***********/
static void FsTOi(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 209 << 5 | fs2s & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FiTOd fs2s, fdd is 
  (FiTOd) op ==  2 & op3 == 52 & opf == 200 & fs2s = fs2s & fdd = fdd

***********/
static void FiTOd(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 200 << 5 | fs2s & 0x1f | (fdd & 0x1f) << 25, 4); 
}
/**************

FsTOd fs2s, fdd is 
  (FsTOd) op ==  2 & op3 == 52 & opf == 201 & fs2s = fs2s & fdd = fdd

***********/
static void FsTOd(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 201 << 5 | fs2s & 0x1f | (fdd & 0x1f) << 25, 4); 
}
/**************

FiTOq fs2s, fdq is 
  (FiTOq) op ==  2 & op3 == 52 & opf == 204 & fs2s = fs2s & fdq = fdq

***********/
static void FiTOq(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 204 << 5 | fs2s & 0x1f | (fdq & 0x1f) << 25, 4); 
}
/**************

FsTOq fs2s, fdq is 
  (FsTOq) op ==  2 & op3 == 52 & opf == 205 & fs2s = fs2s & fdq = fdq

***********/
static void FsTOq(unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 205 << 5 | fs2s & 0x1f | (fdq & 0x1f) << 25, 4); 
}
/**************

FdTOi fs2d, fds is 
  (FdTOi) op ==  2 & op3 == 52 & opf == 210 & fs2d = fs2d & fds = fds

***********/
static void FdTOi(unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 210 << 5 | fs2d & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FdTOs fs2d, fds is 
  (FdTOs) op ==  2 & op3 == 52 & opf == 198 & fs2d = fs2d & fds = fds

***********/
static void FdTOs(unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 198 << 5 | fs2d & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FqTOs fs2q, fds is 
  (FqTOs) op ==  2 & op3 == 52 & opf == 199 & fs2q = fs2q & fds = fds

***********/
static void FqTOs(unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 199 << 5 | fs2q & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FqTOi fs2q, fds is 
  (FqTOi) op ==  2 & op3 == 52 & opf == 211 & fs2q = fs2q & fds = fds

***********/
static void FqTOi(unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 211 << 5 | fs2q & 0x1f | (fds & 0x1f) << 25, 4); 
}
/**************

FqTOd fs2q, fdd is 
  (FqTOd) op ==  2 & op3 == 52 & opf == 203 & fs2q = fs2q & fdd = fdd

***********/
static void FqTOd(unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 203 << 5 | fs2q & 0x1f | (fdd & 0x1f) << 25, 4); 
}
/**************

FdTOq fs2d, fdq is 
  (FdTOq) op ==  2 & op3 == 52 & opf == 206 & fs2d = fs2d & fdq = fdq

***********/
static void FdTOq(unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 52 << 19 | 206 << 5 | fs2d & 0x1f | (fdq & 0x1f) << 25, 4); 
}
/**************

FADDs fs1s, fs2s, fds is 
  (FADDs) op ==  2 & op3 == 52 & opf == 65 & fs1s = fs1s & fs2s = fs2s & 
  fds = fds

***********/
static void FADDs(unsigned /* [0..31] */ fs1s, unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs1s) < 0x20)) 
    fail("field fs1s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 65 << 5 | (fs1s & 0x1f) << 14 | fs2s & 0x1f | 
      (fds & 0x1f) << 25, 4); 
}
/**************

FSUBs fs1s, fs2s, fds is 
  (FSUBs) op ==  2 & op3 == 52 & opf == 69 & fs1s = fs1s & fs2s = fs2s & 
  fds = fds

***********/
static void FSUBs(unsigned /* [0..31] */ fs1s, unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs1s) < 0x20)) 
    fail("field fs1s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 69 << 5 | (fs1s & 0x1f) << 14 | fs2s & 0x1f | 
      (fds & 0x1f) << 25, 4); 
}
/**************

FMULs fs1s, fs2s, fds is 
  (FMULs) op ==  2 & op3 == 52 & opf == 73 & fs1s = fs1s & fs2s = fs2s & 
  fds = fds

***********/
static void FMULs(unsigned /* [0..31] */ fs1s, unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs1s) < 0x20)) 
    fail("field fs1s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 73 << 5 | (fs1s & 0x1f) << 14 | fs2s & 0x1f | 
      (fds & 0x1f) << 25, 4); 
}
/**************

FDIVs fs1s, fs2s, fds is 
  (FDIVs) op ==  2 & op3 == 52 & opf == 77 & fs1s = fs1s & fs2s = fs2s & 
  fds = fds

***********/
static void FDIVs(unsigned /* [0..31] */ fs1s, unsigned /* [0..31] */ fs2s, unsigned /* [0..31] */ fds) {
  if (!((unsigned)(fs1s) < 0x20)) 
    fail("field fs1s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fds) < 0x20)) 
    fail("field fds does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 77 << 5 | (fs1s & 0x1f) << 14 | fs2s & 0x1f | 
      (fds & 0x1f) << 25, 4); 
}
/**************

FADDd fs1d, fs2d, fdd is 
  (FADDd) op ==  2 & op3 == 52 & opf == 66 & fs1d = fs1d & fs2d = fs2d & 
  fdd = fdd

***********/
static void FADDd(unsigned /* [0..31] */ fs1d, unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs1d) < 0x20)) 
    fail("field fs1d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 66 << 5 | (fs1d & 0x1f) << 14 | fs2d & 0x1f | 
      (fdd & 0x1f) << 25, 4); 
}
/**************

FSUBd fs1d, fs2d, fdd is 
  (FSUBd) op ==  2 & op3 == 52 & opf == 70 & fs1d = fs1d & fs2d = fs2d & 
  fdd = fdd

***********/
static void FSUBd(unsigned /* [0..31] */ fs1d, unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs1d) < 0x20)) 
    fail("field fs1d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 70 << 5 | (fs1d & 0x1f) << 14 | fs2d & 0x1f | 
      (fdd & 0x1f) << 25, 4); 
}
/**************

FMULd fs1d, fs2d, fdd is 
  (FMULd) op ==  2 & op3 == 52 & opf == 74 & fs1d = fs1d & fs2d = fs2d & 
  fdd = fdd

***********/
static void FMULd(unsigned /* [0..31] */ fs1d, unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs1d) < 0x20)) 
    fail("field fs1d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 74 << 5 | (fs1d & 0x1f) << 14 | fs2d & 0x1f | 
      (fdd & 0x1f) << 25, 4); 
}
/**************

FDIVd fs1d, fs2d, fdd is 
  (FDIVd) op ==  2 & op3 == 52 & opf == 78 & fs1d = fs1d & fs2d = fs2d & 
  fdd = fdd

***********/
static void FDIVd(unsigned /* [0..31] */ fs1d, unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs1d) < 0x20)) 
    fail("field fs1d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 78 << 5 | (fs1d & 0x1f) << 14 | fs2d & 0x1f | 
      (fdd & 0x1f) << 25, 4); 
}
/**************

FADDq fs1q, fs2q, fdq is 
  (FADDq) op ==  2 & op3 == 52 & opf == 67 & fs1q = fs1q & fs2q = fs2q & 
  fdq = fdq

***********/
static void FADDq(unsigned /* [0..31] */ fs1q, unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs1q) < 0x20)) 
    fail("field fs1q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 67 << 5 | (fs1q & 0x1f) << 14 | fs2q & 0x1f | 
      (fdq & 0x1f) << 25, 4); 
}
/**************

FSUBq fs1q, fs2q, fdq is 
  (FSUBq) op ==  2 & op3 == 52 & opf == 71 & fs1q = fs1q & fs2q = fs2q & 
  fdq = fdq

***********/
static void FSUBq(unsigned /* [0..31] */ fs1q, unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs1q) < 0x20)) 
    fail("field fs1q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 71 << 5 | (fs1q & 0x1f) << 14 | fs2q & 0x1f | 
      (fdq & 0x1f) << 25, 4); 
}
/**************

FMULq fs1q, fs2q, fdq is 
  (FMULq) op ==  2 & op3 == 52 & opf == 75 & fs1q = fs1q & fs2q = fs2q & 
  fdq = fdq

***********/
static void FMULq(unsigned /* [0..31] */ fs1q, unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs1q) < 0x20)) 
    fail("field fs1q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 75 << 5 | (fs1q & 0x1f) << 14 | fs2q & 0x1f | 
      (fdq & 0x1f) << 25, 4); 
}
/**************

FDIVq fs1q, fs2q, fdq is 
  (FDIVq) op ==  2 & op3 == 52 & opf == 79 & fs1q = fs1q & fs2q = fs2q & 
  fdq = fdq

***********/
static void FDIVq(unsigned /* [0..31] */ fs1q, unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs1q) < 0x20)) 
    fail("field fs1q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 79 << 5 | (fs1q & 0x1f) << 14 | fs2q & 0x1f | 
      (fdq & 0x1f) << 25, 4); 
}
/**************

FsMULd fs1d, fs2d, fdd is 
  (FsMULd) op ==  2 & op3 == 52 & opf == 105 & fs1d = fs1d & fs2d = fs2d & 
  fdd = fdd

***********/
static void FsMULd(unsigned /* [0..31] */ fs1d, unsigned /* [0..31] */ fs2d, unsigned /* [0..31] */ fdd) {
  if (!((unsigned)(fs1d) < 0x20)) 
    fail("field fs1d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdd) < 0x20)) 
    fail("field fdd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 105 << 5 | (fs1d & 0x1f) << 14 | fs2d & 0x1f | 
      (fdd & 0x1f) << 25, 4); 
}
/**************

FdMULq fs1q, fs2q, fdq is 
  (FdMULq) op ==  2 & op3 == 52 & opf == 110 & fs1q = fs1q & fs2q = fs2q & 
  fdq = fdq

***********/
static void FdMULq(unsigned /* [0..31] */ fs1q, unsigned /* [0..31] */ fs2q, unsigned /* [0..31] */ fdq) {
  if (!((unsigned)(fs1q) < 0x20)) 
    fail("field fs1q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fdq) < 0x20)) 
    fail("field fdq does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 52 << 19 | 110 << 5 | (fs1q & 0x1f) << 14 | fs2q & 0x1f | 
      (fdq & 0x1f) << 25, 4); 
}
/**************

FCMPs fs1s, fs2s is 
  (FCMPs) op ==  2 & op3 == 53 & opf == 81 & fs1s = fs1s & fs2s = fs2s

***********/
static void FCMPs(unsigned /* [0..31] */ fs1s, unsigned /* [0..31] */ fs2s) {
  if (!((unsigned)(fs1s) < 0x20)) 
    fail("field fs1s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 53 << 19 | 81 << 5 | (fs1s & 0x1f) << 14 | fs2s & 0x1f, 4); 
}
/**************

FCMPEs fs1s, fs2s is 
  (FCMPEs) op ==  2 & op3 == 53 & opf == 85 & fs1s = fs1s & fs2s = fs2s

***********/
static void FCMPEs(unsigned /* [0..31] */ fs1s, unsigned /* [0..31] */ fs2s) {
  if (!((unsigned)(fs1s) < 0x20)) 
    fail("field fs1s does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2s) < 0x20)) 
    fail("field fs2s does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 53 << 19 | 85 << 5 | (fs1s & 0x1f) << 14 | fs2s & 0x1f, 4); 
}
/**************

FCMPd fs1d, fs2d is 
  (FCMPd) op ==  2 & op3 == 53 & opf == 82 & fs1d = fs1d & fs2d = fs2d

***********/
static void FCMPd(unsigned /* [0..31] */ fs1d, unsigned /* [0..31] */ fs2d) {
  if (!((unsigned)(fs1d) < 0x20)) 
    fail("field fs1d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 53 << 19 | 82 << 5 | (fs1d & 0x1f) << 14 | fs2d & 0x1f, 4); 
}
/**************

FCMPEd fs1d, fs2d is 
  (FCMPEd) op ==  2 & op3 == 53 & opf == 86 & fs1d = fs1d & fs2d = fs2d

***********/
static void FCMPEd(unsigned /* [0..31] */ fs1d, unsigned /* [0..31] */ fs2d) {
  if (!((unsigned)(fs1d) < 0x20)) 
    fail("field fs1d does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2d) < 0x20)) 
    fail("field fs2d does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 53 << 19 | 86 << 5 | (fs1d & 0x1f) << 14 | fs2d & 0x1f, 4); 
}
/**************

FCMPq fs1q, fs2q is 
  (FCMPq) op ==  2 & op3 == 53 & opf == 83 & fs1q = fs1q & fs2q = fs2q

***********/
static void FCMPq(unsigned /* [0..31] */ fs1q, unsigned /* [0..31] */ fs2q) {
  if (!((unsigned)(fs1q) < 0x20)) 
    fail("field fs1q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 53 << 19 | 83 << 5 | (fs1q & 0x1f) << 14 | fs2q & 0x1f, 4); 
}
/**************

FCMPEq fs1q, fs2q is 
  (FCMPEq) op ==  2 & op3 == 53 & opf == 87 & fs1q = fs1q & fs2q = fs2q

***********/
static void FCMPEq(unsigned /* [0..31] */ fs1q, unsigned /* [0..31] */ fs2q) {
  if (!((unsigned)(fs1q) < 0x20)) 
    fail("field fs1q does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(fs2q) < 0x20)) 
    fail("field fs2q does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 53 << 19 | 87 << 5 | (fs1q & 0x1f) << 14 | fs2q & 0x1f, 4); 
}
/**************

NOP  is (NOP) op ==  0 & op2 ==  4 & rd ==  0 & imm22 ==  0

***********/
static void NOP(void) {
  emitb(0 << 30 | 4 << 22 | 0 << 25, 4);
}
/**************

FLUSH address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 59 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void FLUSH(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 59 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 59 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 59 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(2 << 30 | 59 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

JMPL address_, rd is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = rd
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = rd
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = rd
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 56 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = rd
  END (* address_ *)

***********/
static void JMPL(address__Instance address_, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (address_.tag) {
      case absoluteA_TAG: 
        
        emitb(2 << 30 | 56 << 19 | 1 << 13 | 0 << 14 | 
          address_.u.absoluteA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case dispA_TAG: 
        
        emitb(2 << 30 | 56 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
          address_.u.dispA.simm13 & 0x1fff | (rd & 0x1f) << 25, 4); 
        break;
      case indexA_TAG: 
        
        emitb(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
          address_.u.indexA.rs2 | (rd & 0x1f) << 25, 4); 
        break;
      case indirectA_TAG: 
        
        emitb(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* address_ */ 
}
/**************

RETT address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 57 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void RETT(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 57 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 57 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 57 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      emitb(2 << 30 | 57 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TN address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  0 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TN(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 0 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 0 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 0 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 0 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  1 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 1 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 1 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 1 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 1 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TLE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  2 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TLE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 2 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 2 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 2 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 2 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TL address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  3 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TL(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 3 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 3 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 3 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 3 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TLEU address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  4 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TLEU(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 4 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 4 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 4 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 4 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TCS address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  5 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TCS(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 5 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 5 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 5 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 5 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TNEG address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  6 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TNEG(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 6 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 6 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 6 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 6 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TVS address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  7 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TVS(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 7 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 7 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 7 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 7 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TA address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  8 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TA(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 8 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 8 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 8 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 8 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TNE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond ==  9 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TNE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 9 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 9 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 9 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 9 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TG address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 10 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TG(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 10 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 10 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 10 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 10 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TGE address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 11 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TGE(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 11 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 11 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 11 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 11 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TGU address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 12 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TGU(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 12 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 12 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 12 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 12 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TCC address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 13 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TCC(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 13 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 13 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 13 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 13 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TPOS address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 14 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TPOS(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 14 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 14 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 14 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 14 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

TVC address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  1 & 
      rs1 ==  0 & simm13 = address_.absoluteA.simm13
  | dispA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13
  | indexA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2
  | indirectA => 
      (?noname?) (?address_:): op ==  2 & op3 == 58 & cond == 15 & i ==  0 & 
      rs2 ==  0 & rs1 = address_.indirectA.rs1
  END (* address_ *)

***********/
static void TVC(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 15 << 25 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 15 << 25 | 1 << 13 | 
        address_.u.dispA.rs1 << 14 | address_.u.dispA.simm13 & 0x1fff, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 15 << 25 | 0 << 13 | 
        address_.u.indexA.rs1 << 14 | address_.u.indexA.rs2, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 58 << 19 | 15 << 25 | 0 << 13 | 
        address_.u.indirectA.rs1 << 14, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

UNIMP imm22 is (UNIMP) op ==  0 & op2 ==  0 & imm22 = imm22

***********/
static void UNIMP(unsigned /* [0..4194303] */ imm22) {
  if (!((unsigned)(imm22) < 0x400000)) 
    fail("field imm22 does not fit in 22 unsigned bits"); 
  else 
    emitb(0 << 30 | 0 << 22 | imm22 & 0x3fffff, 4); 
}
/**************

sethi %hi(val), rd is 
  (SETHI) {val[0:9] = 0} => op ==  0 & op2 ==  4 & rd = rd & imm22 = val[10:31]

***********/
static void sethi(int val, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if ((val & 0x3ff) == 0) 
      emitb(0 << 30 | 4 << 22 | (rd & 0x1f) << 25 | val >> 10 & 0x3fffff, 4); 
    else 
      fail("Conditions not satisfied for constructor sethi");  
}
/**************

cmp rs1, reg_or_imm is 
  
  CASE reg_or_imm OF 
  | imode => 
      (SUBcc) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = 0
  | rmode => 
      (SUBcc) (?reg_or_imm:): op ==  2 & op3 == 20 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = 0
  END (* reg_or_imm *)

***********/
static void cmp(unsigned /* [0..31] */ rs1, reg_or_imm_Instance reg_or_imm) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 20 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 0 << 25, 
          4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 20 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | 0 << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

jmp address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | indexA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
static void jmp(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

call_ address_ is 
  
  CASE address_ OF 
  | absoluteA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = 15
  | dispA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 15
  | indexA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 15
  | indirectA => 
      (JMPL) (?address_:): op ==  2 & op3 == 56 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = 15
  END (* address_ *)

***********/
static void call_(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 15 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 15 << 25, 4); 
      break;
    case indexA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 15 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(2 << 30 | 56 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        15 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

tst rs2 is (ORcc) op ==  2 & op3 == 18 & i ==  0 & rs2 = rs2 & rs1 = 0 & rd = 0

***********/
static void tst(unsigned /* [0..31] */ rs2) {
  if (!((unsigned)(rs2) < 0x20)) 
    fail("field rs2 does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 18 << 19 | 0 << 13 | rs2 & 0x1f | 0 << 14 | 0 << 25, 4); 
}
/**************

ret  is (JMPL) op ==  2 & op3 == 56 & i ==  1 & rs1 = 31 & simm13 = 8 & rd = 0

***********/
static void ret(void) {
  emitb(2 << 30 | 56 << 19 | 1 << 13 | 31 << 14 | 8 | 0 << 25, 4);
}
/**************

retl  is (JMPL) op ==  2 & op3 == 56 & i ==  1 & rs1 = 15 & simm13 = 8 & rd = 0

***********/
static void retl(void) {
  emitb(2 << 30 | 56 << 19 | 1 << 13 | 15 << 14 | 8 | 0 << 25, 4);
}
/**************

restore_  is 
  (RESTORE) op ==  2 & op3 == 61 & i ==  0 & rs2 = 0 & rs1 = 0 & rd = 0

***********/
static void restore_(void) {
  emitb(2 << 30 | 61 << 19 | 0 << 13 | 0 << 14 | 0 << 25, 4);
}
/**************

save_  is (SAVE) op ==  2 & op3 == 60 & i ==  0 & rs2 = 0 & rs1 = 0 & rd = 0

***********/
static void save_(void) {
  emitb(2 << 30 | 60 << 19 | 0 << 13 | 0 << 14 | 0 << 25, 4);
}
/**************

not rd is (XNOR) op ==  2 & op3 ==  7 & i ==  0 & rs2 = 0 & rs1 = rd & rd = rd

***********/
static void not(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 7 << 19 | 0 << 13 | (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 
      4); 
}
/**************

not2 rs1, rd is 
  (XNOR) op ==  2 & op3 ==  7 & i ==  0 & rs2 = 0 & rs1 = rs1 & rd = rd

***********/
static void not2(unsigned /* [0..31] */ rs1, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 7 << 19 | 0 << 13 | (rs1 & 0x1f) << 14 | (rd & 0x1f) << 25, 
      4); 
}
/**************

neg rd is (SUB) op ==  2 & op3 ==  4 & i ==  0 & rs2 = rd & rs1 = 0 & rd = rd

***********/
static void neg(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 4 << 19 | 0 << 13 | rd & 0x1f | 0 << 14 | 
      (rd & 0x1f) << 25, 4); 
}
/**************

neg2 rs2, rd is 
  (SUB) op ==  2 & op3 ==  4 & i ==  0 & rs2 = rs2 & rs1 = 0 & rd = rd

***********/
static void neg2(unsigned /* [0..31] */ rs2, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs2) < 0x20)) 
    fail("field rs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 4 << 19 | 0 << 13 | rs2 & 0x1f | 0 << 14 | 
      (rd & 0x1f) << 25, 4); 
}
/**************

inc simm13, rd is 
  (ADD) op ==  2 & op3 ==  0 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
static void inc(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitb(2 << 30 | 0 << 19 | 1 << 13 | simm13 & 0x1fff | (rd & 0x1f) << 14 | 
        (rd & 0x1f) << 25, 4);  
}
/**************

inccc simm13, rd is 
  (ADDcc) op ==  2 & op3 == 16 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
static void inccc(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitb(2 << 30 | 16 << 19 | 1 << 13 | simm13 & 0x1fff | 
        (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4);  
}
/**************

dec simm13, rd is 
  (SUB) op ==  2 & op3 ==  4 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
static void dec(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitb(2 << 30 | 4 << 19 | 1 << 13 | simm13 & 0x1fff | (rd & 0x1f) << 14 | 
        (rd & 0x1f) << 25, 4);  
}
/**************

deccc simm13, rd is 
  (SUBcc) op ==  2 & op3 == 20 & i ==  1 & simm13 = simm13[13!] & rs1 = rd & 
  rd = rd

***********/
static void deccc(unsigned /* [0..8191] */ simm13, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(simm13) < 0x2000)) 
    fail("field simm13 does not fit in 13 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    if (!((unsigned)(simm13 + 4096) < 0x2000)) 
      fail("`simm13' = %d won't fit in 13 signed bits.", simm13); 
    else 
      
      emitb(2 << 30 | 20 << 19 | 1 << 13 | simm13 & 0x1fff | 
        (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4);  
}
/**************

btst reg_or_imm, rs1 is 
  
  CASE reg_or_imm OF 
  | imode => 
      (ANDcc) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rs1 & rd = 0
  | rmode => 
      (ANDcc) (?reg_or_imm:): op ==  2 & op3 == 17 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rs1 & rd = 0
  END (* reg_or_imm *)

***********/
static void btst(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rs1) {
  if (!((unsigned)(rs1) < 0x20)) 
    fail("field rs1 does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 17 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rs1 & 0x1f) << 14 | 0 << 25, 
          4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 17 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rs1 & 0x1f) << 14 | 0 << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

bset reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rd & rd = rd
  | rmode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rd & rd = rd
  END (* reg_or_imm *)

***********/
static void bset(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 2 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rd & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 2 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

bclr reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (ANDN) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rd & rd = rd
  | rmode => 
      (ANDN) (?reg_or_imm:): op ==  2 & op3 ==  5 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rd & rd = rd
  END (* reg_or_imm *)

***********/
static void bclr(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 5 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rd & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 5 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

btog reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (XOR) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = rd & rd = rd
  | rmode => 
      (XOR) (?reg_or_imm:): op ==  2 & op3 ==  3 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = rd & rd = rd
  END (* reg_or_imm *)

***********/
static void btog(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 3 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | (rd & 0x1f) << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 3 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 
          (rd & 0x1f) << 14 | (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

clr rd is (OR) op ==  2 & op3 ==  2 & i ==  0 & rs2 = 0 & rs1 = 0 & rd = rd

***********/
static void clr(unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    emitb(2 << 30 | 2 << 19 | 0 << 13 | 0 << 14 | (rd & 0x1f) << 25, 4); 
}
/**************

clr_ [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | indexA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (ST) (?address_:): op ==  3 & op3 ==  4 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
static void clr_(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 4 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 4 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(3 << 30 | 4 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

clrb [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | indexA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (STB) (?address_:): op ==  3 & op3 ==  5 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
static void clrb(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 5 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 5 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(3 << 30 | 5 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

clrh [address_] is 
  
  CASE address_ OF 
  | absoluteA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & rs1 ==  0 & 
      simm13 = address_.absoluteA.simm13 & rd = 0
  | dispA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  1 & 
      rs1 = address_.dispA.rs1 & simm13 = address_.dispA.simm13 & rd = 0
  | indexA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & 
      rs1 = address_.indexA.rs1 & rs2 = address_.indexA.rs2 & rd = 0
  | indirectA => 
      (STH) (?address_:): op ==  3 & op3 ==  6 & i ==  0 & rs2 ==  0 & 
      rs1 = address_.indirectA.rs1 & rd = 0
  END (* address_ *)

***********/
static void clrh(address__Instance address_) {
  switch (address_.tag) {
    case absoluteA_TAG: 
      
      emitb(3 << 30 | 6 << 19 | 1 << 13 | 0 << 14 | 
        address_.u.absoluteA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case dispA_TAG: 
      
      emitb(3 << 30 | 6 << 19 | 1 << 13 | address_.u.dispA.rs1 << 14 | 
        address_.u.dispA.simm13 & 0x1fff | 0 << 25, 4); 
      break;
    case indexA_TAG: 
      
      emitb(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indexA.rs1 << 14 | 
        address_.u.indexA.rs2 | 0 << 25, 4); 
      break;
    case indirectA_TAG: 
      
      emitb(3 << 30 | 6 << 19 | 0 << 13 | address_.u.indirectA.rs1 << 14 | 
        0 << 25, 4); 
      break;
    default: assert(0);
  } /* address_ */
}
/**************

mov reg_or_imm, rd is 
  
  CASE reg_or_imm OF 
  | imode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  1 & 
      simm13 = reg_or_imm.imode.simm13 & rs1 = 0 & rd = rd
  | rmode => 
      (OR) (?reg_or_imm:): op ==  2 & op3 ==  2 & i ==  0 & 
      rs2 = reg_or_imm.rmode.rs2 & rs1 = 0 & rd = rd
  END (* reg_or_imm *)

***********/
static void mov(reg_or_imm_Instance reg_or_imm, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    switch (reg_or_imm.tag) {
      case imode_TAG: 
        
        emitb(2 << 30 | 2 << 19 | 1 << 13 | 
          reg_or_imm.u.imode.simm13 & 0x1fff | 0 << 14 | (rd & 0x1f) << 25, 4); 
        break;
      case rmode_TAG: 
        
        emitb(2 << 30 | 2 << 19 | 0 << 13 | reg_or_imm.u.rmode.rs2 | 0 << 14 | 
          (rd & 0x1f) << 25, 4); 
        break;
      default: assert(0);
    } /* reg_or_imm */ 
}
/**************

mov_ rs2, rd is 
  (OR) op ==  2 & op3 ==  2 & i ==  0 & rs2 = rs2 & rs1 = 0 & rd = rd

***********/
static void mov_(unsigned /* [0..31] */ rs2, unsigned /* [0..31] */ rd) {
  if (!((unsigned)(rs2) < 0x20)) 
    fail("field rs2 does not fit in 5 unsigned bits"); 
  else if (!((unsigned)(rd) < 0x20)) 
    fail("field rd does not fit in 5 unsigned bits"); 
  else 
    
    emitb(2 << 30 | 2 << 19 | 0 << 13 | rs2 & 0x1f | 0 << 14 | 
      (rd & 0x1f) << 25, 4); 
}

static struct sparc_enc_t encoding_procs = {dispA, absoluteA, indexA, 
  indirectA, imode, rmode, LDSB, LDSH, LDUB, LDUH, LD, LDSTUB, SWAP_, LDD, LDF, 
  LDDF, LDC, LDDC, STB, STH, ST, STD, STF, STDF, STC, STDC, indexR, indirectR, 
  LDSBA, LDSHA, LDUBA, LDUHA, LDA, LDSTUBA, SWAPA, LDDA, STBA, STHA, STA, STDA, 
  LDFSR, LDCSR, STFSR, STCSR, STDFQ, STDCQ, RDY, RDPSR, RDWIM, RDTBR, WRY, 
  WRPSR, WRWIM, WRTBR, RDASR, WRASR, STBAR, AND, ANDcc, ANDN, ANDNcc, OR, ORcc, 
  ORN, ORNcc, XOR, XORcc, XNOR, XNORcc, SLL, SRL, SRA, ADD, ADDcc, ADDX, 
  ADDXcc, TADDcc, TADDccTV, SUB, SUBcc, SUBX, SUBXcc, TSUBcc, TSUBccTV, MULScc, 
  UMUL, SMUL, UMULcc, SMULcc, UDIV, SDIV, UDIVcc, SDIVcc, SAVE, RESTORE, BN_a, 
  BE_a, BLE_a, BL_a, BLEU_a, BCS_a, BNEG_a, BVS_a, BA_a, BNE_a, BG_a, BGE_a, 
  BGU_a, BCC_a, BPOS_a, BVC_a, FBN_a, FBNE_a, FBLG_a, FBUL_a, FBL_a, FBUG_a, 
  FBG_a, FBU_a, FBA_a, FBE_a, FBUE_a, FBGE_a, FBUGE_a, FBLE_a, FBULE_a, FBO_a, 
  CBN_a, CB123_a, CB12_a, CB13_a, CB1_a, CB23_a, CB2_a, CB3_a, CBA_a, CB0_a, 
  CB03_a, CB02_a, CB023_a, CB01_a, CB013_a, CB012_a, BN, BE, BLE, BL, BLEU, 
  BCS, BNEG, BVS, BA, BNE, BG, BGE, BGU, BCC, BPOS, BVC, FBN, FBNE, FBLG, FBUL, 
  FBL, FBUG, FBG, FBU, FBA, FBE, FBUE, FBGE, FBUGE, FBLE, FBULE, FBO, CBN, 
  CB123, CB12, CB13, CB1, CB23, CB2, CB3, CBA, CB0, CB03, CB02, CB023, CB01, 
  CB013, CB012, call__, FMOVs, FNEGs, FABSs, FSQRTs, FSQRTd, FSQRTq, FiTOs, 
  FsTOi, FiTOd, FsTOd, FiTOq, FsTOq, FdTOi, FdTOs, FqTOs, FqTOi, FqTOd, FdTOq, 
  FADDs, FSUBs, FMULs, FDIVs, FADDd, FSUBd, FMULd, FDIVd, FADDq, FSUBq, FMULq, 
  FDIVq, FsMULd, FdMULq, FCMPs, FCMPEs, FCMPd, FCMPEd, FCMPq, FCMPEq, NOP, 
  FLUSH, JMPL, RETT, TN, TE, TLE, TL, TLEU, TCS, TNEG, TVS, TA, TNE, TG, TGE, 
  TGU, TCC, TPOS, TVC, UNIMP, sethi, cmp, jmp, call_, tst, ret, retl, restore_, 
  save_, not, not2, neg, neg2, inc, inccc, dec, deccc, btst, bset, bclr, btog, 
  clr, clr_, clrb, clrh, mov, mov_, 
};
struct sparc_enc_t *sparc_enc = &encoding_procs;
/*****************************
  _clofun_2 = 
    [
    1 cla force cl-loc force sub 0 1 bitslice 0 eq
    	{1 cla force cl-loc force sub -2 bitshift 30 narrows 1 clv orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  _clofun_1 = 
    [
    1 cla force cl-loc force sub 0 1 bitslice 0 eq
    	{1 cla force cl-loc force sub -2 bitshift 22 narrows 1 clv orb cl-loc force 4 emit-at
    }
    true
    	{"Conditions not satisfied for unnamed constructor" [ ] failmsg}
    ] if-guard
  
****************/
ClosurePostfix sparc_encoder_clofuns[] = {
  { _clofun_2, "[\n1 cla force cl-loc force sub 0 1 bitslice 0 eq\n\t{1 cla force cl-loc force sub -2 bitshift 30 narrows 1 clv orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { _clofun_1, "[\n1 cla force cl-loc force sub 0 1 bitslice 0 eq\n\t{1 cla force cl-loc force sub -2 bitshift 22 narrows 1 clv orb cl-loc force 4 emit-at\n}\ntrue\n\t{\"Conditions not satisfied for unnamed constructor\" [ ] failmsg}\n] if-guard" }, 
  { (ApplyMethod) 0, (char *) 0 }
};
