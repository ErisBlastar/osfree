--------W-20----Vx0001-----------------------
INT 20 P - Microsoft Windows - VMM - VxD SERVICES
        VxD = 0001h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01265)
Values for VMM (VxD ID 0001h) service number:
 0000h  get version
 0001h  get current VM handle
 0002h  test current VM handle
 0003h  get system VM handle
 0004h  test system VM handle
 0005h  validate VM handle
 0006h  get VMM reenter count
 0007h  begin reentrant execution
 0008h  end reentrant execution
 0009h  install V86 breakpoint
 000Ah  remove V86 breakpoint
 000Bh  allocate V86 callback
 000Ch  allocation PM callback
 000Dh  call when VM returns
 000Eh  schedule global event
 000Fh  schedule VM event
 0010h  call global event
 0011h  call VM event
 0012h  cancel global event
 0013h  cancel VM event
 0014h  call priority VM event
 0015h  cancel priority VM event
 0016h  get NMI handler address
 0017h  set NMI handler address
 0018h  hook NMI event
 0019h  call when VM interrupts enabled
 001Ah  enable VM interrupts
 001Bh  disable VM interrupts
 001Ch  map flat
 001Dh  map linear to VM address
 001Eh  adjust execution priority
 001Fh  begin critical section
 0020h  end critical section
 0021h  end critical section and suspend
 0022h  claim critical section
 0023h  release critical section
 0024h  call when not critical
 0025h  create semaphore
 0026h  destroy semaphore
 0027h  wait on semaphore
 0028h  signal semaphore
 0029h  get critical section status
 002Ah  call when task switched
 002Bh  suspend VM
 002Ch  resume VM
 002Dh  no-fail resume VM
 002Eh  nuke VM
 002Fh  crash current VM
 0030h  get execution focus
 0031h  set execution focus
 0032h  get time slice priority
 0033h  set time slice priority
 0034h  get time slice granularity
 0035h  set time slice granularity
 0036h  get time slice information
 0037h  adjust execution time
 0038h  release time slice
 0039h  wake up VM
 003Ah  call when idle
 003Bh  get next VM handle
 003Ch  set global timeout
 003Dh  set VM timeout
 003Eh  cancel timeout
 003Fh  get system time
        Return: EAX = time in milliseconds that Windows has been running
 0040h  get VM execution time
 0041h  hook V86 interrupt chain
 0042h  get V86 interrupt vector
 0043h  set V86 interrupt vector
 0044h  get PM interrupt vector
 0045h  set PM interrupt vector
 0046h  simulate interrupt
 0047h  simulate IRET
 0048h  simulate far call
 0049h  simulate far jump
 004Ah  simulate far RET
 004Bh  simulate far RET N
 004Ch  build interrupt stack frame
 004Dh  simulate push
 004Eh  simulate pop
 004Fh  _HeapAllocate
 0050h  _HeapReAllocate
 0051h  _HeapFree
 0052h  _HeapGetSize
 0053h  _PageAllocate
 0054h  _PageReAllocate
 0055h  _PageFree
 0056h  _PageLock
 0057h  _PageUnLock
 0058h  _PageGetSizeAddr
 0059h  _PageGetAllocInfo
 005Ah  _GetFreePageCount
 005Bh  _GetSysPageCount
 005Ch  _GetVMPgCount
 005Dh  _MapIntoV86
 005Eh  _PhysIntoV86
 005Fh  _TestGlobalV86Mem
 0060h  _ModifyPageBits
 0061h  copy page table
 0062h  map linear into V86
 0063h  linear page lock
 0064h  linear page unlock
 0065h  _SetResetV86Pageabl
 0066h  _GetV86PageableArray
 0067h  _PageCheckLinRange
 0068h  page out dirty pages
 0069h  discard pages
 006Ah  _GetNulPageHandle
 006Bh  get first V86 page
 006Ch  map physical address to linear address
 006Dh  _GetAppFlatDSAlias
 006Eh  _SelectorMapFlat
 006Fh  _GetDemandPageInfo
 0070h  _GetSetPageOutCount
 0071h  hook V86 page
 0072h  assign device V86 pages
 0073h  deassign device V86 pages
 0074h  get array of V86 pages for device
 0075h  _SetNULPageAddr
 0076h  allocate GDT selector
 0077h  free GDT selector
 0078h  allocate LDT selector
 0079h  free LDT selector
 007Ah  _BuildDescriptorDWORDs
 007Bh  get descriptor
 007Ch  set descriptor
 007Dh  toggle HMA
 007Eh  get fault hook addresses
 007Fh  hook V86 fault
 0080h  hook PM fault
 0081h  hook VMM fault
 0082h  begin nested V86 execution
 0083h  begin nested execution
 0084h  execute V86-mode interrupt
 0085h  resume execution
 0086h  end nested execution
 0087h  allocate PM application callback area
 0088h  get current PM application callback area
 0089h  set V86 execution mode
 008Ah  set PM execution mode
 008Bh  begin using locked PM stack
 008Ch  end using locked PM stack
 008Dh  save client state
 008Eh  restore client state
 008Fh  execute VxD interrupt
        STACK:  WORD    interrupt number
                other registers as required by interrupt call
        Return: registers as returned by interrupt call
 0090h  hook device service
        EAX = service ID (high word = VxD ID, low = service number)
        ESI -> new handler
 0091h  hook device V86 API
 0092h  hook device PM API
 0093h  system control (see also #02657)
 0094h  simulate I/O
 0095h  install multiple I/O handlers
 0096h  install I/O handler
        DX = I/O port address
        ESI -> handler to call when I/O access attempted???
 0097h  enable global trapping
        DX = I/O port address
 0098h  enable local trapping
        DX = I/O port address
 0099h  disable global trapping
        DX = I/O port address
 009Ah  disable local trapping
        DX = I/O port address
 009Bh  create list
 009Ch  destroy list
 009Dh  allocate list
 009Eh  attach list
 009Fh  attach list tail
 00A0h  insert into list
 00A1h  remove from list
 00A2h  deallocate list
 00A3h  get first item in list
 00A4h  get next item in list
 00A5h  remove first item in list
 00A6h  add instance item
 00A7h  allocate device callback area
 00A8h  allocate global V86 data area
 00A9h  allocate temporary V86 data area
 00AAh  free temporary V86 data area
 00ABh  get decimal integer from profile
 00ACh  convert decimal string to integer
 00ADh  get fixed-point number from profile
 00AEh  convert fixed-point string
 00AFh  get hex integer from profile
 00B0h  convert hex string to integer
 00B1h  get boolean value from profile
 00B2h  convert boolean string
 00B3h  get string from profile
 00B4h  get next string from profile
 00B5h  get environment string
 00B6h  get exec path
 00B7h  get configuration directory
 00B8h  open file
 00B9h  get PSP segment
 00BAh  get DOS vectors
 00BBh  get machine information
 00BCh  get/set HMA information
 00BDh  set system exit code
 00BEh  fatal error handler
 00BFh  fatal memory error
 00C0h  update system clock
 00C1h  test if debugger installed
 00C2h  output debugger string
 00C3h  output debugger character
 00C4h  input debugger character
 00C5h  debugger convert hex to binary
 00C6h  debugger convert hex to decimal
 00C7h  debugger test if valid handle
 00C8h  validate client pointer
 00C9h  test reentry
 00CAh  queue debugger string
 00CBh  log procedure call
 00CCh  debugger test current VM
 00CDh  get PM interrupt type
 00CEh  set PM interrupt type
 00CFh  get last updated system time
 00D0h  get last updated VM execution time
 00D1h  test if double-byte character-set lead byte
 00D2h  _AddFreePhysPage
 00D3h  _PageResetHandlePAddr
 00D4h  _SetLastV86Page
 00D5h  _GetLastV86Page
 00D6h  _MapFreePhysReg
 00D7h  _UnmapFreePhysReg
 00D8h  _XchgFreePhysReg
 00D9h  _SetFreePhysRegCalBk
 00DAh  get next arena (MCB)
 00DBh  get name of ugly TSR
 00DCh  get debug options
 00DDh  set physical HMA alias
 00DEh  _GetGlblRng0V86IntBase
 00DFh  add global V86 data area
 00E0h  get/set detailed VM error
 00E1h  Is_Debug_Chr
 00E2h  clear monochrome screen
 00E3h  output character to mono screen
 00E4h  output string to mono screen
 00E5h  set current position on mono screen
 00E6h  get current position on mono screen
 00E7h  get character from mono screen
 00E8h  locate byte in ROM
 00E9h  hook invalid page fault
 00EAh  unhook invalid page fault
 00EBh  set delete on exit file
 00ECh  close VM
 00EDh  "Enable_Touch_1st_Meg"
 00EEh  "Disable_Touch_1st_Meg"
 00EFh  install exception handler
 00F0h  remove exception handler
 00F1h  "Get_Crit_Status_No_Block"
 00F2h  "_Schedule_VM_RTI_Event"
 00F3h  "_Trace_Out_Service"
 00F4h  "_Debug_Out_Service"
 00F5h  "_Debug_Flags_Service"
 00F6h  VMM add import module name
 00F7h  VMM Add DDB
 00F8h  VMM Remove DDB
 00F9h  get thread time slice priority
 00FAh  set thread time slice priority
 00FBh  schedule thread event
 00FCh  cancel thread event
 00FDh  set thread timeout
 00FEh  set asynchronous timeout
 00FFh  "_AllocatreThreadDataSlot"
 0100h  "_FreeThreadDataSlot"
 0101h  create Mutex
 0102h  destroy Mutex
 0103h  get Mutex owner
 0104h  call when thread switched
 0105h  create thread
 0106h  start thread
 0107h  terminate thread
 0108h  get current thread handle
 0109h  test current thread handle
 010Ah  "Get_Sys_Thread_Handle"
 010Bh  "Test_Sys_Thread_Handle"
 010Ch  "Validate_Thread_Handle"
 010Dh  "Get_Initial_Thread_Handle"
 010Eh  "Test_Initial_Thread_Handle"
 010Fh  "Debug_Test_Valid_Thread_Handle"
 0110h  "Debug_Test_Cur_Thread"
 0111h  "VMM_GetSystemInitState"
 0112h  "Cancel_Call_When_Thread_Switched"
 0113h  "Get_Next_Thread_Handle"
 0114h  "Adjust_Thread_Exec_Priority"
 0115h  "_Deallocate_Device_CB_Area"
 0116h  "Remove_IO_Handler"
 0117h  "Remove_Mult_IO_Handlers"
 0118h  unhook V86 interrupt chain
 0119h  unhook V86 fault handler
 011Ah  unhook PM fault handler
 011Bh  unhook VMM fault handler
 011Ch  unhook device service
 011Dh  "_PageReserve"
 011Eh  "_PageCommit"
 011Fh  "_PageDecommit"
 0120h  "_PagerRegister"
 0121h  "_PagerQuery"
 0122h  "_PagerDeregister"
 0123h  "_ContextCreate"
 0124h  "_ContextDestroy"
 0125h  "_PageAttach"
 0126h  "_PageFlush"
 0127h  "_SignalID"
 0128h  "_PageCommitPhys"
 0129h  "_Register_Win32_Services"
 012Ah  "Cancel_Call_When_Not_Critical"
 012Bh  "Cancel_Call_When_Idle"
 012Ch  "Cancel_Call_When_Task_Switched"
 012Dh  "_Debug_Printf_Service"
 012Eh  enter Mutex
 012Fh  leave Mutex
 0130h  simulate VM I/O
 0131h  "Signal_Semaphore_No_Switch"
 0132h  "_MMSwitchContext"
 0133h  "_MMModifyPermissions"
 0134h  "_MMQuery"
 0135h  "_EnterMustComplete"
 0136h  "_LeaveMustComplete"
 0137h  "_ResumeExecMustComplete"
 0138h  get thread termination status
 0139h  "_GetInstanceInfo"
 013Ah  "_ExecIntMustComplete"
 013Bh  "_ExecVxDIntMustComplete"
 013Ch  begin V86 serialization
 013Dh  unhook V86 page
 013Eh  "VMM_GetVxDLocationList"
 013Fh  "VMM_GetDDBList" get start of VxD chain
        (see also #02657 at INT 2F/AX=1684h/BX=0017h)
 0140h  unhook NMI event
 0141h  "Get_Instanced_V86_Int_Vector"
 0142h  get or set real DOS PSP
 0143h  call priority thread event
 0144h  "Get_System_Time_Address"
 0145h  "Get_Crit_Status_Thread"
 0146h  "Get_DDB"
 0147h  "Directed_Sys_Control"
 0148h  "_RegOpenKey"
 0149h  "_RegCloseKey"
 014Ah  "_RegCreateKey"
 014Bh  "_RegDeleteKey"
 014Ch  "_RegEnumKey"
 014Dh  "_RegQueryValue"
 014Eh  "_RegSetValue"
 014Fh  "_RegDeleteValue"
 0150h  "_RegEnumValue"
 0151h  "_RegQueryValueEx"
 0152h  "_RegSetValueEx"
 0153h  "_CallRing3"
 0154h  "Exec_PM_Int"
 0155h  "_RegFlushKey"
 0156h  "_PageCommitContig"
 0157h  "_GetCurrentContext"
 0158h  "_LocalizeSprintf"
 0159h  "_LocalizeStackSprintf"
 015Ah  "Call_Restricted_Event"
 015Bh  "Cancel_Restricted_Event"
 015Ch  "Register_PEF_Provider"
 015Dh  "_GetPhysPageInfo"
 015Eh  "_RegQueryInfoKey"
 015Fh  "MemArb_Reserve_Pages"
 0160h  "Time_Slice_Sys_VM_Idle"
 0161h  "Time_Slice_Sleep"
 0162h  "Boost_With_Decay"
 0163h  "Set_Inversion_Pri"
 0164h  "Reset_Inversion_Pri"
 0165h  "Release_Inversion_Pri"
 0166h  "Get_Thread_Win32_Pri"
 0167h  "Set_Thread_Win32_Pri"
 0168h  "Set_Thread_Static_Boost"
 0169h  "Set_VM_Static_Boost"
 016Ah  "Release_Inversion_Pri_ID"
 016Bh  "Attach_Thread_To_Group"
 016Ch  "Detach_Thread_From_Group"
 016Dh  "Set_Group_Static_Boost"
 016Eh  "_GetRegistryPath"
 016Fh  "_GetRegistryKey"
 0170h  "_CleanupNestedExec"
 0171h  "_RegRemapPreDefKey"
 0172h  "End_V86_Serialization"
 0173h  "_Assert_Range"
 0174h  "_Sprintf"
 0175h  "_PageChangePager"
 0176h  "_RegCreateDynKey"
 0177h  "RegQMulti"
 0178h  "Boost_Thread_With_VM"
 0179h  "Get_Boot_Flags"
 017Ah  "Set_Boot_Flags"
 017Bh  "_lstrcpyn"
 017Ch  "_lstrlen"
 017Dh  "_lmemcpy"
 017Eh  "_GetVxDName"
 017Fh  "Force_Mutexes_Free"
 0180h  "Restore_Forced_Mutexes"
 0181h  "_AddReclaimableItem"
 0182h  "_SetReclaimableItem"
 0183h  "_EnumReclaimableItem"
 0184h  "Time_Slice_Wake_Sys_VM"
 0185h  "VMM_Replace_Global_Environment"
 0186h  "Begin_Non_Serial_Nest_V86_Exec"
 0187h  "Get_Nest_Exec_Status"
 0188h  "Open_Boot_Log"
 0189h  "Write_Boot_Log"
 018Ah  "Close_Boot_Log"
 018Bh  "EnableDisable_Boot_Log"
 018Ch  "_Call_On_My_Stack"
 018Dh  "Get_Inst_V86_Int_Vec_Base"
 018Eh  "_lstrcmpi"
 018Fh  "_strupr"
 0190h  "Log_Fault_Call_Out"
 0191h  "_AtEventTime"
 0191h  ...last service for Windows95 SP1
 811Ch  unhook device service??? (called by KEYREMAP.VXD)
        EAX = service ID (high word = VxD ID, low = service number)
        ESI -> handler
SeeAlso: #01266,#01267,INT 2F/AX=1684h/BX=0001h
--------W-20----Vx0002-----------------------
INT 20 P - Microsoft Windows - DEBUG - VxD SERVICES
        VxD = 0002h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01266,#01340

(Table 01266)
Values for DEBUG (VxD ID 0002h) service number:
 0000h  get version
 0001h  "DEBUG_Fault"
 0002h  "DEBUG_CheckFault"
 0003h  "_DEBUG_LoadSyms"
SeeAlso: #01265,#01267
--------W-20----Vx0003-----------------------
INT 20 P - Microsoft Windows - VPICD - VxD SERVICES
        VxD = 0003h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01267,#01340

(Table 01267)
Values for VPICD (VxD ID 0003h) service number:
 0000h  get version
 0001h  virtualize IRQ
 0002h  set interrupt request
 0003h  clear interrupt request
 0004h  physical EOI
 0005h  get complete status
 0006h  get status
 0007h  test physical request
 0008h  physically mask
 0009h  physically unmask
 000Ah  set automatic masking
 000Bh  get IRQ complete status
 000Ch  convert handle to IRQ
 000Dh  convert IRQ to interrupt
 000Eh  convert interrupt to IRQ
 000Fh  call on hardware interrupt
 0010h  force default owner
 0011h  force default behavior
 0012h  "VPICD_Auto_Mask_At_Inst_Swap"
 0013h  "VPICD_Begin_Inst_Page_Swap"
 0014h  "VPICD_End_Inst_Page_Swap"
 0015h  "VPICD_Virtual_EOI"
 0016h  "VPICD_Get_Virtualization_Count"
 0017h  "VPICD_Post_Sys_Critical_Init"
 0018h  "VPICD_VM_SlavePIC_Mask_Change"
SeeAlso: #01265,#01268,INT 2F/AX=1684h/BX=0003h
--------W-20----Vx0004-----------------------
INT 20 P - Microsoft Windows - VDMAD - VxD SERVICES
        VxD = 0004h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01268)
Values for VDMAD (VxD ID 0004h) service number:
 0000h  get version
 0001h  virtualize channel
 0002h  get region information
 0003h  set region information
 0004h  get virtual state
 0005h  set virtual state
 0006h  set physical state
 0007h  mask channel
 0008h  unmask channel
 0009h  lock DMA region
 000Ah  unlock DMA region
 000Bh  scatter lock
 000Ch  scatter unlock
 000Dh  reserve buffer space
 000Eh  request buffer
 000Fh  release buffer
 0010h  copy to buffer
 0011h  copy from buffer
 0012h  default handler
 0013h  disable translation
 0014h  enable translation
 0015h  get EISA address mode
 0016h  set EISA address mode
 0017h  unlock DMA region (ND)
 0018h  "VDMAD_Phys_Mask_Channel"
 0019h  "VDMAD_Phys_Unmask_Channel"
 001Ah  "VDMAD_Unvirtualize_Channel"
 001Bh  "VDMAD_Set_IO_Address"
 001Ch  "VDMAD_Get_Phys_Count"
 001Dh  "VDMAD_Get_Phys_Status"
 001Eh  "VDMAD_Get_Max_Phys_Page"
 001Fh  "VDMAD_Set_Channel_Callbacks"
 0020h  "VDMAD_Get_Virt_Count"
 0021h  "VDMAD_Set_Virt_Count"
 0021h  ...last service for Windows95 SP1
SeeAlso: #01267,#02646,#02683 at INT 2F/AX=1684h/BX=0444h
--------W-20----Vx0005-----------------------
INT 20 P - Microsoft Windows - VTD - VxD SERVICES
        VxD = 0005h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01269)
Values for VTD (VxD ID 0005h) service number:
 0000h  get version
 0001h  update system clock
 0002h  get interrupt period
 0003h  begin minimum interrupt period
 0004h  end minimum interrupt period
 0005h  disable trapping
 0006h  enable trapping
 0007h  get real time
        Return: EDX:EAX = time in 840ns units since Windows was started
 0008h  "VTD_Get_Date_And_Time"
 0009h  "VTD_Adjust_VM_Count"
 000Ah  "VTD_Delay"
SeeAlso: #02646 at INT 2F/AX=1684h/BX=0005h
--------W-20----Vx0006-----------------------
INT 20 P - Microsoft Windows - V86MMGR - VxD SERVICES
        VxD = 0006h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01270)
Values for V86MMGR (VxD ID 0006h) service number:
 00h    get version
 01h    allocate V86 pages
 02h    set EMS and XMS limits
 03h    get EMS and XMS limits
 04h    set mapping information
 05h    get mapping information
 06h    Xlat API
 07h    load client pointer
 08h    allocate buffer
 09h    free buffer
 0Ah    get Xlat buffer state
 0Bh    set Xlat buffer state
 0Ch    get VM flat selector
 0Dh    map pages
 0Eh    free page map region
 0Fh    _LocalGlobalReg
 10h    get page status
 11h    set local A20
 12h    reset base pages
 13h    set available mapped pages
 14h    "V86MMGR_NoUMBInitCalls"
 15h    "V86MMGR_Get_EMS_XMS_Avail"
 16h    "V86MMGR_Toggle_HMA"
        EAX = ???
 17h    "V86MMGR_Dev_Init"
 18h    "V86MMGR_Alloc_UM_Page"
SeeAlso: #02646,#01271,INT 2F/AX=1684h"DEVICE API"
--------W-20----Vx0007-----------------------
INT 20 P - Microsoft Windows - PageSwap - VxD SERVICES
        VxD = 0007h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01271)
Values for PageSwap (VxD ID 0007h) service number:
 00h    get version
 01h    test create
 02h    create swap file
 03h    destroy swap file
 04h    in
 05h    out
 06h    test if I/O valid
 07h    "Read_Or_Write"
 08h    "Grow_File"
 09h    "Init_File"
SeeAlso: #01270,#01272,#01273,#02648
--------W-20----Vx0009-----------------------
INT 20 P - Microsoft Windows - REBOOT - VxD SERVICES
        VxD = 0009h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01272)
Values for REBOOT (VxD ID 0009h) service number:
 00h    get REBOOT version???
 01h    ???
 02h    ???
 03h    ...last service for Windows95 SP1
SeeAlso: #01271,#01273,#02642
--------W-20----Vx000A-----------------------
INT 20 P - Microsoft Windows - VDD - VxD SERVICES
        VxD = 000Ah
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01273)
Values for VDD (VxD ID 000Ah) service number:
 00h    get version
 01h    PIF state
 02h    get GrabRtn
 03h    hide cursor
 04h    set VM type
 05h    get ModTime
 06h    set HCurTrk
 07h    message clear screen
 08h    message foreground color
 09h    message background color
 0Ah    message output text
 0Bh    message set cursor position
 0Ch    query access
 0Dh    "VDD_Check_Update_Soon"
 0Eh    "VDD_Get_Mini_Dispatch_Table"
 0Fh    "VDD_Register_Virtual_Port"
        DX = base I/O port number
        CL = number of contiguous ports???
 10h    "VDD_Get_VM_Info"
 11h    "VDD_Get_Special_VM_IDs"
        Return: ESI = ???
                EDI = ???
 12h    "VDD_Register_Extra_Screen_Selector"
 13h    "VDD_Takeover_VGA_Port"
        DX = VGA I/O port number (03C2h, etc.)
        ECX -> routine to call on I/O access
        Return: ECX -> previous handler (to be jumped to at end of new handler)
 14h    ???
 15h    ???
 16h    ...last service for Windows95 SP1
SeeAlso: #01272,#01274,#02648
--------W-20----Vx000B-----------------------
INT 20 P - Microsoft Windows - VSD - VxD SERVICES
        VxD = 000Bh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01274)
Values for VSD (VxD ID 000Bh) service number:
 00h    get version
 01h    bell
 02h    sound on
 03h    "VSD_TakeSoundPort"
SeeAlso: #01273,#01275
--------W-20----Vx000C-----------------------
INT 20 P - Microsoft Windows - VMD / VMOUSE - VxD SERVICES
        VxD = 000Ch
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01275)
Values for VMD / VMOUSE (VxD ID 000Ch) service number:
 0000h  get version
 0001h  set mouse type
 0002h  get mouse owner
 0003h  "VMOUSE_Post_Pointer_Message"
 0004h  "VMOUSE_Set_Cursor_Proc"
 0005h  "VMOUSE_Call_Cursor_Proc"
 0006h  "VMOUSE_Set_Mouse_Data~Get_Mouse_Data"
 0007h  "VMOUSE_Manipulate_Pointer_Message"
 0008h  "VMOUSE_Set_Middle_Button"
 0009h  "VMD_Set_Middle_Button"
 000Ah  "VMD_Enable_Disable_Mouse_Events"
 000Bh  "VMD_Post_Absolute_Pointer_Message"
        ...last service for Windows95 SP1
SeeAlso: #01274,#01276,INT 2F/AX=1684h/BX=000Ch
--------W-20----Vx000D-----------------------
INT 20 P - Microsoft Windows - VKD - VxD SERVICES
        VxD = 000Dh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01276)
Values for VKD (VxD ID 000Dh) service number:
 0000h  get version
 0001h  define hotkey
 0002h  remove hotkey
 0003h  locally enable hotkey
 0004h  locally disable hotkey
 0005h  reflect hotkey
 0006h  cancel hotkey state
 0007h  force keys
 0008h  get keyboard owner
 0009h  define paste mode
 000Ah  start pasting
 000Bh  cancel paste
 000Ch  get message key
 000Dh  peek message key
 000Eh  flush message key queue
 000Fh  "VKD_Enable_Keyboard"
 0010h  "VKD_Disable_Keyboard"
 0011h  "VKD_Get_Shift_State"
 0012h  "VKD_Filter_Keyboard_Input"
 0013h  "VKD_Put_Byte"
 0014h  "VKD_Set_Shift_State"
        ...last service for Windows95 SP1
SeeAlso: #01275,#01277
--------W-20----Vx000E-----------------------
INT 20 P - Microsoft Windows - VCD - VxD SERVICES
        VxD = 000Eh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01277)
Values for VCD (VxD ID 000Eh) service number:
 0000h  get version
 0001h  set port global
 0002h  get focus
 0003h  virtualize port
 0004h  "VCD_Acquire_Port"
 0005h  "VCD_Free_Port"
 0006h  "VCD_Acquire_Port_Windows_Style"
 0007h  "VCD_Free_Port_Windows_Style"
 0008h  "VCD_Steal_Port_Windows_Style"
 0009h  "VCD_Find_COM_Index"
 000Ah  "VCD_Set_Port_Global_Special"
 000Bh  "VCD_Virtualize_Port_Dynamic"
 000Ch  "VCD_Unvirtualize_Port_Dynamic"
        ...last service for Windows95 SP1
SeeAlso: #01276,#01278
--------W-20----Vx0010-----------------------
INT 20 P - Microsoft Windows - BlockDev / IOS - VxD SERVICES
        VxD = 0010h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01278)
Values for BlockDev/IOS (VxD ID 0010h) service number:
 0000h  get version
 0001h  register device
 0002h  find INT 13 drive
 0003h  get device list
 0004h  send command
 0005h  command complete
 0006h  synchronous command
 0007h  "IOS_Register"
 0008h  "IOS_Requestor_Service"
 0009h  "IOS_Exclusive_Access"
 000Ah  "IOS_Send_Next_Command"
 000Bh  "IOS_Set_Async_Time_Out"
 000Ch  "IOS_Signal_Semaphore_No_Switch"
 000Dh  "IOSIdleStatus"
 000Eh  "IOSMapIORSToI24"
 000Fh  "IOSMapIORSToI21"
 0010h  "PrintLog"
SeeAlso: #01277,#01279
--------W-20----Vx0011-----------------------
INT 20 P - Microsoft Windows - VMCPD - VxD SERVICES
        VxD = 0011h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01279)
Values for VMCPD (VxD ID 0011h) service number:
 0000h  "VMCPD_Get_Version"
 0001h  "VMCPD_Get_Virt_State"
 0002h  "VMCPD_Set_Virt_State"
 0003h  "VMCPD_Get_CR0_State"
 0004h  "VMCPD_Set_CR0_State"
 0005h  "VMCPD_Get_Thread_State"
 0006h  "VMCPD_Set_Thread_State"
 0007h  "_VMCPD_Get_FP_Instruction_Size"
 0008h  "VMCPD_Set_Thread_Precision"
SeeAlso: #01278,#01280,#02642
--------W-20----Vx0012-----------------------
INT 20 P - Microsoft Windows - EBIOS - VxD SERVICES
        VxD = 0012h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01280)
Values for EBIOS (VxD ID 0012h) service number:
 00h    get EBIOS version
 01h    get unused memory
SeeAlso: #01279,#01281
--------W-20----Vx0014-----------------------
INT 20 P - Microsoft Windows - VNETBIOS - VxD SERVICES
        VxD = 0014h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01281)
Values for VNETBIOS (VxD ID 0014h) service number:
 00h    get version
 01h    register
 02h    submit
 03h    enum
 04h    deregister
 05h    register2
 06h    map
 07h    enum2
SeeAlso: #01280,#01282
--------W-20----Vx0015-----------------------
INT 20 P - Microsoft Windows - DOSMGR - VxD SERVICES
        VxD = 0015h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01282)
Values for DOSMGR (VxD ID 0015h) service number:
 0000h  get version
 0001h  set exec VM data
 0002h  coyp VM drive state
 0003h  execute VM
 0004h  get InDOS pointer
 0005h  add device
 0006h  remove device
 0007h  instance device
 0008h  get DOS critical status
 0009h  enable InDOS polling
 000Ah  backfill allowed
 000Bh  "LocalGlobalReg"
 000Ch  "Init_UMB_Area"
 000Dh  "Begin_V86_App"
 000Eh  "End_V86_App"
 000Fh  "Alloc_Local_Sys_VM_Mem"
        EAX = number of paragraphs??? to allocate
 0010h  "DOSMGR_Grow_CDSs"
 0011h  "DOSMGR_Translate_Server_DOS_Call"
 0012h  "DOSMGR_MMGR_PSP_Change_Notifier"
SeeAlso: #01281,#02656 at INT 2F/AX=1684h/BX=0015h
--------W-20----Vx0017-----------------------
INT 20 P - Microsoft Windows - SHELL - VxD SERVICES
        VxD = 0017h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01283)
Values for SHELL (VxD ID 0017h) service number:
 0000h  get version
 0001h  resolve contention
 0002h  event
 0003h  SYSMODAL message
 0004h  message
 0005h  get VM information
 0006h  "_SHELL_PostMessage"
 0007h  "_SHELL_WinExec"
 0008h  "_SHELL_CallDll"
 0009h  "SHELL_OpenClipboard"
 000Ah  "SHELL_SetClipboardData"
 000Bh  "SHELL_GetClipboardData"
 000Ch  "SHELL_CloseClipboard"
 000Dh  "_SHELL_Install_Taskman_Hooks"
 000Eh  "SHELL_Hook_Properties"
 000Fh  "SHELL_Unhook_Properties"
 0010h  "SHELL_OEMKeyScan"
 0011h  "SHELL_Update_User_Activity"
 0012h  "_SHELL_UnhookSystemBroadcast"
 0013h  "_SHELL_LocalAllocEx"
 0014h  "_SHELL_LocalFree"
 0015h  "_SHELL_LoadLibrary"
 0016h  "_SHELL_FreeLibrary"
 0017h  "_SHELL_GetProcAddress"
 0018h  "_SHELL_CallDll"
 0019h  "_SHELL_SuggestSingleMSDOSMode"
 001Ah  "SHELL_CheckHotkeyAllowed"
 001Bh  "_SHELL_GetDOSAppInfo"
SeeAlso: #01282,#01284,#02657 at INT 2F/AX=1684h/BX=0017h
--------W-20----Vx0018-----------------------
INT 20 P - Microsoft Windows - VMPoll - VxD SERVICES
        VxD = 0018h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01284)
Values for VMPoll (VxD ID 0018h) service number:
 00h    get version
 01h    enable/disable
 02h    reset detection
 03h    check idle
SeeAlso: #01269,#02657 at INT 2F/AX=1684h/BX=0017h
--------W-20----Vx001A-----------------------
INT 20 P - Microsoft Windows - DOSNET - VxD SERVICES
        VxD = 001Ah
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01285)
Values for DOSNET (VxD ID 001Ah) service number:
 00h    get version
 01h    send FILESYSCHANGE
 02h    do PSP adjust
SeeAlso: #01284,#01286
--------W-20----Vx001B-----------------------
INT 20 P - Microsoft Windows - VFD - VxD SERVICES
        VxD = 001Bh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01286,#01340

(Table 01286)
Values for VFD (VxD ID 001Bh) service number:
 0000h  get version
SeeAlso: #01285,#01287
--------W-20----Vx001C-----------------------
INT 20 P - Microsoft Windows - LoadHi - VxD SERVICES
        VxD = 001Ch
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01287)
Values for LoadHi (VxD ID 001Ch) service number:
 00h    get version
        Return: CF clear
                EAX = version (AH = major, AL = minor)
                ESI -> ASCIZ signature "LoadHi"
SeeAlso: #01286,#01288
--------W-20----Vx0020-----------------------
INT 20 P - Microsoft Windows - Int13 - VxD SERVICES
        VxD = 0020h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01288)
Values for Int13 (VxD ID 0020h) service number:
 00h    get version
 01h    device registered
 02h    translate VM interrupt
 03h    hooking BIOS interrupt
 04h    unhooking BIOS interrupt
SeeAlso: #01287,#01289
--------W-20----Vx0021-----------------------
INT 20 P - Microsoft Windows - PAGEFILE - VxD SERVICES
        VxD = 0021h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01289)
Values for PAGEFILE (VxD ID 0021h) service number:
 00h    get version
 01h    init file
 02h    clean up
 03h    grow file
 04h    read or write
 05h    cancel
 06h    test I/O valid
 07h    "Get_Size_Info"
 08h    "Set_Async_Manager"
 09h    "Call_Async_Manager"
SeeAlso: #01288,#02661 at INT 2F/AX=1684h/BX=0021h
--------W-20----Vx0026-----------------------
INT 20 P - Microsoft Windows - VPOWERD - VxD SERVICES
        VxD = 0026h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01290)
Values for VPOWERD (VxD ID 0026h) service number:
 00h    get version
        Return: CF clear
                EAX = version (AH = major, AL = minor)
 01h    get APM BIOS version
        Return: CF clear
                EAX = APM BIOS version
 02h    get current power management level
        Return: CF clear
                EAX = power management level
 03h    enable/disable power management (see INT 15/AX=5308h)
        Return: EAX = error code (see #02665) or 00000000h if successful
 04h    set power state (see INT 15/AX=5307h)
        ???
        Return: EAX = error code (see #02665) or 00000000h if successful
 05h    set system power status
        Return: EAX = error code (see #02665) or 00000000h if successful
 06h    restore APM power-on defaults (see INT 15/AX=5309h)
        Return: EAX = error code (see #02665) or 00000000h if successful
 07h    get power status (see INT 15/AX=530Ah)
        Return: ???
 08h    get APM 1.1 power state (see INT 15/AX=530Ch)
        Return: ???
 09h    invoke OEM APM function
        ??? -> bufer containing parameters for INT 15/AX=5380h
        Return: EAX = error code (see #02665) or 00000000h if successful
                buffer updated if successful
 0Ah    register power handler
        ???
        Return: EAX = error code (see #02665) or 00000000h if successful
 0Bh    deregister power handler
        ???
        Return: EAX = error code (see #02665) or 00000000h if successful
 0Ch    Win32 get system power status
 0Dh    Win32 set system power status
SeeAlso: #01289,#01291,INT 2F/AX=1684h/BX=0026h
--------W-20----Vx0027-----------------------
INT 20 P - Microsoft Windows - VXDLDR - VxD SERVICES
        VxD = 0027h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01291)
Values for VXDLDR (VxD ID 0027h) service number:
 0000h  "VXDLDR_Get_Version"
 0001h  "VXDLDR_LoadDevice"
 0002h  "VXDLDR_UnloadDevice"
 0003h  "VXDLDR_DevInitSucceeded"
 0004h  "VXDLDR_DevInitFailed"
 0005h  "VXDLDR_GetDeviceList"
 0006h  "VXDLDR_UnloadMe"
 0007h  "PELDR_LoadModule"
 0008h  "PELDR_GetModuleHandle"
 0009h  "PELDR_GetModuleUsage"
 000Ah  "PELDR_GetEntryPoint"
 000Bh  "PELDR_GetProcAddress"
 000Ch  "PELDR_AddExportTable"
 000Dh  "PELDR_RemoveExportTable"
 000Eh  "PELDR_FreeModule"
 000Fh  "VXDLDR_Notify"
 0010h  "_PELDR_InitCompleted"
 0011h  "_PELDR_LoadModuleEx"
SeeAlso: #01289,#01292
--------W-20----Vx0028-----------------------
INT 20 P - Microsoft Windows - NDIS - VxD SERVICES
        VxD = 0028h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01292)
Values for NDIS (VxD ID 0028h) service number:
 00h    "NdisGetVersion"
 01h    "NdisAllocateSpinLock"
 02h    "NdisFreeSpinLock"
 03h    "NdisAcquireSpinLock"
 04h    "NdisReleaseSpinLock"
 05h    "NdisOpenConfiguration"
 06h    "NdisReadConfiguration"
 07h    "NdisCloseConfiguration"
 08h    "NdisReadEisaSlotInformation"
 09h    "NdisReadMcaPosInformation"
 0Ah    "NdisAllocateMemory"
 0Bh    "NdisFreeMemory"
 0Ch    "NdisSetTimer"
 0Dh    "NdisCancelTimer"
 0Eh    "NdisStallExecution"
 0Fh    "NdisInitializeInterrupt"
 10h    "NdisRemoveInterrupt"
 11h    "NdisSynchronizeWithInterrupt"
 12h    "NdisOpenFile"
 13h    "NdisMapFile"
 14h    "NdisUnmapFile"
 15h    "NdisCloseFile"
 16h    "NdisAllocatePacketPool"
 17h    "NdisFreePacketPool"
 18h    "NdisAllocatePacket"
 19h    "NdisReinitializePacket"
 1Ah    "NdisFreePacket"
 1Bh    "NdisQueryPacket"
 1Ch    "NdisAllocateBufferPool"
 1Dh    "NdisFreeBufferPool"
 1Eh    "NdisAllocateBuffer"
 1Fh    "NdisCopyBuffer"
 20h    "NdisFreeBuffer"
 21h    "NdisQueryBuffer"
 22h    "NdisGetBufferPhysicalAddress"
 23h    "NdisChainBufferAtFront"
 24h    "NdisChainBufferAtBack"
 25h    "NdisUnchainBufferAtFront"
 26h    "NdisUnchainBufferAtBack"
 27h    "NdisGetNextBuffer"
 28h    "NdisCopyFromPacketToPacket"
 29h    "NdisRegisterProtocol"
 2Ah    "NdisDeregisterProtocol"
 2Bh    "NdisOpenAdapter"
 2Ch    "NdisCloseAdapter"
 2Dh    "NdisSend"
 2Eh    "NdisTransferData"
 2Fh    "NdisReset"
 30h    "NdisRequest"
 31h    "NdisInitializeWrapper"
 32h    "NdisTerminateWrapper"
 33h    "NdisRegisterMac"
 34h    "NdisDeregisterMac"
 35h    "NdisRegisterAdapter"
 36h    "NdisDeregisterAdapter"
 37h    "NdisCompleteOpenAdapter"
 38h    "NdisCompleteCloseAdapter"
 39h    "NdisCompleteSend"
 3Ah    "NdisCompleteTransferData"
 3Bh    "NdisCompleteReset"
 3Ch    "NdisCompleteRequest"
 3Dh    "NdisIndicateReceive"
 3Eh    "NdisIndicateReceiveComplete"
 3Fh    "NdisIndicateStatus"
 40h    "NdisIndicateStatusComplete"
 41h    "NdisCompleteQueryStatistics"
 42h    "NdisEqualString"
 43h    "NdisNetAddressStringToBinary"
 44h    "NdisReadNetworkAddress"
 45h    "NdisWriteErrorLogEntry"
 46h    "C_MapPhysToLinear"
 47h    "C_HeapFree"
 48h    "NdisAllocateSharedMemory"
 49h    "NdisFreeSharedMemory"
 ...
 5Fh    ...last service for Windows95 SP1
SeeAlso: #01291,#01293
--------W-20----Vx002A-----------------------
INT 20 P - Microsoft Windows - VWIN32 - VxD SERVICES
        VxD = 002Ah
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01293)
Values for VWIN32 (VxD ID 002Ah) service number:
 0000h  "VWin32_Get_Version"
 0001h  "VWin32_Wake_For_Event"
 0002h  "_VWIN32_QueueUserApc"
 0003h  "_VWIN32_Get_Thread_Context"
 0004h  "_VWIN32_Set_Thread_Context"
 0005h  "_VWIN32_CopyMem"
 0006h  "_VWIN32_BlockForTermination"
 0007h  "_VWIN32_Emulate_Npx"
 0008h  "_VWIN32_CheckDelayedNpxTrap"
 0009h  "VWIN32_EnterCrstR0"
 000Ah  "VWIN32_LeaveCrstR0"
 000Bh  "_VWIN32_FaultPopup"
 000Ch  "VWIN32_GetContextHandle"
 000Dh  "VWIN32_GetCurrentProcessHandle"
 000Eh  "_VWIN32_SetWin32Event"
 000Fh  "_VWIN32_PulseWin32Event"
 0010h  "_VWIN32_ResetWin32Event"
 0011h  "_VWIN32_WaitSingleObject"
 0012h  "_VWIN32_WaitMultipleObjects"
 0013h  "_VWIN32_CreateRing0Thread"
 0014h  "_VWIN32_CloseVxDHandle"
 0015h  "VWIN32_ActiveTimeBiasSet"
 0016h  "VWIN32_GetCurrentDirectory"
 0017h  "VWIN32_BlueScreenPopup"
 0018h  "VWIN32_TerminateApp"
 0019h  "_VWIN32_QueueKernelAPC"
 001Ah  "VWIN32_SysErrorBox"
 001Bh  "_VWIN32_IsClientWin32"
 001Ch  "VWIN32_IFSRIPWhenLev2Taken"
SeeAlso: #01292,#01294
--------W-20----Vx002B-----------------------
INT 20 P - Microsoft Windows - VCOMM - VxD SERVICES
        VxD = 002Bh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01294)
Values for VCOMM (VxD ID 002Bh) service number:
 0000h  "VCOMM_Get_Version"
 0001h  "_VCOMM_Register_Port_Driver"
 0002h  "_VCOMM_Acquire_Port"
 0003h  "_VCOMM_Release_Port"
 0004h  "_VCOMM_OpenComm"
 0005h  "_VCOMM_SetCommState"
 0006h  "_VCOMM_GetCommState"
 0007h  "_VCOMM_SetupComm"
 0008h  "_VCOMM_TransmitCommChar"
 0009h  "_VCOMM_CloseComm"
 000Ah  "_VCOMM_GetCommQueueStatus"
 000Bh  "_VCOMM_ClearCommError"
 000Ch  "_VCOMM_GetModemStatus"
 000Dh  "_VCOMM_GetCommProperties"
 000Eh  "_VCOMM_EscapeCommFunction"
 000Fh  "_VCOMM_PurgeComm"
 0010h  "_VCOMM_SetCommEventMask"
 0011h  "_VCOMM_GetCommEventMask"
 0012h  "_VCOMM_WriteComm"
 0013h  "_VCOMM_ReadComm"
 0014h  "_VCOMM_EnableCommNotification"
 0015h  "_VCOMM_GetLastError"
 0016h  "_VCOMM_Steal_Port"
 0017h  "_VCOMM_SetReadCallBack"
 0018h  "_VCOMM_SetWriteCallBack"
 0019h  "_VCOMM_GetSetCommTimeouts"
 001Ah  "_VCOMM_SetWriteRequest"
 001Bh  "_VCOMM_SetReadRequest"
 001Ch  "_VCOMM_Dequeue_Request"
 001Dh  "_VCOMM_Dequeue_Request"
 001Eh  "_VCOMM_Enumerate_DevNodes"
 001Fh  "VCOMM_Map_Win32DCB_To_Ring0"
 0020h  "VCOMM_Map_Ring0DCB_To_Win32"
 0021h  "_VCOMM_Get_Contention_Handler"
 0022h  "_VCOMM_Map_Name_To_Resource"
SeeAlso: #01293,#01295
--------W-20----Vx002C-----------------------
INT 20 P - Microsoft Windows - SPOOLER - VxD SERVICES
        VxD = 002Ch
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01295)
Values for SPOOLER (VxD ID 002Ch) service number:
 0000h  get version???
 0001h  ???
 0010h  ...last service for Windows95 SP1
SeeAlso: #01294,#01296
--------W-20----Vx0032-----------------------
INT 20 P - Microsoft Windows - VSERVER - VxD SERVICES
        VxD = 0032h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01296)
Values for VSERVER (VxD ID 0032h) service number:
 00h    get VSERVER version
        Return: CF clear
                EAX = version (AH = major, AL = minor)
                EBX = ??? (00000000h)
 01h    allocate ???
        AX = ???
        ESI = ???
        Return: CF clear if successful
                CF set on error (table full)
 02h    NOP???
        Return: EBX = 00000000h
 03h    ???
        Return: ZF clear
SeeAlso: #01295,#01297,INT 2F/AX=1684h/BX=0032h
--------W-20----Vx0033-----------------------
INT 20 P - Microsoft Windows - CONFIGMG - VxD SERVICES
        VxD = 0033h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01297)
Values for CONFIGMG (VxD ID 0033h) service number:
 0000h  "_CONFIGMG_Get_Version"
 0001h  "_CONFIGMG_Initialize"
 0002h  "_CONFIGMG_Locate_DevNode"
 0003h  "_CONFIGMG_Get_Parent"
 0004h  "_CONFIGMG_Get_Child"
 0005h  "_CONFIGMG_Get_Sibling"
 0006h  "_CONFIGMG_Get_Device_ID_Size"
 0007h  "_CONFIGMG_Get_Device_ID"
 0008h  "_CONFIGMG_Get_Depth"
 0009h  "_CONFIGMG_Get_Private_DWord"
 000Ah  "_CONFIGMG_Set_Private_DWord"
 000Bh  "_CONFIGMG_Create_DevNode"
 000Ch  "_CONFIGMG_Query_Remove_SubTree"
 000Dh  "_CONFIGMG_Remove_SubTree"
 000Eh  "_CONFIGMG_Register_Device_Driver"
 000Fh  "_CONFIGMG_Register_Enumerator"
 0010h  "_CONFIGMG_Register_Arbitrator"
 0011h  "_CONFIGMG_Deregister_Arbitrator"
 0012h  "_CONFIGMG_Query_Arbitrator_Free_Size"
 0013h  "_CONFIGMG_Query_Arbitrator_Free_Data"
 0014h  "_CONFIGMG_Sort_NodeList"
 0015h  "_CONFIGMG_Yield"
 0016h  "_CONFIGMG_Lock"
 0017h  "_CONFIGMG_Unlock"
 0018h  "_CONFIGMG_Add_Empty_Log_Conf"
 0019h  "_CONFIGMG_Free_Log_Conf"
 001Ah  "_CONFIGMG_Get_First_Log_Conf"
 001Bh  "_CONFIGMG_Get_Next_Log_Conf"
 001Ch  "_CONFIGMG_Add_Res_Des"
 001Dh  "_CONFIGMG_Modify_Res_Des"
 001Eh  "_CONFIGMG_Free_Res_Des"
 001Fh  "_CONFIGMG_Get_Next_Res_Des"
 0020h  "_CONFIGMG_Get_Performance_Info"
 0021h  "_CONFIGMG_Get_Res_Des_Data_Size"
 0022h  "_CONFIGMG_Get_Res_Des_Data"
 0023h  "_CONFIGMG_Process_Events_Now"
 0024h  "_CONFIGMG_Create_Range_List"
 0025h  "_CONFIGMG_Add_Range"
 0026h  "_CONFIGMG_Delete_Range"
 0027h  "_CONFIGMG_Test_Range_Available"
 0028h  "_CONFIGMG_Dup_Range_List"
 0029h  "_CONFIGMG_Free_Range_List"
 002Ah  "_CONFIGMG_Invert_Range_List"
 002Bh  "_CONFIGMG_Intersect_Range_List"
 002Ch  "_CONFIGMG_First_Range"
 002Dh  "_CONFIGMG_Next_Range"
 002Eh  "_CONFIGMG_Dump_Range_List"
 002Fh  "_CONFIGMG_Load_DLVxDs"
 0030h  "_CONFIGMG_Get_DDBs"
 0031h  "_CONFIGMG_Get_CRC_CheckSum"
 0032h  "_CONFIGMG_Register_DevLoader"
 0033h  "_CONFIGMG_Reenumerate_DevNode"
 0034h  "_CONFIGMG_Setup_DevNode"
 0035h  "_CONFIGMG_Reset_Children_Marks"
 0036h  "_CONFIGMG_Get_DevNode_Status"
 0037h  "_CONFIGMG_Remove_Unmarked_Children"
 0038h  "_CONFIGMG_ISAPNP_To_CM"
 0039h  "_CONFIGMG_CallBack_Device_Driver"
 003Ah  "_CONFIGMG_CallBack_Enumerator"
 003Bh  "_CONFIGMG_Get_Alloc_Log_Conf"
 003Ch  "_CONFIGMG_Get_DevNode_Key_Size"
 003Dh  "_CONFIGMG_Get_DevNode_Key"
 003Eh  "_CONFIGMG_Read_Registry_Value"
 003Fh  "_CONFIGMG_Write_Registry_Value"
 0040h  "_CONFIGMG_Disable_DevNode"
 0041h  "_CONFIGMG_Enable_DevNode"
 0042h  "_CONFIGMG_Move_DevNode"
 0043h  "_CONFIGMG_Set_Bus_Info"
 0044h  "_CONFIGMG_Get_Bus_Info"
 0045h  "_CONFIGMG_Set_HW_Prof"
 0046h  "_CONFIGMG_Recompute_HW_Prof"
 0047h  "_CONFIGMG_Query_Change_HW_Prof"
 0048h  "_CONFIGMG_Get_Device_Driver_Private_DWord"
 0049h  "_CONFIGMG_Set_Device_Driver_Private_DWord"
 004Ah  "_CONFIGMG_Get_HW_Prof_Flags"
 004Bh  "_CONFIGMG_Set_HW_Prof_Flags"
 004Ch  "_CONFIGMG_Read_Registry_Log_Confs"
 004Dh  "_CONFIGMG_Run_Detection"
 004Eh  "_CONFIGMG_Call_At_Appy_Time"
 004Fh  "_CONFIGMG_Fail_Change_HW_Prof"
 0050h  "_CONFIGMG_Set_Private_Problem"
 0051h  "_CONFIGMG_Debug_DevNode"
 0052h  "_CONFIGMG_Get_Hardware_Profile_Info"
 0053h  "_CONFIGMG_Register_Enumerator_Function"
 0054h  "_CONFIGMG_Call_Enumerator_Function"
 0055h  "_CONFIGMG_Add_ID"
 0056h  "_CONFIGMG_Find_Range"
 0057h  "_CONFIGMG_Get_Global_State"
 0058h  "_CONFIGMG_Broadcast_Device_Change_Message"
 0059h  "_CONFIGMG_Call_DevNode_Handler"
 005Ah  "_CONFIGMG_Remove_Reinsert_All"
Note:   the VxD services appear to be identical to the PM/V86 APIs on
          INT 2F/AX=1684h
SeeAlso: #01296,#01299,INT 2F/AX=1684h/BX=0033h
--------W-20----Vx0034-----------------------
INT 20 P - Microsoft Windows - DWCFGMG.SYS - VxD SERVICES
        VxD = 0034h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01298)
Values for DWCFGMG.SYS (VxD ID 0034h) service number:
 00h    "CM_GetVersion" get supported DDI version
        Return: EAX = 00000000h if not installed
                else
                    AH = major version number
                    AL = minor version number
                    EBX = number of devices controlled by DWCFGMG.SYS
 01h    "CM_GetConfig" get device configuration
        EBX = device index
        EDI -> buffer for configuration information (see #02675)
        Return: EAX = status (0000h successful, 0001h index out of range)
 02h    "CM_LockConfig" lock device configuration
        EDI -> configuration information (see #02675)
        Return: EAX = status
                    0000h successful
                    0001h resource conflict
                    0002h invalid request
 03h    "CM_UnlockConfig" unlock device configuration
        EDI -> configuration information (see #02675)
        Return: EAX = status (0000h successful, 0001h invalid request)
 04h    "CME_QueryResources"
 05h    "CME_AllocResources"
 06h    "CME_DeallocResources"
SeeAlso: INT 2F/AX=1684h/BX=0034h
--------W-20----Vx0036-----------------------
INT 20 P - Microsoft Windows - VFBACKUP - VxD SERVICES
        VxD = 0036h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01299)
Values for VFBACKUP (VxD ID 0036h) service number:
 0000h  get version
        Return: CF clear
                EAX = version (AH = major, AL = minor)
 0001h  "VFBACKUP_Lock_NEC"
 0002h  "VFBACKUP_UnLock_NEC"
 0003h  "VFBACKUP_Register_NEC"
 0004h  "VFBACKUP_Register_VFD"
 0005h  "VFBACKUP_Lock_All_Ports"
SeeAlso: #01297,#01300
--------W-20----Vx0037-----------------------
INT 20 P - Microsoft Windows - VMINI / ENABLE - VxD SERVICES
        VxD = 0037h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01300)
Values for VMINI / ENABLE (VxD ID 0037h) service number:
 0000h  get version
        Return: CF clear
                EAX = version (AH = major, AL = minor)
 0001h  "VMINI_Update"
        ??? (performs VMMCall 1800Eh, then falls through to service 04h)
        Return: EAX = system time???
 0002h  "VMINI_Status"
        get current ???
        Return: EAX = ???
 0003h  "VMINI_DisplayError" (schedules a global event via VMMCall 1800Eh)
        Return: ???
 0004h  "VMINI_SetTimeStamp" (performs VMMCall 100CFh)
        Return: EAX = system time
 0005h  "VMINI_Siren" (call ??? priority event)
        Return: nothing
 0006h  "VMINI_RegisterAccess" (set ??? / get ???)
        EDI -> buffer containing data to copy into VxD and space for results
        Return: EDI buffer updated
 0007h  "VMINI_GetData"
        EBX = ??? flags (bits 2,15,17,18 checked)
        EDI -> ???
        ???
        Return: ???
 0008h  "VMINI_ShutDownItem" (schedules a global event via VMMCall 1800Eh)
        Return: ???
 0009h  "VMINI_RegisterSK" (get ??? data)
        EDI -> buffer for data (see #01301)
        Return: EDI buffer updated if large enough
SeeAlso: #01299,#01302,#02677 at INT 2F/AX=1684h/BX=0037h

Format of ENABLE.VXD ??? data:
Offset  Size    Description     (Table 01301)
 00h    DWORD   (ret) length of data, including this word
                (call) length of buffer
 04h    DWORD   -> 24-byte (or larger) buffer
 08h    DWORD   -> 20-byte buffer
 0Ch    DWORD   -> 260-byte buffer
 10h    DWORD   -> 260-byte buffer
SeeAlso: #01300
--------W-20----Vx0038-----------------------
INT 20 P - Microsoft Windows - VCOND - VxD SERVICES
        VxD = 0038h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01302)
Values for VCOND (VxD ID 0038h) service number:
 0000h  get VCOND version
        Return: CF clear
                EAX = version (AH = major, AL = minor)
 0001h  "VCOND_Launch_ConApp_Inherited"
SeeAlso: #01303,#01300,#01304

(Table 01303)
Values for Windows95 VCOND (Vxd ID 0038h) Win32 service number:
 00h    get VCOND version
        Return: EAX = version (AH = major, AL = minor)
 ...
 34h    ...last Win32 service for Windows95 SP1
SeeAlso: #01302
--------W-20----Vx003D-----------------------
INT 20 P - Microsoft Windows - BIOS - VxD SERVICES
        VxD = 003Dh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01304)
Values for BIOS (VxD ID 003Dh) service number:
 00h    get version???
 01h    ???
 02h    ???
 03h    ???
SeeAlso: #01302,#01305
--------W-20----Vx003E-----------------------
INT 20 P - Microsoft Windows - WSOCK - VxD SERVICES
        VxD = 003Eh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01305)
Values for WSOCK (VxD ID 003Eh) service number:
 00h    get WSOCK version
        Return: CF clear
                AH = major version
                AL = minor version
                EAX high word = 0000h
 01h    ???
        EAX = ??? or 00000000h
        Return: CF clear if successful
                    EAX = 00000000h
                CF set on error
                    EAX = ???
 02h    ???
        EAX = ??? or 00000000h
        Return: ???
 03h    ???
 04h    ...last service for Windows95 SP1
SeeAlso: #01304,#01306
--------W-20----Vx0040-----------------------
INT 20 P - Microsoft Windows - IFSMgr - VxD SERVICES
        VxD = 0040h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01306)
Values for IFSMGR (VxD ID 0040h) service number:
 00h    get version
 01h    "RegisterMount"
 02h    "RegisterNet"
 03h    "RegisterMailSlot"
 04h    "Attach"
 05h    "Detach"
 06h    "Get_NetTime"
 07h    "Get_DOSTime"
 08h    "SetupConnection"
 09h    "DerefConnection"
 0Ah    "ServerDOSCall"
 0Bh    "CompleteAsync"
 0Ch    "RegisterHeap"
 0Dh    "GetHeap"
 0Eh    "RetHeap"
 0Fh    "CheckHeap"
 10h    "CheckHeapItem"
 11h    "FillHeapSpare"
 12h    "Block"
 13h    "Wakeup"
 14h    "Yield"
 15h    "SchedEvent"
 16h    "QueueEvent"
 17h    "KillEvent"
 18h    "FreeIOReg"
 19h    "MakeMailSlot"
 1Ah    "DeleteMailSlot"
 1Bh    "WriteMailSlot"
 1Ch    "PopUp"
 1Dh    "printf"
 1Eh    "AssertFailed"
 1Fh    "LogEntry"
 20h    "DebugMenu"
 21h    "DebugVars"
 22h    "GetDebugString"
 23h    "GetDebugHexNum"
 24h    "NetFunction"
 25h    "DoDelAllUses"
 26h    "SetErrString"
 27h    "GetErrString"
 28h    "SetReqHook"
 29h    "SetPathHook"
 2Ah    "UseAdd"
 2Bh    "UseDel"
 2Ch    "InitUseAdd"
 2Dh    "ChangeDir"
 2Eh    "DelAllUses"
 2Fh    "CDROM_Attach"
 30h    "CDROM_Detach"
 31h    "Win32DupHandle"
 32h    "Ring0_FileIO"
 33h    "Toggle_Extended_File_Handle"
 34h    "IFSMgr_GetDrive_Info"
 35h    "IFSMgr_Ring0GetDriveInfo"
 36h    "IFSMgr_BlockNoEvents"
 37h    "IFSMgr_NetToDosTime"
 38h    "IFSMgr_DosToNetTime"
 39h    "IFSMgr_DosToWin32Time"
 3Ah    "IFSMgr_Win32ToDosTime"
 3Bh    "IFSMgr_NetToWin32Time"
 3Ch    "IFSMgr_Win32ToNetTime"
 3Dh    "IFSMgr_MetaMatch"
 3Eh    "IFSMgr_TransMatch"
 3Fh    "IFSMgr_CallProvider"
 40h    "UniToBCS"
 41h    "UniToBCSPath"
 42h    "BCSToUni"
 43h    "UniToUpper"
 44h    "UniCharToOEM"
 45h    "CreateBasis"
 46h    "MatchBasisName"
 47h    "AppendBasisTail"
 48h    "FcbToShort"
 49h    "ShortToFcb"
 4Ah    "IFSMgr_ParsePath"
 4Bh    "Query_PhysLock"
 4Ch    "_VolFlush"
 4Dh    "NotifyVolumeArrival"
 4Eh    "NotifyVolumeRemoval"
 4Fh    "QueryVolumeRemoval"
 50h    "IFSMgr_FSDUnmountCFSD"
 51h    "IFSMgr_GetConversionTablePtrs"
 52h    "IFSMgr_CheckAccessConflict"
 53h    "IFSMgr_LockFile"
 54h    "IFSMgr_UnlockFile"
 55h    "IFSMgr_RemoveLocks"
 56h    "IFSMgr_CheckLocks"
 57h    "IFSMgr_CountLocks"
 58h    "IFSMgr_ReassignLockFileInst"
 59h    "IFSMgr_UnassignLockList"
 5Ah    "IFSMgr_MountChildVolume"
 5Bh    "IFSMgr_UnmountChildVolume"
 5Ch    "IFSMgr_SwapDrives"
 5Dh    "IFSMgr_FSDMapFHtoIOREQ"
 5Eh    "IFSMgr_FSDParsePath"
 5Fh    "IFSMgr_FSDAttachSFT"
 60h    "IFSMgr_GetTimeZoneBias"
 61h    "IFSMgr_PNPEvent"
 62h    "IFSMgr_RegisterCFSD"
 63h    "IFSMgr_Win32MapExtendedHandleToSFT"
 64h    "IFSMgr_DbgSetFileHandleLimit"
 65h    "IFSMgr_Win32MapSFTToExtendedHandle"
 66h    "IFSMgr_FSDGetCurrentDrive"
 67h    "IFSMgr_InstallFileSystemApiHook"
 68h    "IFSMgr_RemoveFileSystemApiHook"
 69h    "IFSMgr_RunScheduledEvents"
 6Ah    "IFSMgr_CheckDelResource"
 6Bh    "IFSMgr_Win32GetVMCurdir"
 6Ch    "IFSMgr_SetupFailedConnection"
 6Dh    "_GetMappedErr"
 6Eh    "ShortToLossyFcb"
 6Fh    "IFSMgr_GetLockState"
 70h    "BcsToBcs"
 71h    "IFSMgr_SetLoopback"
 72h    "IFSMgr_ClearLoopback"
 73h    "IFSMgr_ParseOneElement"
 74h    "BcsToBcsUpper"
SeeAlso: #01305,#01307
--------W-20----Vx0041-----------------------
INT 20 P - Microsoft Windows - VCDFSD - VxD SERVICES
        VxD = 0041h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01307)
Values for VCDFSD (VxD ID 0041h) service number:
 00h    get VCDFSD version???
 01h    ???
 02h    ???
 03h    ???
SeeAlso: #01306,#01308
--------W-20----Vx0048-----------------------
INT 20 P - Microsoft Windows - PERF - VxD SERVICES
        VxD = 0048h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01308)
Values for PERF (VxD ID 0048h) service number:
 00h    get version
        Return: CF clear
                EAX = version (AH = major, AL = minor)
 01h    "PERF_Server_Register"
        (creates/sets a registry key for the server)
 02h    "PERF_Server_Deregister"
        end performance monitoring (deletes registry key for server)
 03h    "PERF_Server_Add_Stat"
        start performance monitoring (creates/sets a registry key)
 04h    "PERF_Server_Remove_Stat"
        end performance monitoring (deletes registry key)
SeeAlso: #01307,#01311,#01309
--------W-20----Vx004A-----------------------
INT 20 P - Microsoft Windows - MTRR - VxD SERVICES
        VxD = 004Ah
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01309)
Values for MTRR (VxD ID 004Ah) service number:
 00h    get version
 01h    ??? (highest service defined for Win95B)
SeeAlso: #01308,#01310
--------W-20----Vx004B-----------------------
INT 20 P - Microsoft Windows - NTKERN - VxD SERVICES
        VxD = 004Bh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01310)
Values for NTKERN (VxD ID 004Bh) service number:
 00h    get version???
 ...
 08h    ??? (highest service defined for Win95B)
SeeAlso: #01309,#01311
--------W-20----Vx011F-----------------------
INT 20 P - Microsoft Windows - VFLATD - VxD SERVICES
        VxD = 011Fh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01311)
Values for VFLATD (VxD ID 011Fh) service number:
 00h    get VFLATD version???
 01h    ???
SeeAlso: #01308,#01312
--------W-20----Vx0449-----------------------
INT 20 P - Microsoft Windows - vjoyd - VxD SERVICES
        VxD = 0449h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01312)
Values for vjoyd (VxD ID 0449h) service number:
 00h    get vjoyd version???
 01h    ???
SeeAlso: #01311,#01313
--------W-20----Vx044A-----------------------
INT 20 P - Microsoft Windows - mmdevldr - VxD SERVICES
        VxD = 044Ah
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01313)
Values for mmdevldr (VxD ID 044Ah) service number:
 00h    get mmdevldr version???
 01h    ???
 02h    ???
 03h    ???
 04h    ???
 05h    ???
SeeAlso: #01312,#01314
--------W-20----Vx0480-----------------------
INT 20 P - Microsoft Windows - VNetSup - VxD SERVICES
        VxD = 0480h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01314)
Values for VNetSup (VxD ID 0480h) service number:
 00h    get VNetSup version???
 01h    ???
 02h    ???
 03h    ???
 04h    ???
 05h    ???
 06h    ???
SeeAlso: #01313,#01315
--------W-20----Vx0481-----------------------
INT 20 P - Microsoft Windows - VREDIR - VxD SERVICES
        VxD = 0481h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01315)
Values for VREDIR (VxD ID 0481h) service number:
 0000h  "VRedir_Get_Version"
 0001h  "VRedir_Register"
 0002h  "VRedir_MakeMailSlot"
 0003h  "VRedir_DeleteMailSlot"
 0004h  "VRedir_ServerEnum"
 0010h  ...last service for Windows95 SP1
SeeAlso: #01314,#01316
--------W-20----Vx0483-----------------------
INT 20 P - Microsoft Windows - VSHARE - VxD SERVICES
        VxD = 0483h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01316)
Values for VSHARE (VxD ID 0483h) service number:
 00h    get VSHARE version???
SeeAlso: #01315,#01317
--------W-20----Vx0487-----------------------
INT 20 P - Microsoft Windows - NWLINK - VxD SERVICES
        VxD = 0487h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01317)
Values for NWLINK (VxD ID 0487h) service number:
 00h    get NWLINK version???
 01h    ???
 06h    ...last service for Windows95 SP1
SeeAlso: #01316,#01318,#02642
--------W-20----Vx0488-----------------------
INT 20 P - Microsoft Windows - VTDI - VxD SERVICES
        VxD = 0488h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01318)
Values for VTDI (VxD ID 0488h) service number:
 00h    get VTDI version???
 01h    ???
 08h    get ???
        seen called with DWORD -> ASCIZ "MSTCP" on stack, returning EAX=???
 0Dh    ...last service for Windows95 SP1
SeeAlso: #01317,#01319
--------W-20----Vx0489-----------------------
INT 20 P - Microsoft Windows - VIP - VxD SERVICES
        VxD = 0489h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01319)
Values for VIP (VxD ID 0489h) service number:
 00h    get VIP version???
 01h    ???
 05h    ???
 06h    ???
        returns EAX=0/1
 08h    ...last service for Windows95 SP1
--------W-20----Vx048A-----------------------
INT 20 P - Microsoft Windows - MSTCP - VxD SERVICES
        VxD = 048Ah
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01320)
Values for MSTCP (VxD ID 048Ah) service number:
 00h    get MSTCP version???
SeeAlso: #01319,#01321
--------W-20----Vx048B-----------------------
INT 20 P - Microsoft Windows - VCACHE - VxD SERVICES
        VxD = 048Bh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01321)
Values for VCACHE (VxD ID 048Bh) service number:
 0000h  "VCACHE_Get_Version"
 0001h  "VCACHE_Register"
 0002h  "VCACHE_GetSize"
 0003h  "VCACHE_CheckAvail"
 0004h  "VCACHE_FindBlock"
 0005h  "VCACHE_FreeBlock"
 0006h  "VCACHE_MakeMRU"
 0007h  "VCACHE_Hold"
 0008h  "VCACHE_Unhold"
 0009h  "VCACHE_Enum"
 000Ah  "VCACHE_TestHandle"
 000Bh  "VCACHE_VerifySums"
 000Ch  "VCACHE_RecalcSums"
 000Dh  "VCACHE_TestHold"
 000Eh  "VCACHE_GetStats"
 000Fh  "VCache_Deregister"
 0010h  "VCache_AdjustMinimum"
 0011h  "VCache_SwapBuffers"
 0012h  "VCache_RelinquishPage"
 0013h  "VCache_UseThisPage"
 0014h  "_VCache_CreateLookupCache"
 0015h  "_VCache_CloseLookupCache"
 0016h  "_VCache_DeleteLookupCache"
 0017h  "_VCache_Lookup"
 0018h  "_VCache_UpdateLookup"
SeeAlso: #01320,#01322
--------W-20----Vx048E-----------------------
INT 20 P - Microsoft Windows - NWREDIR - VxD SERVICES
        VxD = 048Eh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01322)
Values for NWREDIR (VxD ID 048Eh) service number:
 00h    get NWREDIR version???
 01h    ???
SeeAlso: #01321,#01323
--------W-20----Vx0491-----------------------
INT 20 P - Microsoft Windows - FILESEC - VxD SERVICES
        VxD = 0491h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01323)
Values for FILESEC (VxD ID 0491h) service number:
 00h    get FILESEC version???
 01h    ???
 10h    ...last service for Windows95 SP1
SeeAlso: #01322,#01324
--------W-20----Vx0492-----------------------
INT 20 P - Microsoft Windows - NWSERVER - VxD SERVICES
        VxD = 0492h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01324)
Values for NWSERVER (VxD ID 0492h) service number:
 00h    get NWSERVER version???
 01h    ???
 02h    ???
 03h    ???
SeeAlso: #01323,#01325
--------W-20----Vx0493-----------------------
INT 20 P - Microsoft Windows - MSSP / NWSP - VxD SERVICES
        VxD = 0493h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01325)
Values for MSSP/NWSP (VxD ID 0493h) service number:
 00h    get NSSP / NWSP version???
 01h    ???
 06h    ...last service for Windows95 SP1
SeeAlso: #01324,#01326
--------W-20----Vx0494-----------------------
INT 20 P - Microsoft Windows - NSCL - VxD SERVICES
        VxD = 0494h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01326)
Values for NSCL (VxD ID 0494h)  service number:
 00h    get NSCL version???
 01h    ???
 02h    ???
SeeAlso: #01325,#01327
--------W-20----Vx0495-----------------------
INT 20 P - Microsoft Windows - AFVXD - VxD SERVICES
        VxD = 0495h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01327)
Values for AFVXD (VxD ID 0495h) service number:
 00h    get version
        Return: CF clear
                AX = version (AH = high, AL = low)
 01h    ???
        EAX -> ???
        EBX -> ???
        ECX = ???
        Return: ???
 02h    ???
        EAX -> ???
        Return: ???
SeeAlso: #01326,#01328
--------W-20----Vx0496-----------------------
INT 20 P - Microsoft Windows - NDIS2SUP - VxD SERVICES
        VxD = 0496h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier (see #02642)
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01328)
Values for NDIS2SUP (VxD ID 0496h) service number:
 00h    get NDIS2SUP version???
 01h    ???
SeeAlso: #01327,#01329
--------W-20----Vx0498-----------------------
INT 20 P - Microsoft Windows - Splitter - VxD SERVICES
        VxD = 0498h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier (see #02642)
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01329)
Values for Splitter (VxD ID 0498h) service number:
 00h    get Splitter version
        Return: CF clear
                EAX = version (00000001h)
 01h    ???
 02h    ???
 03h    hook/unhook VMM "hook device service" service
        EAX = request (0 = unhook, nonzero = hook)
        Return: if EAX nonzero on entry, Splitter's service 04h replaces VMM
                  service 0090h; otherwise, default handler is restored
 04h    Splitter "hook device service" handler
SeeAlso: #01328,#01330
--------W-20----Vx0499-----------------------
INT 20 P - Microsoft Windows - PPPMAC - VxD SERVICES
        VxD = 0499h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier (see #02642)
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01330)
Values for PPPMAC (VxD ID 0499h) service number:
 00h    ???
 09h    ...last service for Windows95 SP1
SeeAlso: #01329,#01331,#02642
--------W-20----Vx049A-----------------------
INT 20 P - Microsoft Windows - VDHCP - VxD SERVICES
        VxD = 049Ah
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier (see #02642)
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01331)
Values for VDHCP (VxD ID 049Ah) service number:
 00h    get VDHCP version???
 01h    ???
 02h    ???
 03h    ???
SeeAlso: #01330,#01332
--------W-20----Vx049B-----------------------
INT 20 P - Microsoft Windows - VNBT - VxD SERVICES
        VxD = 049Bh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier (see #02642)
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01332)
Values for VNBT (VxD ID 049Bh) service number:
 00h    get VNBT version???
SeeAlso: #01331,#01333
--------W-20----Vx049D-----------------------
INT 20 P - Microsoft Windows - LOGGER - VxD SERVICES
        VxD = 049Dh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier (see #02642)
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01333)
Values for LOGGER (VxD ID 049Dh) service number:
 00h    get LOGGER version???
 01h    ???
 02h    ???
 03h    ???
 04h    ???
SeeAlso: #01332,#01334
--------W-20----Vx097C-----------------------
INT 20 P - Microsoft Windows - PCCARD - VxD SERVICES
        VxD = 097Ch
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier (see #02642)
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01334,#01340

(Table 01334)
Values for PCCARD (VxD ID 097Ch) service number:
 0000h  "PCCARD_Get_Version"
 0001h  "PCCARD_Card_Services"
SeeAlso: #01333,#01337
--------W-20----Vx3098-----------------------
INT 20 P - QEMM - VstlthD - VxD SERVICES
        VxD = 3098h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01337)
Values for VStlthD (VxD ID 3098h) service number:
 00h    get version
        Return: CF clear
                EAX = version (AH = major, AL = BCD minor)
 01h    ???
 02h    get current ???
        Return: CF clear
                EDX = current value of ???
 03h    ???
SeeAlso: #01334,#01338
--------W-20----Vx30F6-----------------------
INT 20 P - Microsoft Windows - WSVV - VxD SERVICES
        VxD = 30F6h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01338)
Values for WSVV (VxD ID 30F6h) service number:
 00h    get WSVV version???
SeeAlso: #01337,#01339
--------W-20----Vx33FC-----------------------
INT 20 P - Microsoft Windows - ASPIENUM - VxD SERVICES
        VxD = 33FCh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01339)
Values for ASPIENUM (VxD ID 33FCh) service number:
 00h    get ASPIENUM version???
 01h    ???
 02h    ???
 03h    ???
SeeAlso: #01338,#01340
--------W-20----Vx357E-----------------------
INT 20 P - Microsoft Windows - DSOUND - VxD SERVICES
        VxD = 357Eh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01340)
Values for DSOUND (VxD ID 357Eh) service number:
 00h    get DSOUND version???
 01h    ???
 02h    ???
SeeAlso: #01339,#01341
--------W-20----Vx39E6-----------------------
INT 20 P - Microsoft Windows - A3D - VxD SERVICES
        VxD = 39E6h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340


(Table 01341)
Values for A3D (VxD ID 39E6h) service number:
 00h    get version???
 01h    ???
 02h    ??? (highest service defined)
SeeAlso: #01340,#01342
--------W-20----Vx3BFD-----------------------
INT 20 P - Microsoft Windows - CWCPROXY - VxD SERVICES
        VxD = 3BFDh
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01342)
Values for CWCPROXY (VxD ID 3BFDh) service number:
 00h    get version???
 ...
 03h    ??? (highest service defined)
SeeAlso: #01341,#01343
--------W-20----Vx3C78-----------------------
INT 20 P - Microsoft Windows - VGARTD - VxD SERVICES
        VxD = 3C78h
Note:   the desired VxD and service number are identified by the data
          immediately following the INT 20 instruction, as in:
                INT     20h
                DW      service number
                DW      VxD identifier
SeeAlso: INT 2F/AX=1684h"DEVICE API",INT 30"Windows",#01265,#01340

(Table 01343)
Values for VGARTD (VxD ID 3C78h) service number:
 00h    get version???
 ...
 05h    ??? (highest service defined)
SeeAlso: #01342,#02642



--------W-2F1600-----------------------------
INT 2F - MS Windows - WINDOWS ENHANCED MODE INSTALLATION CHECK
        AX = 1600h
Return: AL = status
            00h neither Windows 3.x enhanced mode nor Windows/386 2.x running
            01h Windows/386 2.x running
            80h XMS version 1 driver installed (neither Windows 3.x enhanced
                  mode nor Windows/386 2.x running) (obsolete--see note)
            FFh Windows/386 2.x running
        AL = anything else
            AL = Windows major version number >= 3
            AH = Windows minor version number
Notes:  INT 2F/AH=16h comprises an API for non-Windows programs (DOS device
          drivers, TSRs, and applications) to cooperate with multitasking
          Windows/386 2.x and Windows 3.x and higher enhanced mode.
        certain calls are also supported in the Microsoft 80286 DOS extender in
          Windows standard mode
        this function served as the installation check and AX=1610h served to
          get the driver entry point for XMS version 1, which is now obsolete.
          Use AX=4300h and AX=4310h instead
        Windows95 reports version 4.00, Windows95B reports version 4.03
SeeAlso: AX=160Ah,AX=1610h,AX=4300h,AX=4680h
Index:  installation check;XMS version 1
--------W-2F1602-----------------------------
INT 2F - MS Windows/386 2.x - GET API ENTRY POINT
        AX = 1602h
Return: ES:DI -> Windows/386 2.x API procedure entry point
Notes:  this interface is supported in Windows 3.x and Windows95 only for 2.x
          compatibility
        to get the current virtual machine (VM) ID in Windows/386 2.x:
            AX = 0000h
            ES:DI -> return address
            JUMP to address returned from INT 2F/AX=1602h
        After JUMP, at return address:
            BX = current VM ID.
SeeAlso: AX=C020h
--------W-2F1603-----------------------------
INT 2F C - MS Windows/386 - GET INSTANCE DATA
        AX = 1603h
Return: AX = 5248h ('RH') if supported
            DS:SI -> Windows/386 instance data (see #02630)
Notes:  reportedly supported by RM Nimbus MS-DOS 3.3 kernel
        this function is called by DOSMGR when AX=1607h/BX=0015h is not
          supported, as is the case in DOS versions prior to 5.0
        see Geoff Chappell's book _DOS_Internals_ for additional discussions of
          this function, DOSMGR's behavior, and instancing in general
SeeAlso: AX=1607h/BX=0015h

Format of Windows/386 instance data:
Offset  Size    Description     (Table 02630)
 00h    WORD    segment of IO.SYS (0000h = default 0070h)
 02h    WORD    offset in IO.SYS of STACKS data structure (DOS 3.2x)
                0000h if not applicable
 04h    WORD    number of instance data entries (max 32)
 06h    Array of instance data entries
        Offset  Size    Description
         00h    WORD    segment (0002h = DOS kernel)
         02h    WORD    offset
         04h    WORD    size
--------W-2F1605-----------------------------
INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX INIT BROADCAST
        AX = 1605h
        ES:BX = 0000h:0000h
        DS:SI = 0000h:0000h
        CX = 0000h
        DX = flags
            bit 0 = 0 if Windows enhanced-mode initialization
            bit 0 = 1 if Microsoft 286 DOS extender initialization
            bits 1-15 reserved (undefined)
        DI = version number (major in upper byte, minor in lower)
Return: CX = 0000h if okay for Windows to load
        CX = FFFFh (other registers unchanged) if Windows 3.0 in standard mode
        CX <> 0 if Windows should not load
        ES:BX -> startup info structure (see #02631)
        DS:SI -> virtual86 mode enable/disable callback or 0000h:0000h
              (see #02634)
Notes:  the Windows enhanced mode loader and Microsoft 286 DOS extender will
          broadcast an INT 2F/AX=1605h call when initializing.  Any DOS device
          driver or TSR can watch for this broadcast and return the appropriate
          values.  If the driver or TSR returns CX <> 0, it is also its
          responsibility to display an error message (however, Windows95 is
          reported to load regardless of the returned CX).
        each handler must first chain to the prior INT 2F handler with
          registers unchanged before processing the call
        if the handler requires local data on a per-VM basis, it must store the
          returned ES:BX in the "next" field of a startup info structure and
          return a pointer to that structure in ES:BX
        a single TSR may set the V86 mode enable/disable callback; if DS:SI is
          already nonzero, the TSR must fail the initialization by setting CX
          nonzero
        MSD checks for Windows 3.0 running in standard mode by testing whether
          CX=FFFFh and other registers are unchanged on return
        Novell DOS v7.0 (Update 8 - Update 11) TASKMGR in multitasking mode
          uses this broadcast, even if TASKMGR.INI sets WinPresent= to OFF
        Microsoft's EMM386.EXE for DOS 5+ when installed with the NOEMS option
          changes its driver name from EMMQXXX0 to EMMXXXX0 while Windows is
          active
SeeAlso: AX=1606h,AX=1608h,AX=4B05h

Format of Windows Startup Information Structure:
Offset  Size    Description     (Table 02631)
 00h  2 BYTEs   major, minor version of info structure
 02h    DWORD   pointer to next startup info structure or 0000h:0000h
 06h    DWORD   pointer to ASCIZ name of virtual device file or 0000h:0000h
 0Ah    DWORD   virtual device reference data (see #02633)
                (only used if above nonzero)
 0Eh    DWORD   pointer to instance data records (see #02632) or 0000h:0000h
---structure version >= 4.0---
 12h    DWORD   pointer to optionally-instanced data records (see #02632)
                  or 0000h:0000h

Format of one Instance Item in array:
Offset  Size    Description     (Table 02632)
 00h    DWORD   address of instance data (end of array if 0000h:0000h)
 04h    WORD    size of instance data
SeeAlso: #02631

Format of Virtual Device Reference Data:
Offset  Size    Description     (Table 02633)
 00h    DWORD   physical address of ??? or 00000000h
 04h    DWORD   physical address of ??? table
 08h    DWORD   "DEST_PAGE" address to which pages must be mapped
 0Ch  N DWORDs  "SRC_PAGE" physical addresses of the pages
                00000000h = end of table
Note:   EMM386.EXE sets the first pointer to the start of the device driver
          chain, the second pointer to a field of 40h bytes followed by a
          16-bit offset to the end of the SRC_PAGE table, and DEST_PAGE to
          the start segment of the UMB area
SeeAlso: #02631

(Table 02634)
Values Windows virtual mode enable/disable procedure is called with:
        AX = 0000h disable V86 mode
        AX = 0001h enable V86 mode
        interrupts disabled
Return: CF set on error
        CF clear if successful
        interrupts disabled
SeeAlso: #02631
--------W-2F1606-----------------------------
INT 2F C - MS Windows - WINDOWS ENHANCED MODE & 286 DOSX EXIT BROADCAST
        AX = 1606h
        DX = flags
            bit 0 = 0 if Windows enhanced-mode exit
            bit 0 = 1 if Microsoft 286 DOS extender exit
            bits 1-15 reserved (undefined)
Notes:  if the init broadcast fails (AX=1605h returned CX <> 0), then this
          broadcast will be issued immediately.
        this call will be issued in real mode
        Novell DOS v7.0 (Update 8 - Update 15) TASKMGR in multitasking mode
          uses this broadcast, even if TASKMGR.INI sets WinPresent= to OFF
SeeAlso: AX=1605h,AX=1609h
--------W-2F1607-----------------------------
INT 2F C - MS Windows - VIRTUAL DEVICE CALL OUT API
        AX = 1607h
        BX = virtual device ID (see #02642)
        CX = (usually) callout subfunction
Return: (usually) AX,BX,CX,DX,ES contain results
Notes:  more of a convention than an API, this call specifies a standard
          mechanism for Windows enhanced-mode virtual devices (VxD's) to talk
          to DOS device drivers and TSRs
        see below for details on several virtual devices
SeeAlso: AX=1605h,AX=1607h/BX=000Ch,AX=1607h/BX=0014h,AX=1607h/BX=0015h
SeeAlso: AX=1607h/BX=0018h,AX=1684h"DEVICE API",AX=C020h
--------W-2F1607BX0006-----------------------
INT 2F C - MS Windows - "V86MMGR" VIRTUAL DEVICE API
        AX = 1607h
        BX = 0006h (VxD identifier of "V86MMGR")
        CX = 0000h
Return: AX = status
            0000h if local A20 state changed
            1607h if A20 unchanged
            other if global A20 state changed
SeeAlso: AX=1607h"CALL OUT API"
--------W-2F1607BX000C-----------------------
INT 2F C - MS Windows - "VMD" VIRTUAL MOUSE DEVICE API
        AX = 1607h
        BX = 000Ch (VxD identifier of "VMD")
Return: CX = nonzero if mouse driver already virtualized
Note:   VMD (Virtual Mouse Driver) calls this and then checks whether CX is
          nonzero; if yes, it will not automatically virtualize the mouse
          driver.  This would be used if MOUSE.COM already virtualizes
          itself using the Windows API.
SeeAlso: AX=1607h/BX=0014h,AX=1607h/BX=0015h
--------W-2F1607BX000D-----------------------
INT 2F C - MS Windows95 - "VKD" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 000Dh (VxD ID for VKD)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------W-2F1607BX0010-----------------------
INT 2F C - MS Windows 3.1 - "BLOCKDEV" VIRTUAL HARD DISK DEVICE API
        AX = 1607h
        BX = 0010h (VxD identifier of "BLOCKDEV")
        CX = function
            0001h starting FastDisk compatibility tests
            0002h ending FastDisk compatibility tests
            0003h check if FastDisk installation allowed
                Return: CX = 0000h if allowed
Note:   this interface is called by the Windows FastDisk driver (such as
          WDCTRL) when it thinks that the INT 13h handler immediately below
          IO.SYS's INT 13h code is not in ROM; it should be supported by any
          program which hooks itself underneath IO.SYS's INT 13h code with
          INT 2F/AH=13h
SeeAlso: AX=1607h/BX=0014h,INT 2F/AH=13h
--------W-2F1607BX0014-----------------------
INT 2F C - MS Windows - "VNETBIOS" VIRTUAL DEVICE API
        AX = 1607h
        BX = 0014h (VxD identifier of "VNETBIOS")
Return: ES:DI -> 128-byte table specifying VNETBIOS actions for each NetBIOS
                command code (see #02635)
Note:   VNETBIOS (Virtual NetBIOS) calls this function to determine whether
          the NetBIOS has an extensions Windows should know about
SeeAlso: AX=1607h/BX=000Ch,AX=1607h/BX=0010h,AX=1607h/BX=0015h

(Table 02635)
Values for VNETBIOS action code:
 00h    "VN_Unknown" unknown command
 04h    "VN_No_Map"  no memory mapping necessary
 08h    "VN_Map_In"  input buffer is quickly used, so no global mapping needed
 0Ch    "VN_Map_In"  output buffer is quickly used, so no global mapping needed
 10h    "VN_Map_In_Out"  buffer is quickly used, so no global mapping needed
 14h    "VN_Chain_Send"  the chain-send command
 18h    "VN_Cancel"     special case for cancel command
 1Ch    "VN_Buffer_In"  buffer is incoming
 20h    "VN_Buffer_Out" buffer is outgoing
 24h    "VN_Buffer_In_Out" buffer used for both incoming and outgoing data
--------D-2F1607BX0015-----------------------
INT 2F C - MS Windows - "DOSMGR" VIRTUAL DEVICE API
        AX = 1607h
        BX = 0015h (VxD identifier of "DOSMGR")
        CX = function
            0000h query instance processing
                DX = 0000h
                Return: CX = state
                            0000h not instanced
                            other instanced (DOS 5+ kernel returns 0001h)
                                DX = segment of DOS drivers or 0000h for
                                        default of 0070h
                                ES:BX -> patch table (see #02637)
            0001h set patches in DOS
                DX = bit mask of patch requests (see #02636)
                Return: AX = B97Ch
                        BX = bit mask of patches applied (see #02636)
                        DX = A2ABh
            0002h remove patches in DOS (ignored by DOS 5.0 kernel)
                DX = bit mask of patch requests (see #02636)
                Return: CX = 0000h (DOS 5-6)
                Note:   return values are ignored by DOSMGR in Windows 3.1
            0003h get size of DOS data structures
                DX = bit mask of request (only one bit can be set)
                    bit 0: Current Directory Structure size
                Return: if supported request:
                            AX = B97Ch
                            CX = size in bytes of requested structure
                            DX = A2ABh
                        else:
                            CX = 0000h
                            all other registers preserved
            0004h determine instanced data structures
                Return: AX = B97Ch if supported
                        DX = A2ABh if supported (DOS 5+ kernel returns 0000h)
                        BX = bit mask of instanced items
                            bit 0: CDS
                            bit 1: SFT
                            bit 2: device list
                            bit 3: DOS swappable data area
            0005h get device driver size
                ES = segment of device driver
                Return: DX:AX = 0000h:0000h on error (not dev. driver segment)
                        DX:AX = A2ABh:B97Ch if successful
                            BX:CX = size of device driver in bytes
Notes:  DOSMGR (DOS Manager) will check whether the OEM DOS/BIOS data has
          been instanced via this API and will not perform its own default
          instancing of the normal DOS/BIOS data if so; if this API is not
          supported, DOSMGR will also try to access instancing data through
          INT 2F/AX=1603h
        these functions are supported by the DOS 5+ kernel; DOSMGR contains
          tables of instancing information for earlier versions of DOS
        see Geoff Chappell's book _DOS_Internals_ for additional discussions of
          DOSMGR's behavior and instancing in general
SeeAlso: AX=1603h,AX=1605h,AX=1607h/BX=000Ch,AX=1607h/BX=0014h
SeeAlso: AX=1684h"DEVICE API"

Bitfields for DOSMGR patch requests:
Bit(s)  Description     (Table 02636)
 0      enable critical sections
 1      NOP setting/checking user ID
 2      turn INT 21/AH=3Fh on STDIN into polling loop
 3      trap stack fault in "SYSINIT" to WIN386
 4      BIOS patch to trap "Insert disk X:" to WIN386

Format of DOSMGR patch table:
Offset  Size    Description     (Table 02637)
 00h  2 BYTEs   DOS version (major, minor)
 02h    WORD    offset in DOS data segment of "SAVEDS"
 04h    WORD    offset in DOS data segment of "SAVEBX"
 06h    WORD    offset in DOS data segment of InDOS flag
 08h    WORD    offset in DOS data segment of User ID word
 0Ah    WORD    offset in DOS data segment of "CritPatch" table to enable
                  critical section calls (see INT 2A/AH=80h)
 0Ch    WORD    (DOS 5+ only) offset in DOS data segment of "UMB_HEAD",
                  containing segment of last MCB in conventional memory
--------W-2F1607BX0018-----------------------
INT 2F C - MS Windows - "VMPoll" VIRTUAL DEVICE - IDLE CALLOUT
        AX = 1607h
        BX = 0018h (VMPoll VxD ID) (see #02642)
        CX = 0000h
Return: AX = status
            0000h if timeslice used
            nonzero if timeslice not needed
Note:   when VMPoll makes this callout, all virtual machines are idle, and any
          interested TSR can use the opportunity to perform background
          processing
SeeAlso: AX=1607h"CALL OUT API",AX=1689h
--------W-2F1607BX0021--------------------------------------
INT 2F C - MS Windows - "PageFile" VIRTUAL DEVICE - GET LOCK BYTE
        AX = 1607h
        BX = 0021h (PageFile VxD ID)
        CX = 0000h
Return: AX = status
            0000h success
                ES:DI -> cache lock byte in disk cacher
            other no disk cache or unsupported
Notes:  PageFile issues this call on real-mode initialization in order to allow
          disk caches to provide it with a byte which it can use to temporarily
          lock the disk cache; VMPOLL also issues this call, so it is made
          twice each time Windows starts up
        if this call fails, PageFile falls back to other techniques for locking
          the disk cache
SeeAlso: AX=1607h"CALL OUT API"
--------W-2F1607BX002D-----------------------
INT 2F C - MS Windows - "W32S" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 002Dh (VxD ID for W32S)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------W-2F1607BX0040-----------------------
INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 0040h (VxD ID for IFSMgr)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------W-2F1607BX0446-----------------------
INT 2F C - MS Windows - "VADLIBD" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 0446h (VxD ID for VADLIBD)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------W-2F1607BX0484-----------------------
INT 2F C - MS Windows - "IFSMgr" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 0484h (VxD ID for IFSMgr)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------W-2F1607BX0487-----------------------
INT 2F C - MS Windows - "NWSUP" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 0487h (VxD ID for NWSUP)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------E-2F1607BX22C0-----------------------
INT 2F C - Rational Systems DOS/4GW - ???
        AX = 1607h
        BX = 22C0h
        ???
Return: ???
SeeAlso: INT 15/AX=BF02h,INT 15/AX=BF04h,#02642
--------W-2F1607BX28A1-----------------------
INT 2F C - MS Windows - "PharLap" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 28A1h (VxD ID for PharLap)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------W-2F1607BX7A5F-----------------------
INT 2F C - MS Windows - "SIWVID" VIRTUAL DEVICE - ??? CALLOUT
        AX = 1607h
        BX = 7A5Fh (VxD ID for SIWVID)
        ???
Return: ???
SeeAlso: AX=1607h"CALL OUT API",#02642
--------W-2F1608-----------------------------
INT 2F C - MS Windows - WINDOWS ENHANCED MODE INIT COMPLETE BROADCAST
        AX = 1608h
Notes:  called after all installable devices have been initialized
        real-mode software may be called between the Windows enhanced-mode init
          call (AX=1605h) and this call; the software must detect this
          situation
SeeAlso: AX=1605h,AX=1609h
--------W-2F1609-----------------------------
INT 2F C - MS Windows - WINDOWS ENHANCED MODE BEGIN EXIT BROADCAST
        AX = 1609h
Note:   called at the beginning of a normal exit sequence; not made in the
          event of a fatal system crash
SeeAlso: AX=1606h,AX=1608h
--------W-2F160A-----------------------------
INT 2F - MS Windows 3.1 - IDENTIFY WINDOWS VERSION AND TYPE
        AX = 160Ah
Return: AX = 0000h if call supported
            BX = version (BH=major, BL=minor)
            CX = mode (0002h = standard, 0003h = enhanced)
Note:   Windows95 reports version 4.00, Windows95B reports version 4.03
SeeAlso: AX=1600h,AX=4680h
--------W-2F160B-----------------------------
INT 2F - MS Windows 3.1 - IDENTIFY TSRs
        AX = 160Bh
        ES:DI = 0000h:0000h
Return: ES:DI -> TSR information structure (see #02638)
Desc:   this call allows Windows-aware TSRs to make themselves known to
          Windows.
Note:   the TSR should first chain to the previous INT 2F handler, then
          allocate a communication structure, place the returned ES:DI
          pointer in the first field, and return a pointer to the new
          structure
SeeAlso: AX=1605h,AX=160Ch,AX=4B01h,AX=4B05h

Format of TSR-to-Windows information structure:
Offset  Size    Description     (Table 02638)
 00h    DWORD   pointer to next structure
 04h    WORD    PSP segment
 06h    WORD    API version ID (0100h)
 08h    WORD    EXEC flags (how to load command specified by "exec_cmd")
                bit 0: "WINEXEC"
                bit 1: "LOADLIBRARY"
                bit 2: "OPENDRIVER"
 0Ah    WORD    "exec_cmd_show" (see #02639)
 0Ch    DWORD   "exec_cmd" pointer to command line to be executed
 10h  4 BYTEs   reserved (0)
 14h    DWORD   pointer to TSR ID block (see #02640)
 18h    DWORD   pointer to TSR data block or 0000h:0000h

(Table 02639)
Values for TSR information structure "exec_cmd_show":
 00h    HIDE
 01h    SHOWNORMAL
 02h    SHOWMINIMIZED
 03h    SHOWMAXIMIZED
 04h    SHOWNOACTIVE
 05h    SHOW
 06h    MINIMIZE
 07h    SHOWMINNOACTIVE
 08h    SHOWNA
 09h    RESTORE
Note:   this value is passed as the second parameter to the WinExec(),
          LoadLibrary(), or OpenDriver() call used to execute a requested
          command line
SeeAlso: #02638

Format of Norton Utilities 6.0 TSR ID block:
Offset  Size    Description     (Table 02640)
 00h    WORD    length of name string
 02h  N BYTEs   name of TSR's executable
SeeAlso: #02638
--------W-2F160C-----------------------------
INT 2F - MS Windows 3.1 - DETECT ROMs
        AX = 160Ch
        ???
Return: ???
Note:   used by ROM Windows; appears to be a NOP under standard Windows95 and
          Windows95B
SeeAlso: AX=160Bh,INT 21/AH=6Dh"ROM"
----------2F1615-----------------------------
INT 2F - Windows95 - SAVE32.COM - INSTALLATION CHECK
        AX = 1615h
Return: AX = 0000h if installed
            BX = segment of resident code
Program: SAVE32.COM is a TSR included in the Windows95 distribution which
          preserves the contents of 32-bit registers across invocations of
          all of the hardware interrupt handlers (which, for some older BIOSes
          and TSRs, do not properly preserve the high words of the 32-bit
          registers)
--------W-2F1680-----------------------------
INT 2F - MS Windows, DPMI, various - RELEASE CURRENT VIRTUAL MACHINE TIME-SLICE
        AX = 1680h
Return: AL = status
            00h if the call is supported
            80h (unchanged) if the call is not supported
Notes:  programs can use this function in idle loops to enhance performance
          under multitaskers; this call is supported by MS Windows 3+, DOS 5+,
          DPMI 1.0+, and in OS/2 2.0+ for multitasking DOS applications
        does not block the program; it just gives up the remainder of the time
          slice
        should not be used by Windows-specific programs
        when called very often without intermediate screen output under
          MS Windows 3.x, the VM will go into an idle-state and will not
          receive the next slice before 8 seconds have elapsed. This time can
          be changed in SYSTEM.INI through "IdleVMWakeUpTime=<seconds>".
          Setting it to zero results in a long wait.
        this function has no effect under OS/2 2.10-4.0 if the DOS box has an
          "Idle Sensitivity" setting of 100
SeeAlso: AX=1689h,INT 15/AX=1000h,INT 15/AX=5305h,INT 21/AH=89h,INT 7A/BX=000Ah
--------W-2F1681-----------------------------
INT 2F - MS Windows 3+ - BEGIN CRITICAL SECTION
        AX = 1681h
Notes:  used to prevent a task switch from occurring
        should be followed by an INT 2F/AX=1682h call as soon as possible
        nested calls are allowed, and must be followed by an appropriate number
          of "end critical section" calls
        not supported in Windows/386 2.x. Get INDOS flag with INT 21/AH=34h and
          increment by hand.
SeeAlso: AX=1682h,INT 15/AX=101Bh,INT 21/AH=34h
--------W-2F1682-----------------------------
INT 2F - MS Windows 3+ - END CRITICAL SECTION
        AX = 1682h
Notes:  not supported in Windows/386 2.x.  Get InDOS flag with INT 21/AH=34h
          and decrement by hand, taking care not to decrement InDOS flag
          through zero
SeeAlso: AX=1681h,INT 15/AX=101Ch,INT 21/AH=34h
--------W-2F1683-----------------------------
INT 2F - MS Windows 3+ - GET CURRENT VIRTUAL MACHINE ID
        AX = 1683h
Return: BX = current virtual machine (VM) ID
Notes:  Windows itself currently runs in VM 1, but this can't be relied upon
        VM IDs are reused when VMs are destroyed
        an ID of 0 will never be returned
SeeAlso: AX=1684h"DEVICE API",AX=1685h,AX=168Bh
--------W-2F1684-----------------------------
INT 2F - MS Windows - GET DEVICE API ENTRY POINT
        AX = 1684h
        BX = virtual device (VxD) ID (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point, or 0:0 if the VxD does not support an API
Note:   some Windows enhanced-mode virtual devices provide services that
          applications can access.  For example, the Virtual Display Device
          (VDD) provides an API used in turn by WINOLDAP.
SeeAlso: AX=1684h/BX=0001h,AX=1684h/BX=0015h,AX=1683h,AX=4011h,INT 20"Windows"

(Table 02642)
Values for MS Windows VxD ID:
Value   Name   CallOut V86 PM   Description
 0000h  ACT200L      ?  ?  ?    IrDA Infrared ActiSys framer VxD
 0000h  ACT220L      ?  ?  ?    IrDA Infrared ActiSys 220 framer VxD
 0000h  ADAPTEC      ?  ?  ?    IrDA Infrared Adaptec framer VxD
 0000h  AM1500T      ?  N  N    (Win95)
 0000h  ATI          ?  N  N    (Win95) ATI display driver
 0000h  ATIPPCAP     ?  N  Y    ATI Rage128-based video card
 0000h  CDFS         ?  N  N
 0000h  CDTSD        ?  N  N    (Win95) CD-ROM Type-Specific Driver
 0000h  CE2NDIS3     ?  N  N    (W4Wg)
 0000h  CENDIS       ?  N  N    (W4Wg)
 0000h  CHIPS        ?  N  N    (Win95) Chips&Tech display driver
 0000h  CIRRUS       ?  N  N    (Win95) Cirrus display driver
 0000h  CTNDW        ?  N  N    (W4Wg)
 0000h  CTVSD        ?  N  N    (Win95) CD-ROM Vendor-Specific Driver
 0000h  CM2NDIS3     ?  N  N    (W4Wg)
 0000h  COMBUFF      ?  N  N    (Win95)
 0000h  COMPAQ       ?  N  N    (Win95) Compaq display driver
 0000h  CPQNDIS3     ?  N  N    (W4Wg)
 0000h  CRYSTAL      ?  ?  ?    IrDA Infrared Crystal framer VxD
 0000h  CWCENUM      ?  N  N    (Win95SR2???)
 0000h  CWCSPUD3     ?  N  N    (Win95SR2???)
 0000h  DBKVSSD      ?  N  N    (Win95) Databook PCMCIA socket services???
 0000h  DDOM95       ?  N  N
 0000h  DECLAN       ?  N  N    (W4Wg)
 0000h  DiskTSD      ?  N  N    (Win95) hard-disk Type-Specific Driver
 0000h  DiskVSD      ?  N  N    (Win95) hard-disk Vendor-Specific Driver
 0000h  DMICTVXD     ?  N  N
 0000h  DMMDVDX      ?  N  N    Diamond MaximumDVD
 0000h  DRVSPACX     ?  N  N    (Win95)
 0000h  E30N3        ?  N  N    (W4Wg)
 0000h  E31N3           N  N    (W4Wg)
 0000h  EE16            N  N    (W4Wg)
 0000h  EISA            N  N    (Win95)
 0000h  EL59X           N  N    (Win95)
 0000h  ELNK16          N  N    (W4Wg)
 0000h  ELNK3           N  N    (Win95)
 0000h  ELNKII          N  N    (W4Wg)
 0000h  ELNKMC          N  N    (W4Wg)
 0000h  ELPC3           N  N    (W4Wg)
 0000h  ENABLE2         N  N    (Win95)
 0000h  ENABLE4         N  N    (Win95)
 0000h  EPRO            N  N    (Win95)
 0000h  ES1488V         N  N    (Win95)
 0000h  ES1688V         N  N    (Win95)
 0000h  ES488V          N  N    (Win95)
 0000h  ES688V          N  N    (Win95)
 0000h  ESI             ?  ?    IrDA Infrared ESI framer VxD
 0000h  FILEMON         N  N    DOS386 File Monitor
 0000h  FLS1MTD         N  N    (Win95) flash-memory driver???
 0000h  FLS2MTD         N  N    (Win95) flash-memory driver???
 0000h  HPEISA          N  N    (W4Wg)
 0000h  HPFEND          N  N    (W4Wg)
 0000h  HPISA           N  N    (W4Wg)
 0000h  HPMCA           N  N    (W4Wg)
 0000h  HSFLOP          N  N
 0000h  IBMTOK          N  N    (W4Wg)
 0000h  IBMTOK4         N  N    (Win95)
 0000h  IRCOMM          ?  ?    IrDA Infrared Virtual COM/LPT driver
 0000h  IRLAMPEX        ?  ?    IrDA Infrared Protocol VxD
 0000h  IRLAPFRM        ?  ?    IrDA Infrared Virtual COM/LPT frame driver
 0000h  IRMATRAK        N  N    (W4Wg)
 0000h  JAVASUP         N  N    Internet Explorer JAVA support
 0000h  KEYREMAP        N  N    (Windows95 PowerToys) shift-key remapper
 0000h  LPT          N  N  N    (Win4Workgroups 3.11) DOS386 LPT Device
 0000h  LPTENUM      ?  N  N
 0000h  MONVSD       ?  ?  ?
 0000h  MGA          ?  N  N    (Win95) Matrox MGA display driver
 0000h  MSMINI       ?  N  N    (Win95)
 0000h  MSODISUP     N  N  N    (Win4Workgroups 3.11) MS ODI Support
 0000h  mvpas        ?  N  N    (Win95) Pro Audio Spectrum driver
 0000h  NECATAPI     ?  N  N    (Win95)
 0000h  NICE         ?  N  N    (Win95)
 0000h  NTI4CDR      ?  Y  Y    NTI CD-R/CD-RW
 0000h  NV3          ?  N  N    (Win95SR2)
 0000h  NWNBLINK     N  N  N    (Win4Workgroups 3.11) Netware NetBIOS
 0000h  OAK             N  N    (Win95) Oak Tech display driver
 0000h  OCTK32          N  N    (W4Wg)
 0000h  OTCETH          N  N    (W4Wg)
 0000h  PARALINK        N  N    (Win95)
 0000h  PARALLAX        ?  ?    IrDA Infrared Parallax framer VxD
 0000h  PCNTN3          N  N    (W4Wg)
 0000h  PE3NDIS         N  N    (W4Wg)
 0000h  PPM             N  N    (Win95)
 0000h  PROTEON         N  N    (W4Wg)
 0000h  QEMMFix         N  N
 0000h  QIC117          N  N    (Win95) QIC-117 floppy-ctrl tape drive
 0000h  QPI             N  N    QEMM Programming Interface (see INT 67/AH=3Fh)
 0000h  RMM             N  N    Real-Mode Mapper for hw with real-mode drivers
 0000h  S3              N  N    (Win95) S3 display driver
 0000h  S3INFO          N  N
 0000h  S3MINI          N  N    S3 display driver
 0000h  SAGE            N  N    (Plus!) System Agent
 0000h  sage            N  N    (Plus! for Win95) System Agent
 0000h  scsi1hlp        N  N    (Win95)
 0000h  SERENUM         N  N
 0000h  SERIAL       N  N  N    (Win4Workgroups 3.11) DOS386 Serial Device
 0000h  SERWAVE      ?  N  N
 0000h  SETP3        ?  N  N    (Win95) Silicon Ethernet Pocket Adapter
 0000h  SLMSDENM     ?  Y  Y
 0000h  SMARTVSD     ?  N  N    (EZ-SMART???)
 0000h  SMC8000W     ?  N  N    (W4Wg)
 0000h  SMC80PC      ?  N  N    (W4Wg)
 0000h  SMC8100W     ?  N  N    (W4Wg)
 0000h  SMC8232W     ?  N  N    (W4Wg)
 0000h  SMC9000      ?  N  N    (W4Wg)
 0000h  SNIP         ?  N  N    (W4Wg)
 0000h  SOCKET       ?  N  N    (W4Wg)
 0000h  SOCKETSV     ?  N  N    (Win95)
 0000h  SPAP         ?  Y  Y    (Win95)
 0000h  SPENDIS      ?  N  N    (Win95)
 0000h  SRAMMTD      ?  N  N    (Win95) flash-memory driver???
 0000h  STLTH64      ?  N  N    Diamond Stealth64 driver
 0000h  STLTHMON     ?  N  N
 0000h  T20N3        ?  N  N    (W4Wg)
 0000h  T30N3        ?  N  N    (W4Wg)
 0000h  TCTOK        ?  N  N    (W4Wg)
 0000h  TSENG        ?  N  N    (Win95) Tseng Labs display driver
 0000h  UBNEI        ?  N  N    (W4Wg)
 0000h  UNIMODEM     ?  ?  ?    (Win95) Universal Modem Driver
 0000h  VDEF         ?  N  N    (Win95)
 0000h  VGATEWAY     ?  N  Y    (Win95) dialin gateway
 0000h  VIDEO7       ?  N  N    (Win95) Video7 display driver
 0000h  VRomD        ?  N  N    (Win95)
 0000h  VStDspcD     ?  ?  ?    Quarterdeck Stealth D*Space
 0000h  VXDMON       ?  ?  ?
 0000h  WD           ?  N  N    (Win95)
 0000h  WINTOP       ?  N  N    (Windows95 Power Toys)
 0000h  WSHTCP       ?  N  N
 0000h  XGA          ?  N  N    (Win95) XGA display driver
 0001h  VMM          ?  N  N    Virtual Machine Manager
 0001h  VMM          ?  Y  Y    Windows95 Virtual Machine Manager
 0002h  Debug        ?  ?  ?
 0003h  VPICD        ?  Y  Y    Virtual Prog. Interrupt Controller (PIC) Device
 0004h  VDMAD        ?  N  N    Virtual Direct Memory Access (DMA) Device
 0005h  VTD          ?  Y  Y    Virtual Timer Device
 0006h  V86MMGR      Y  N  N    (Windows3.x) Virtual 8086 Mode Device
 0006h  V86MMGR      ?  N  Y    (Win95) Virtual 8068 Mode Device
 0007h  PageSwap     ?  N  N    Paging Device
 0008h  Parity       ?  N  N    Parity-check trapper
 0009h  Reboot       ?  N  Y    Ctrl-Alt-Del handler
 000Ah  VDD          ?  N  Y    Virtual Display Device (GRABBER)
 000Bh  VSD          ?  N  N    Virtual Sound Device
 000Ch  VMD          Y  Y  Y    Virtual Mouse Device
 000Dh  VKD          ?  N  Y    Virtual Keyboard Device
 000Eh  VCD          ?  N  Y    Virtual COMM Device
 000Fh  VPD          ?  N  Y    Virtual Printer Device
 0010h  VHD          ?  ?  ?    Virtual Hard Disk Device (Windows 3.0)
 0010h  BLOCKDEV     Y  N  N    Virtual Hard Disk Device (Windows 3.1)
 0010h  IOS          N  N  N    (Win4Workgroups 3.11) DOS386 IOS Device
 0010h  IOS          ?  Y  Y    Windows95 I/O Supervisor
 0011h  VMCPD        ?  Y  Y    (Windows3.x) Virtual Math CoProcessor Device
 0011h  VMCPD        ?  N  Y    (Win95) Virtual Math CoProcessor Device
 0012h  EBIOS        ?  N  N    Reserve EBIOS page (e.g., on PS/2)
 0013h  BIOSXLAT     ?  N  N    Map ROM BIOS API between prot & V86 mode
 0014h  VNETBIOS     Y  N  N    Virtual NetBIOS Device
 0015h  DOSMGR       Y  Y  N    DOS data instancing (see #02656)
 0016h  WINLOAD      ?  ?  ?
 0017h  SHELL        ?  N  Y    (Windows3)
 0017h  SHELL        ?  Y  Y    (Win95)
 0018h  VMPOLL       Y  N  N
 0019h  VPROD        ?  ?  ?
 001Ah  DOSNET       ?  N  N    assures network integrity across VMs
 001Ah  VNETWARE     ?  Y  Y    Novell NetWare DOSNET replacement
 001Bh  VFD          ?  N  N    Virtual Floppy Device
 001Ch  VDD2         ?  ?  ?    Secondary display adapter
 001Ch  LoadHi       ?  N  N    Netroom LoadHi Device (RMLODHI.VXD)
 001Ch  LoadHi       ?  N  N    386MAX LoadHi Device (386MAX.VXD)
 001Ch  LoadHi       ?  N  N    Win386 LoadHi Device (EMM386.EXE)
 001Dh  WINDEBUG     ?  N  Y
 001Dh  TDDebug      ?  N  Y
 001Eh  TSRLoad      ?  ?  ?    TSR instance utility
 001Fh  BiosHook     ?  ?  ?    BIOS interrupt hooker VxD
 0020h  Int13        N  N  N
 0021h  PageFile     Y  N  Y    Paging File device
 0022h  SCSI         ?  ?  ?
 0022h  APIX         ?  N  Y    (Win95)
 0023h  MCA_POS      ?  ?  ?    Microchannel Programmable Option Select
 0024h  SCSIFD       ?  ?  ?    SCSI FastDisk device
 0025h  VPEND        ?  ?  ?    Pen device
 0026h  APM          ?  ?  ?    Advanced Power Management
 0026h  VPOWERD      ?  Y  Y    (Win95) power management
 0027h  VXDLDR       N  Y  Y    (Win4Wg 3.11/Win95) VXD Loader
 0028h  NDIS         N  Y  Y    (Win4Wg 3.11) Network Driver Interface Spec
 0029h  ???
 002Ah  VWIN32       ?  N  Y    (Win95)
 002Bh  VCOMM        N  Y  Y    (Win4Workgroups 3.11) DOS386 VCOMM Device
 002Ch  SPOOLER      ?  N  N    Windows95 print spooler
 002Dh  W32S         Y  N  Y    WIN32s 32-bit extension to Windows API
 002Eh  ???
 002Fh  ???
 0030h  MACH32       N  N  Y    ATI Mach32 video card
 0031h  NETBEUI      N  N  N    (Win4Workgroups 3.11) NETBEUI
 0032h  SERVER       N  Y  Y    (Win4Workgroups 3.11) Int21 File Server
 0032h  VSERVER      ?  N  Y    (Win95) Int21 File Server
 0033h  CONFIGMG     ?  Y  Y    (Win95)
 0033h  EDOS         ?  N  N    Windows DOS Box Enhancer by Mom's Software
 0034h  DWCFGMG.SYS  ?  Y  ?    DOS Plug-and-Play configuration manager
 0035h  SCSIPORT     ?  N  N    (Win95) virtualized access to SCSI adapter
 0036h  VFBACKUP     ?  Y  Y    (Win95)
 0037h  ENABLE       ?  Y  Y    (Win95)
 0038h  VCOND        ?  Y  Y    (Win95)
 0039h  ???
 003Ah  VPMTD        N  N  Y    (Win4Workgroups 3.11) IFAX Scheduler Device
 003Bh  DSVXD        ?  Y  N    DoubleSpace VxD from MS-DOS v6.x
 003Ch  ISAPNP       ?  N  N    (Win95)
 003Dh  BIOS         ?  Y  Y    (Win95)
 003Eh  WSOCK        ?  Y  Y    (Win95) WinSock
 003Fh  WSIPX        ?  N  N    (Win95) IPX WinSock
 0040h  IFSMGR       ?  N  N    (Win95)
 0041h  VCDFSD       ?  N  N    (Win95) CD-ROM File System Driver (MSCDEX)
 0042h  MRCI2        ?  N  N    (Win95) DriveSpace3
 0043h  PCI          ?  N  N    (Win95)
 0048h  PERF         ?  N  N    (Win95)
 004Ah  MTRR         ?  N  N    (Win95SR2) PPro/P-II MTRR enumerator???
 004Bh  NTKERN       ?  N  Y    (Win95SR2)
 0051h  ISAPNP       ?  N  N    (Win95) ISA Plug-and-Play manager
 008Dh  ESDI_506     ?  N  N    (Win95) MFM/RLL/ESDI disk driver
 0090h  voltrack     ?  N  N    (Win95) Volume Tracker
 00FDh  FAKEIDE      ?  N  N    (Chicago)
 0102h  CV1          ?  N  N    Microsoft C/C++ 7.00+ CodeView for Windows
 011Fh  VFLATD       ?  N  Y    (Win95)
 0200h  VIPX         ?  Y  Y    NetWare Virtual IPX Driver
 0200h  VTEMPD       ?  ?  ?    dummy template driver by Ray Patch
 0201h  VNWLSERV     ?  N  N    NetWare Lite 1.1 Server (SERVER.EXE)
 0202h  WINICE       ?  Y  Y    SoftICE/W
 0202h  SICE         ?  Y  Y
 0203h  VCLIENT      ?  N  Y    NetWare Lite 1.1+ Client
 0205h  VCAFT        ?  N  N    Novell Virtual CAFT Driver (LANalyzer for Win)
 0205h  BCW          ?  Y  Y    Nu-Mega Bounds Checker for Windows
 0206h  VTXRX        ?  N  N    Novell Virtual TXRX Driver (LANalyzer for Win)
 0207h  DPMS         N  Y  N    Novell DOS Protected Mode Services
 0234h  VCOMMUTE     ?  Y  Y    PC Tools Commute
 0442h  VTDAPI       ?  N  Y    MMSys Win386 VTAPI Device
 0443h  ???
 0444h  VADMAD       ?  ?  ?    Autoinitialize DMA (Windows 3.0)
 0445h  VSBD         ?  Y  Y    WinResKit: Sound Blaster Device
 0446h  VADLIBD      Y  Y  Y    MMSys Win386 AdLib Device (v3.x)
 0447h  ???
 0448h  SETULTRA     ?  ?  ?    Gravis UltraSound setup
 0449h  vjoyd        ?  N  Y    (Win95) joystick
 044Ah  mmdevldr     ?  Y  Y    (Win95)
 044Bh  ???
 044Ch  msmpu401     ?  N  N    (Win95) MPU-401 MIDI driver
 044Ch  cwdmidi      ?  Y  Y    (Crystal???) MIDI driver
 044Dh  msopl        ?  N  N    (Win95) OPL-3 (SoundBlaster FM) driver
 044Eh  mssblst      ?  N  N    (Win95) SoundBlaster MIDI driver
 045Dh  VflatD       ?  N  Y    dva.386, part of WIN32s
 045Eh  ???
 045Fh  mssndsys     ?  ?  ?    Microsoft Sound System audio driver
 045Fh  azt16        ?  Y  Y    Aztech Sound Galaxy 16 audio driver
 0460h  UNIMODEM     ?  N  Y    Universal Modem driver
 0480h  VNetSup      N  Y  Y    (Win4Workgrps 3.11) Virtual Network Support
 0481h  VRedir       N  N  N    (Win4Workgroups 3.11) Redirector File System
 0481h  VREDIR       ?  N  N    (Win95) Redirector File System driver
 0482h  VBrowse      ?  Y  Y    Win386 Virtual Browser
 0482h  SNAPVXD      ?  Y  Y    (Win95)
 0483h  VSHARE       ?  N  N    (Win4Workgroups) Virtual SHARE
 0483h  VSHARE       ?  Y  Y    (Win95) Virtual SHARE
 0484h  IFSMgr       Y  N  Y    (Win4Wg 3.11) Installable File System Manager
 0485h  ???                     ???
 0486h  VFAT         N  Y  Y    (Win4Workgroups 3.11) Win386 HPFS Driver
 0487h  NWLINK       ?  Y  Y    Win386 Virtual Packet Exchange Protocol
 0487h  NWSUP        Y  N  N    NetWare Vnetbios shim
 0488h  VTDI         ?  N  N    (Win95)
 0489h  VIP          ?  Y  N    (Win95)
 0489h  FTCVIP       ?  Y  Y    Frontier Technologies' VIP
 048Ah  VTCP         ?  Y  ?
 048Ah  MSTCP        ?  Y  N    (Win95) TCP stack
 048Ah  FTCTDI       ?  Y  Y    Future Technologies' TCP stack
 048Bh  VCache       N  Y  Y    (Win4Workgroups 3.11) Virtual File Cache
 048Bh  VCACHE       ?  Y  Y    (Win95) disk cache
 048Ch  ???                     ???
 048Dh  RASMAC       ?  Y  Y    enhanced mode Win4Workgroups RASMAC device
 048Eh  NWREDIR      ?  Y  Y    (Win95)
 048Fh  ???                     ???
 0490h  ???                     ???
 0491h  FILESEC      ?  ?  ?    (Win95) File Access Control Manager
 0492h  NWSERVER     ?  ?  ?    (Win95)
 0493h  SECPROV      ?  ?  ?    (Win95) Security Provider
 0494h  NSCL         ?  Y  Y    (Win95)
 0495h  AFVXD        ?  N  N    (Win95)
 0496h  NDIS2SUP     ?  ?  ?    (W4Wg???) NDIS2 networking support
 0497h  MSODISUP     ?  N  N    (W4Wg???)
 0498h  Splitter     ?  N  N    (Win95)
 0499h  PPPMAC       ?  Y  Y    (Win95)
 049Ah  VDHCP        ?  Y  Y    (Win95)
 049Bh  VNBT         ?  Y  Y    (Win95) NetBIOS-over-TCP/IP driver
 049Ch  ???
 049Dh  LOGGER       ?  ?  ?    (Win95)
 04A2h  IRLAMP       ?  ?  ?    IrDA Infrared Enumerator VxD
 097Ch  PCCARD       ?  N  Y    (Win95) (see INT 20/VxD=097Ch)
 1020h  VCV          ?  ?  ?    Microsoft C/C++ 7.00 CodeView
 1021h  VMB          ?  Y  Y    Microsoft C/C++ 7.00 WXSRVR
 1022h  Vpfd         ?  Y  Y    Microsoft C/C++ 7.00
 1025h  MMD          ?  Y  Y    Microsoft C/C++ 8.00, Visual C/C++ 1.00
 2020h  PIPE         ?  Y  Y    by Thomas W. Olson, in Windows/DOS DevJrn 5/92
 21EAh  VADLIBWD     ?  N  Y    Adlib Waveform Driver by John Ridges
 2200h  VFINTD       ?  Y  Y    Norton VFINTD (Norton Desktop)
 22C0h  ???          Y          Rational Systems DOS/4GW ???
 2402h  ZMAX         ?  N  N    Qualitas 386MAX v7 DOSMAX handler
 24A0h  VNSS         ?  N  Y    Norton Screen Saver (Norton Desktop)
 24A1h  VNDWD        ?  Y  Y    Norton VNDWD Device (Norton Desktop)
 24A2h  SYMEvent     ?  Y  Y    Norton Utilities v8
 2540h  VILD         ?  Y  N    INTERLNK client from MS-DOS v6.x
 2640h  VASBID       ?  N  Y    WinResKit: Artisoft Sounding Board Device
 2860h  COMMTASK     N  N  Y    Windows 386-mode preemptive tasker by James
                                  A. Kenemuth of Interabang Computing
 28A0h  PHARLAPX     ?  Y  ?    PharLap inter-VM communications DLL
 28A1h  PharLap      Y  Y  Y    PharLap 386|DOS-Extender DOSXNT.386
 28C0h  VXD          N  Y  Y    Generic VxD for real and protected mode by
                                  Andrew Schulman in MSJ February 1993
 28C1h  PUSHKEYS     ?  ?  ?    VKD_Force_Keys device
 28C2h  VCR3D        ?  ?  ?    Virtual CR3, by A.Schulman in MSJ October 1992
 2925h  EDOS         ?  Y  Y    Enhanced DOS by Firefly Software
 292Dh  VSBPD        ?  Y  Y    Sound Blaster Pro
 295Ah  GRVSULTR     ?  Y  Y    Gravis UltraSound / UltraSound ACE
 3048h  FTCTCPIP     ?  N  Y    Frontier Technologies' TCP/IP stack
 3049h  ???                     (called by FNFSC32.VXD, FrontierTech's VNFSD)
 304Ch  DWCFGMG.SYS  ?  Y       Plug-and-Play configuration access
 3098h  VstlthD      N  N  N    for QEMM Stealth ROM mode
 3099h  VVidramD     ?  Y  N    for QEMM VIDRAM support
 30F6h  WSVV         ?  N  Y    (Win95) WinSock for Voice-View Modems???
 310Eh  WPS          ?  N  Y    MS DevNet CD-ROM: Windows Process Status
 3110h  VGSSD        ?  Y  Y    VSGLX16.386 for Aztech Sound Galaxy 16
 313Bh  PMC          ?  ?  ?    Power Management Coordinator
 318Ah  LMOUSE       ?  Y  Y    (Win95) Logitech mouse???
 31CFh  STAT.386     ?  ?  ?    Ton Plooy's processor statistics VxD
 3202h  VdspD        ?  N  N    (Win95)
 3203h  vpasd        ?  N  N    (Win95) Pro Audio Spectrum driver
 32A4h  SBAWE        ?  Y  Y    (Win95) SoundBlaster AWE driver
 32A5h  VSB16        ?  N  N    (Win95) SoundBlaster 16 driver
 32CBh  VFRAD        ?  Y  Y    Dr.Franz - Simultan's diagnotics VFRAD.386
 32DCh  NV3RM        ?  N  Y    (Win95SR2)
 3354h  Discover     ?  N  Y    (Nuts&Bolts) Discover
 33AAh  DECCORE      ?  Y  Y    (Win95) DEC Pathworks core VxD
 33B4h  DECLICL      ?  N  N    (Win95)
 33F0h  VIWD         ?  Y  Y    Gravis UltraSound Plug-n-Play Interwave v1.x
 33FCh  ASPIENUM     ?  N  N    (Win95)
 34DCh  MAGNARAM     ?  N  Y    Quarterdeck MagnaRAM (MAGNA31.VXD/MAGNA95.VXD)
 357Eh  DSOUND       ?  Y  Y    (Win95) DirectSound
 3584h  VSNDSYS      ?  Y  Y    (Win95SR2)
 35C5h  LUGEPS       ?  Y  Y    Lugaru's Epsilon editor
 36AEh  AIB-PC.386   ?  Y  Y    Sunset Laboratory interface hardware driver
 377Bh  MX1501HAD    ?  ?  ?    Cherry keyboard chipcard reader
 38BEh  Vheapx       ?  N  Y    (Nuts&Bolts) Virtual Heap Expander
 38C0h  Bombshel     ?  N  Y    (Nuts&Bolts) Bombshelter
 38DAh  VIWD         ?  Y  Y    UltraSound PnP InterWave driver v2.0beta
 39E6h  A3D          ?  N  N    (Win95SR2)
 3A39h  CINEMSYS     ?  Y  Y    Software Cinemaster MPEG/DVD decoder
 3BFCh  CWCSPUD      ?  N  N    (Win95SR2)
 3BFDh  CWCPROXY     ?  N  N    (Win95SR2)
 3BFEh  CWCMMSYS     ?  N  Y    (Win95SR2)
 3BFFh  CWCDSND      ?  N  N    (Win95SR2)
 3C46h  X10MOUSE     ?  Y  Y    X10 RF wireless mouse
 3C78h  VGARTD       ?  N  N    (Win95SR2)
 3E6Dh  DDRAW        ?  Y  Y    DirectDraw
 3ED6h  ATIVVXXX     ?  N  Y    ATI Rage128-based video card
 3EE5h  WINTEL.VXD   ?  ?  ?    "WinTel" Windows remote-control program
                                (see also PORT 063Eh)
 4321h  POSTMSG      ?  Y  Y    (see #02712)
 4321h  VPCD         ?  N  N    PCache
 4321h  avvxp500     ?  N  N    (Win95) VxP500 driver
 6001h  REGVXD       ?  Y  Y    Windows95 Registry Monitor helper
 7A5Fh  SIWVID       Y  Y  Y    Soft-ICE for Windows video driver
 7FE0h  VSWITCHD     ?  Y  N    by Jeff Prosise
 7FE0h  VWFD         N  Y  Y    reports windowed/fullscreen state; by Neil
                                  Sandlin of Microsoft, shipped with ANSIPLUS
 7FE1h  VWATCHD      N  Y  Y    basic driver w/ no functionality except tracing
                                  by Keith Jin of Microsoft PSS
 7FE5h  VFINTD       N  Y  Y    Virtual Floppy Interrupt trapper by Neil
                                  Sandlin of Microsoft
 7FE7h  VMPAGES      N  Y  Y    demonstration of exporting VxD services, by
                                  Neil Sandlin of Microsoft
 7FE8h  VPOSTD       ?  Y  Y    PostMessage() demo by Curtis J. Palmer of MS
 7FE9h  VIdleD       N  N  N    demonstration of Call_When_Idle function, by
                                  Bernie McIlroy of Microsoft
 7FEBh  VMIOD        N  N  N    Virtual Monitor I/O Traffic Device, by Neil
                                  Sandlin of Microsoft
 7FEDh  VMIRQD       N  N  N    Virtual Monitor IRQ Traffic Device, by Neil
                                  Sandlin of Microsoft
 8888h  VbillD       ?  ?  ?    Bill Potvin II's for reversing Compaq LTE video
 EEEEh  VEPSD        ?  N  N    Virtual Extended Paging Services for
                                  Borland C++ v4.0
Notes:  The high bit of the VxD ID is reserved for future use. Originally,
          the next 10 bits were the OEM number which was assigned by Microsoft,
          and the low 5 bits were the device number.  Currently, Microsoft
          assigns VxD IDs individually for each driver; send blank email to
          vxdid@microsoft.com for more information.
        "CallOut"=Y indicates that the VxD uses the INT 2F/AX=1607h/BX=VxDID
          device callout interface; "PM" and "V86" indicate whether the VxD
          provides an API entry point in protected mode and Virtual-86 mode
          (e.g. DOS boxes)
--------W-2F1684BX0001-----------------------
INT 2F - MS Windows95 - VMM - GET API ENTRY POINT
        AX = 1684h
        BX = 0001h (virtual device ID for VMM) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02643)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02643)
Call Windows VMM 16-bit entry point with:
        AX = function number
            ---registry functions---
            0100h "RegOpenKey"
                STACK:  DWORD   -> DWORD for returned key handle
                        DWORD   -> ASCIZ registry key name
                        DWORD   HKEY (see #02644)
            0101h "RegCreateKey"
                STACK:  DWORD   -> DWORD for returned key handle
                        DWORD   -> ASCIZ registry key name
                        DWORD   HKEY (see #02644)
            0102h "RegCloseKey"
                STACK:  DWORD   key handle from RegOpenKey or RegCreateKey
            0103h "RegDeleteKey"
                STACK:  DWORD   -> ASCIZ registry key name
                        DWORD   HKEY (see #02644)
            0104h "RegSetValue"
                STACK:  DWORD   ???
                        DWORD   -> ???
                        DWORD   ???
                        DWORD   -> ???
                        DWORD   HKEY (see #02644)
            0105h "RegQueryValue"
                STACK:  DWORD   -> DWORD for ???
                        DWORD   -> ASCIZ ???
                        DWORD   -> ASCIZ ???
                        DWORD   HKEY (see #02644)
            0106h "RegEnumKey"
                STACK:  DWORD   ???
                        DWORD   -> ASCIZ ???
                        DWORD   ???
                        DWORD   HKEY (see #02644)
            0107h "RegDeleteValue"
            0108h "RegEnumValue"
                STACK:  DWORD   -> DWORD for ???
                        DWORD   -> BYTE ???
                        DWORD   -> DWORD for ???
                        DWORD   -> DWORD for ???
                        DWORD   -> DWORD for ???
                        DWORD   -> ASCIZ ???
                        DWORD   ???
                        DWORD   HKEY (see #02644)
            0109h "RegQueryValueEx"
            010Ah "RegSetValueEx"
            010Bh "RegFlushKey"
            010Ch "RegLoadKey"
            010Dh "RegUnLoadKey"
            010Eh "RegSaveKey"
            010Fh "RegRestore"
            0110h "RegRemapPreDefKey"
Return: parameters popped from stack
        DX:AX = return value

(Table 02644)
Values for Windows95 VMM predefined HKEY values:
 80000000h      HKEY_CLASSES_ROOT
 80000001h      HKEY_CURRENT_USER
 80000002h      HKEY_LOCAL_MACHINE
 80000003h      HKEY_USERS
 80000004h      HKEY_PERFORMANCE_DATA
 80000005h      HKEY_CURRENT_CONFIG
 80000006h      HKEY_DYN_DATA
SeeAlso: #02643
--------W-2F1684BX0003-----------------------
INT 2F - MS Windows - VPICD - GET API ENTRY POINT
        AX = 1684h
        BX = 0003h (virtual device ID for VPICD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02645)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02645)
Call VPICD API entry point with:
        EAX = function number
            0000h get version
                Return: AX = binary version (AH=major, AL=minor)
            0001h virtualize timer???
            0002h unvirtualize timer???
--------W-2F1684BX0005-----------------------
INT 2F - MS Windows - VTD - GET API ENTRY POINT
        AX = 1684h
        BX = 0005h (virtual device ID for VTD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02646)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02646)
Call VTD.386/VTD.VXD entry point with:
        AX = function number
            0000h get VTD version number
                Return: CF clear
                        AH = major version
                        AL = minor version
            0100h get current clock tick time
                Return: EDX:EAX = clock tick time in 840ns units since Windows
                                  was started
            0101h get current system time in milliseconds
                Return: EAX = time in milliseconds that Windows has been
                                  running
            0102h get current virtual machine time
                Return: EAX = cumulative amount of time the virtual machine has
                                  been active, in milliseconds
Note:   this entry point should only be called directly when TOOLHELP.DLL
          TimerCount() cannot be called
SeeAlso: #01268,#01270,#01269 at INT 20"Windows"
--------W-2F1684BX0006-----------------------
INT 2F P - MS Windows95 - V86MMGR - GET API ENTRY POINT
        AX = 1684h
        BX = 0006h (virtual device ID for V86MMGR device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02647)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02647)
Call V86MMGR entry point with:
        EAX = function number
            0000h get V86MMGR version
                Return: CF clear
                        AH = major version
                        AL = minor version
            0001h get ???
                Return: CF clear
                        EAX = status bits
                                bit 0: ???
                                bit 1: ???
                                bit 2: ???
                                bit 3: ???
                                bit 4: ???
            else
                Return: CF set
--------W-2F1684BX0009-----------------------
INT 2F P - MS Windows - REBOOT - GET API ENTRY POINT
        AX = 1684h
        BX = 0009h (virtual device ID for REBOOT device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02648)
                  0000h:0000h if the VxD does not support an API
SeeAlso: INT 14/AH=17h"FOSSIL",INT 16/AX=E0FFh

(Table 02648)
Call REBOOT protected-mode entry point with:
        AX = function
            0100h warm boot
                Return: never
                Note:   broadcasts "Reboot_Processor" message, which is caught
                          by the VKD device
            0201h set KERNEL Ctrl-Alt-Del handler
                ES:DI -> new Ctrl-Alt-Del handler
                DS:SI -> KERNEL reboot sanity check byte
                Return: CF clear
                Notes:  if an application installs its own handler and then
                          chains to Windows' handler, Windows will no longer
                          be able to detect hung applications, and will always
                          produce an "Application not responding" dialog
                        DS must contain a writable, fixed selector because
                          the provided address is converted to a linear address
                          before being stored
                        when Ctrl-Alt-Del is pressed in the system VM, Reboot
                          sets the sanity check byte to zero, schedules a
                          750ms wait, and then tests whether the check byte is
                          still zero; if not, it displays a message that there
                          is no hung application and then exits
            0202h get KERNEL Ctrl-Alt-Del handler
                Return: CF clear
                        ES:DI -> current Ctrl-Alt-Del handler
                Note:   the default handler is located in KERNEL
            0203h display "Application not responding" dialog box
                ES:DI -> ASCIZ name of hung application
                Return: never if user pressed Ctrl-Alt-Del a second time
                        CF clear
                        AX = result
                            0000h user pressed Esc
                            0001h user pressed Enter
                Note:   this function is used by the default Windows
                          Ctrl-Alt-Del handler
            0204h set/reset protected-mode INT 01 handler
                CX:EDX -> new protected-mode INT 01 handler
                CX = 0000h restore protected-mode INT 01 handler
                Return: CF clear
                Notes:  if CX is nonzero, the current handler address is saved
                          internally before the new handler is set; this saved
                          address is then used when CX is zero on entry
                        used by Windows' default Ctrl-Alt-Del handler; actual
                          fatal exit to DOS will be done on next INT 01
                Warning: opened files are not closed and remain open as
                          orphaned files in DOS
Note:   functions 0201h and 0203h are not useful outside the system VM
SeeAlso: #01271,#01273
--------W-2F1684BX000A-----------------------
INT 2F P - MS Windows - VDD - GET API ENTRY POINT
        AX = 1684h
        BX = 000Ah (virtual device ID for VDD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02649)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02649)
Call VDD entry point with:
        EAX = function
            0000h get VDD version
                Return: CF clear
                        AH = major version
                        AL = minor version
                Note:   also performs an internal initialization
            0001h ???
                Return: ECX = ???
                        ???
            0002h
            0003h
            0004h
            0005h
            0006h
            0007h
            0008h
            0009h
            0080h
            0081h
            0082h
            0083h
            0084h
            0085h
            0086h
            0087h
            0088h
            0089h
            else
                Return: nothing
--------W-2F1684BX000C-----------------------
INT 2F - MS Windows - VMD - GET API ENTRY POINT
        AX = 1684h
        BX = 000Ch (virtual device ID for VMD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02650)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02650)
Call VMOUSE entry point with:
        EAX = function number
            0000h get VMOUSE version
                Return: CF clear
                        AH = major version
                        AL = minor version
            0001h
                EBX = ???
                ECX = ???
                Return: CF clear if successful
                        CF set on error (e.g. fn 0003h not yet called)
            0002h ??? (calls "test system VM handle")
                Return: CF clear if successful (in system VM)
                        CF set on error
            0003h ???
                ECX = ???
                DX = ???
                Return: CF clear
            0004h ???
                Note: invokes Call_Priority_VM_Event
            0005h get mouse port data
                Return: CF clear
                        AL = ??? (04h)
                        AH = mouse IRQ interrupt number (IRQ4=0Ch,etc.)
                        CX = mouse I/O port address (e.g. 03F8h)
                        DX = COM port number??? (0001h for mouse on COM1)
            0100h NOP???
                Return: CF clear
            0101h init???
                Return: CF clear
                Note:   appears to be the same as fn 0005h, but returns no data
            0102h unimplemented
                Return: CF set
            0103h check ???
                Return: AX = status (0000h/0001h)
                Note:   checks flag set by fn 0003h
            else
                Return: CF set
SeeAlso: #02649,#02651
--------W-2F1684BX000D-----------------------
INT 2F P - MS Windows - VKD - GET API ENTRY POINT
        AX = 1684h
        BX = 000Dh (virtual device ID for VKD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02651)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02651)
Call VKD entry point with:
        EAX = function
            0000h get VKD version
                Return: CF clear
                        AH = major version
                        AL = minor version
            0001h ???
                EBX = VM handle or 00000000h to use ??? VM handle
                CH = ???
                CL = ???
                EDX = ??? or FFFFFFFFh
                Return: CF clear if successful
                        CF set on error
            else
                Return: CF set
SeeAlso: #02650,#02652
--------W-2F1684BX000E-----------------------
INT 2F P - MS Windows - VCD - GET API ENTRY POINT
        AX = 1684h
        BX = 000Eh (virtual device ID for VCD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02652)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02652)
Call VCD entry point with:
        EDX = function number
            0000h get VCD version
                Return: CF clear
                        AH = major version
                        AL = minor version
            0001h get ???
                Return: CF clear
                        AX = bit mask of ???
            0002h get ???
                CX = COM port number
                Return: CF clear
                        DX:AX -> ???
            0003h set ???
                CX = COM port number
                DX:AX -> new ???
                Return: CF clear
            0004h acquire COM port
                AX = ???
                CX = COM port number
                Return: CF clear
                        AX = ???
                        EBX = ???
                        DX = ???
            0005h release COM port
                CX = COM port number
                Return: CF clear
            0006h ???
                Return: CF set
                        AL = 00h
            else
                Return: CF set
                        EAX = FFFFFFFFh
Note:   these functions are apparently only available from the system VM,
          returning CF set and EAX=FFFFFFFFh otherwise
SeeAlso: #02651,#02653
--------W-2F1684BX000F-----------------------
INT 2F P - MS Windows - VPD - GET API ENTRY POINT
        AX = 1684h
        BX = 000Fh (virtual device ID for VPD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02653)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02653)
Call VPD entry point with:
        EDX = function number
            0000h get VPD version
                Return: CF clear
                        AH = major version
                        AL = minor version
                        DX = ??? (CB01h)
            0001h get valid??? printers
                Return: CF clear
                        AX = bitmask of ??? printers (bits 0-2)
            0002h get ??? for printer
                CX = printer port (0-2)
                Return: CF clear if successful
                            BX:AX = ???
                        CF set on error (invalid port number)
            0003h set ??? for printer
                CX = printer port (0-2)
                BX:AX = ???
                Return: CF clear if successful
                        CF set on error (invalid port number)
            0004h ???
                CX = printer port (0-2)
                EAX = VM handle
                Return: CF clear if successful
                        CF set on error (invalid port number)
            0005h ???
                CX = printer port (0-2)
                EAX = VM handle
                Return: CF clear if successful
                        CF set on error (invalid port number or ???)
            0006h-000Eh unused
                Return: CF set
            000Fh ???
                CX = printer port (0-2)
                AX = ???
                Return: CF clear if successful
                        CF set on error (e.g. invalid port number)
            0010h ???
                CX = printer port (0-2)
                Return: CF clear if successful
                        CF set on error (e.g. invalid port number)
            0011h ???
                CX = printer port (0-2)
                Return: CF clear if successful
                        CF set on error (e.g. invalid port number)
            0012h get port status
                CX = printer port (0-2)
                Return: CF clear if successful
                            AX = port status (see #P0658 at PORT 03BCh"LPT")
                        CF set on error (e.g. invalid port number)
            else
                Return: CF set
Note:   these functions are apparently only available from the system VM,
          returning CF set
SeeAlso: #02652,#02654
--------W-2F1684BX0010-----------------------
INT 2F - MS Windows - IOS - GET API ENTRY POINT
        AX = 1684h
        BX = 0010h (virtual device ID for IOS device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02654)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02654)
Call IOS entry point with:
        EAX = function number
            0000h ???
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = FFFFh
            0001h check if ???
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = FFFFh
            0002h requestor services???
                DL = service number???
                Return: CF clear if successful
                            AX = 0000h
                            DX = ???
                        CF set on error
                            AX = FFFFh
                Note:   calls "IOS_Requestor_Service" (see INT 20"Windows")
            0003h ??? (copies five bytes of data internally)
                Return: CF clear if successful
                            AX = 0000h
                            EDX = ???
                        CF set on error
                            AX = FFFFh
            else
                Return: CF set
                        AX = FFFFh
SeeAlso: #02653,#02655
--------W-2F1684BX0011-----------------------
INT 2F - MS Windows - VMCPD - GET API ENTRY POINT
        AX = 1684h
        BX = 0011h (virtual device ID for VMCPD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02655)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02655)
Call Windows95 VMCPD protected-mode entry point with:
        EAX = function number
            0000h get VMCPD version
                Return: CF clear
                        AH = major version
                        AL = minor version
            0001h get ??? flags
                Return: CF clear
                        AX = ??? flags
                            bit 0: ???
                            bit 1: ???
                            bit 2: ???
                            bit 3: ???
            else
                Return: CF set
SeeAlso: #02654,#02656
--------W-2F1684BX0015-----------------------
INT 2F - MS Windows - DOSMGR - GET API ENTRY POINT
        AX = 1684h
        BX = 0015h (virtual device ID for DOSMGR device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02656,#01282)
                  0000h:0000h if the VxD does not support an API
SeeAlso: #01282 at INT 20"Windows"

(Table 02656)
Call DOSMGR entry point with:
        AX = 0000h get DOSMGR version
            Return: CF clear
                    AX = version (AH = major, AL = minor)
        AX = 0001h set critical focus
            Return: CF clear
        AX = 0002h crash current virtual machine
            Return: never
            Note:   displays message box stating that "application has been
                      stopped by the DOSMGR device"
        AX = 0003h enter critical section
            Note:   this function assumes that the code for INT 2A/AX=8001h
                      and INT 2A/AX=8002h have been modified for Windows
        AX = 0004h get VM ID byte
            Return: CF clear if successful
                        ES:DI -> VM ID byte
                    CF set on error
            Note:   this function fails if the INT 2A modifications have not
                      yet been applied
        AX = 0005h inform Windows of possible media change
            BL = drive number (00h=A:)
            Return: CF clear if successful
                    CF set on error
SeeAlso: #01282 at INT 20"Windows",#02655,#02657
--------W-2F1684BX0017-----------------------
INT 2F U - MS Windows - SHELL - GET API ENTRY POINT
        AX = 1684h
        BX = 0017h (virtual device ID for SHELL device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02657)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h/BX=0021h,#01283 at INT 20"Windows"

(Table 02657)
Call SHELL entry point with:
        EDX = function number (0000h-0027h,0100h-0108h, mostly unknown)
            0000h get version number
                Return: AX = version number
                        EBX = system VM handle
            0001h "SHELL_Get_SYSVM_Info" get system VM information
                Return: CF clear
                        AX bit 0 set if system VM executing exclusively
                        BX = background time slice priority
                        CX = foreground time slice priority
                        SI = minimum time slice in milliseconds
            0002h "SHELL_Set_SYSVM_Info" set system VM information
                AX bit 0 set if system VM should execute exclusively (ignored?)
                BX = background time slice priority (1-10000)
                CX = foreground time slice priority (1-10000)
                SI = minimum time slice in milliseconds (1-10000)
                Return: CF clear if successful
            0003h "SHELL_Crt_VM" create a virtual machine
                ES:EDI -> SEB structure (see #02658)
                Return: CF clear if successful
                           EAX = VM handle
                        CF set on error
                           EDX,EAX = result from GetSetDetailedVMError()
            0004h "SHELL_Destroy_VM" destroy a virtual machine
                EBX = VM handle (not system VM)
                Return: nothing
            0005h "SHELL_Set_Focus"
                EBX = VM handle
                ECX = ???
                Return: nothing
            0006h "SHELL_Get_VM_State"
                EBX = VM handle (not system VM)
                ES:EDI -> ??? structure
                Return: CF clear if successful
            0007h "SHELL_Set_VM_State"
                EBX = VM handle (not system VM)
                ES:EDI -> ??? structure
            0008h "SHELL_Debug_Out"
                ???
                Return: ???
                Note:   dummy function in retail version of MS Windows
            0009h "SHELL_VMDA_Init"
                ???
                Return: ???
            000Ah "SHELL_VMDA_Exit"
                ???
                Return: ???
            000Bh "SHELL_Get_Message_Txt"
                ???
                Return: ???
            000Ch "SHELL_Event_Complete"
                ???
                Return: ???
            000Dh "SHELL_Get_Contention_Info"
                ???
                Return: ???
            000Eh "SHELL_Get_Clip_Info"
                ???
                Return: ???
            000Fh "SHELL_Set_Paste"
                ???
                Return: ???
            0010h "SHELL_Switcher_Assist"
                ???
                Return: ???
            0011h "SHELL_Get_FileSysChng"
                ???
                Return: ???
            0012h "SHELL_Query_Destroy"
                ???
                Return: ???
            0013h "SHELL_SetFocus_Cur_VM" set input focus to current VM
                ???
                Return: ???
            0014h "SHELL_User_Busy_API"
                ???
                Return: ???
            0015h "SHELL_Chng_Hot_Key"
                ???
                Return: ???
            0016h "SHELL_Get_TermInfo"
                ???
                Return: ???
            ---Windows95---
            0017h ???
            0018h ???
            0019h ???
            001Ah ???
            001Bh ???
            001Ch ???
            001Dh ???
            001Eh ???
            001Fh ???
            0020h ???
            0021h ???
            0022h ???
            0023h ???
            0024h ???
            0025h ???
            0026h ???
                Note:   makes VxDCALL 00178002h (see INT 20"Windows")
            0027h ???
            0100h get ??? version
                Return: AX = version??? (0400h for Windows95)
            0101h not implemented
                Return: CF set
                        EAX = FFFFFFFFh
            0102h not implemented
                Return: CF set
                        EAX = FFFFFFFFh
            0103h not implemented
                Return: CF set
                        EAX = FFFFFFFFh
            0104h ???
            0105h ???
            0106h ???
                ???
                Return: CF clear if successful
                        CF set on error
            0107h get SDK version for VxD
                AX = VxD identifier
                Return: EAX = VxD ID (high word) and SDK version (low)
                            00000000h if no such VxD loaded
                Note:   makes a VMMCALL 0001013Fh (see INT 20"Windows")
                          followed by ???
            0108h ???
Return: CF set if called from VM other than system VM
            EAX = FFFFFFFFh
Note:   except for functions 0013h,0026h,and 010xh, this API may only be
          called from the system VM
SeeAlso: #01283 at INT 20"Windows"

Format of Shell Execution Block (SEB):
Offset  Size    Description     (Table 02658)
 00h    DWORD   PIF flags (see #02659)
 04h    DWORD   display flags (see #02660)
 08h    PWORD   -> pathname of .EXE to run
 0Eh    PWORD   -> argument list
 14h    PWORD   -> working drive/directory
 1Ah    WORD    desired number of V86 pages for virtual machine
 1Ch    WORD    minimum number of V86 pages for VM
 1Eh    WORD    foreground priority
 20h    WORD    background priority
 22h    WORD    maximum KB of EMS
 24h    WORD    minimum KB of EMS
 26h    WORD    maximum KB of XMS
 28h    WORD    minimum KB of XMS
 2Ah    WORD    maximum KB of DPMI???
 2Ch    WORD    minimum KB of DPMI???
 2Eh 128 BYTEs  title
Note:   the PWORDs at offsets 08h,0Eh, and 14h consist of a DWORD offset
          followed by a WORD selector

Bitfields for 386 Enhanced Mode PIF flags:
Bit(s)  Description     (Table 02659)
 0      exclusive use of processor when VM is fullscreen
 1      VM runs in background
 2      VM runs in window
 3-4    ???
 5      Alt-Tab reserved
 6      Alt-Esc reserved
 7      Alt-Space reserved
 8      Alt-Enter reserved
 9      Alt-PrtSc reserved
 10     PrtSc reserved
 11     Ctrl-Esc reserved
 12     VM will release idle time slice
 13     VM not allowed to use high memory
 14     ???
 15     VM expanded memory not pageable
 16     VM extended memory not pageable
 17     Fast paste from clipboard enabled
 18     VM application memory not pageable
 30     Close VM when application exits
SeeAlso: #02658,#02660

Bitfields for SHELL display options:
Bit(s)  Description     (Table 02660)
 0      emulate text mode
 1      monitor text port
 2      monitor low graphics port
 3      monitor high graphics port
 7      Retain video memory
SeeAlso: #02658,#02659
--------W-2F1684BX001A-----------------------
INT 2F - MS Windows - VNETWARE - GET API ENTRY POINT
        AX = 1684h
        BX = 001Ah (virtual device ID for VNETWARE device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX001D-----------------------
INT 2F P - MS Windows - WINDEBUG - GET API ENTRY POINT
        AX = 1684h
        BX = 001Dh (virtual device ID for WINDEBUG device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0021-----------------------
INT 2F PU - MS Windows - PAGEFILE - GET API ENTRY POINT
        AX = 1684h
        BX = 0021h (virtual device ID for PAGEFILE device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02661)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h/BX=0017h,#01289 at INT 20"Windows"

(Table 02661)
Call PAGEFILE entry point with:
        AX = function
            0000h get version
                Return: CF clear
                        AX = version (AH = major, AL = minor)
            0001h get swap file info
                DS:SI -> 128-byte buffer for swap file full pathname
                DS:DI -> 128-byte buffer for SPART.PAR full pathname
                Return: CF clear
                        AL = pager type (see #02662)
                        AH = flags
                            bit 7: swap file corrupted
                        ECX = maximum size of swap file
                        DS:SI buffer filled if paging enabled
                        DS:DI buffer filled if permanent swap file
            0002h delete permanent swap file on exit
                Return: CF clear
            0003h get current temporary swap file size
                Return: CF clear
                        DX:AX = current swap file size in bytes
                                0000h:0000h if permanent swap file
Note:   this API is only available in protected mode, and may only be called
          from the system VM
SeeAlso: #01289 at INT 20"Windows",#02663

(Table 02662)
Values for MS Windows PAGEFILE pager type:
 00h    paging disabled
 01h    MSDOS
 02h    BIOS
 03h    32-bit disk access
SeeAlso: #02661
--------W-2F1684BX0022-----------------------
INT 2F P - MS Windows - APIX - GET API ENTRY POINT
        AX = 1684h
        BX = 0022h (virtual device ID for APIX device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02663)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02663)
Call APIX protected-mode entry point with:
        AH = function number
            00h get APIX version
                Return: CF clear
                        AH = major version
                        AL = minor version
            01h ???
                Return: CF clear
                        AX = number of ???
            02h NOP
                Return: CF clear
            03h ???
                Return: CF clear
                        AX = 0000h/FFFFh
            else
                Return: CF clear (bug?)
SeeAlso: #02661,#02666
--------W-2F1684BX0026-----------------------
INT 2F P - MS Windows - VPOWERD - GET API ENTRY POINT
        AX = 1684h
        BX = 0026h (virtual device ID for VPOWERD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02664)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02664)
Call VPOWERD.VXD entry point with:
        AX = function number
            0000h get VPOWERD version
                Return: DX = 0000h
                        AX = version (AH = major, AL = minor)
            0001h get APM BIOS version
                Return: DX:AX = APM BIOS version
            0002h get current power management level
                Return: DX:AX = power management level
            0003h enable/disable power management (see INT 15/AX=5308h)
                ??? = new state of power management
                Return: DX:AX = 0000h:0000h if successful
                           else error code (see #02665)
            0004h set power state (see INT 15/AX=5307h)
                Return: DX:AX = 0000h:0000h if successful
                           else error code (see #02665)
            0005h set system power status
                Return: DX:AX = 0000h:0000h if successful
                           else error code (see #02665)
            0006h restore APM power-on defaults (see INT 15/AX=5309h)
                Return: DX:AX = 0000h:0000h if successful
                           else error code (see #02665)
            0007h get power status (see INT 15/AX=530Ah)
                Return: ???
            0008h get APM 1.1 power state (see INT 15/AX=530Ch)
                Return: ???
            0009h invoke OEM APM function
                ??? -> buffer containing parameters for INT 15/AX=5380h
                Return: DX:AX = 0000h:0000h or error code (see #02665)
                        buffer updated if successful
            000Ah register power handler
                ???
                Return: DX:AX = 0000h:0000h or error code
            000Bh deregister power handler
                ???
                Return: DX:AX = 0000h:0000h or error code (see #02665)
            000Ch Win32 get system power status
            000Dh Win32 set system power status
            else
                Return: DX = 0000h
                        AX = 00FFh
SeeAlso: #02663,#02666

(Table 02665)
Values for VPOWERD.VXD error code:
 000000xxh      APM error code
 000000FFh      function number out of range
 80000001h      ??? (service 05h)
 80000002h      ??? (service 0Dh)
 80000003h      specified NULL buffer pointer (service 07h,08h,09h)
 80000005h      ??? (service 03h)
 80000006h      ??? (service 04h)
 80000007h      ??? (service 05h)
 80000008h      ??? (service 05h)
 80000009h      out of memory (service 0Ah)
 8000000Ah      ??? (service 0Ah)
 8000000Bh      invalid power handler (service 0Bh)
 8000000Ch      unsupported/disabled??? function
SeeAlso: #02664,#01290
--------W-2F1684BX0027-----------------------
INT 2F - MS Windows95 - VXDLDR - GET API ENTRY POINT
        AX = 1684h
        BX = 0027h (virtual device ID for VXDLDR device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02666)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02666)
Call VXDLDR entry point with:
        EAX = function number
            0000h get VXDLDR version
                Return: CF clear
                        AX = 0000h (successful)
                        DH = major version
                        DL = minor version
            0001h load device
                DS(???):DX -> ASCIZ path name of dynamically-loadable VxD
                        (driver must reside in current directory or Windows
                          system directory???)
                ES:DI = 0000h:0000h
                Return: CF clear if successful
                            AX = 0000h
                            ES:DI -> VxD API entry point
                        CF set on error
                            AX = error code (see #02667)
            0002h unload device
                EBX = device ID or FFFFFFFFh (Undefined_Device_ID)
                ---if EBX=FFFFFFFFh ---
                (DS???):DX -> ASCIZ name of dynamically-loadable device
                          (case-sensitive)
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = error code (see #02667)
            else
                Return: CF set
                        AX = 000Bh
SeeAlso: #02664,#02668

(Table 02667)
Values for VXDLDR error code:
 0000h  successful
 000Bh  invalid function number
SeeAlso: #02666
--------W-2F1684BX0028-----------------------
INT 2F - MS Windows - NDIS - GET API ENTRY POINT
        AX = 1684h
        BX = 0028h (virtual device ID for NDIS device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02668)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02668)
Call NDIS.VXD entry point with:
        ??? = function number
            0000h set ??? to ???
                ??? = new ???
                Return: DX:AX = 0000h:0001h
            0002h ???
                ???
                Return: DX:AX -> ???
            0003h reset ??? to default
                Return: DX:AX = 0000h:0001h
            else
                Return: DX:AX = 0000h:0000h
SeeAlso: #02666,#02669
--------W-2F1684BX002A-----------------------
INT 2F P - MS Windows - VWIN32 - GET API ENTRY POINT
        AX = 1684h
        BX = 002Ah (virtual device ID for VWIN32 device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02669)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02669)
Call VWIN32.VXD entry point with:
        AH = function number
            00h get VWIN32 version and ???
                Return: CF clear
                        AH = major version
                        AL = minor version
                        EDX = ???
            01h ???
                EBX = ???
                ECX = ???
                Return: CF clear
                        EAX = ???
            02h ???
                Return: CF clear
                        AX = ??? or 0000h
            03h address allocation
                DS:??? -> buffer containing/for page data
                ECX = length of buffer
                AL = subfunction
                    00h reserve page(s)
                    01h commit page(s)
                    02h decommit page(s)
                    03h free page(s)
                Return: CF clear if successful
                        CF set on error
                Note:   this function uses ECX bytes of stack
            04h get ???
                Return: CF clear
                        EAX = ???
            05h ???
                EBX = ???
                Return: CF clear
                        EAX = ???
            06h ???
                EBX = ???
                Return: CF clear
                        EAX = ???
            07h ???
                EBX = ???
                Return: CF clear
                        EAX = ???
            08h get ???
                Return: CF clear
                        AX = ???
            09h ???
                EBX = ???
                ECX = ???
                Return: CF clear
            0Ah ???
                EBX = ???
                Return: CF clear
            0Bh ???
                EBX = ???
                Return: CF clear
            0Ch ???
                EBX = ???
                ECX = ???
                EDX = ???
                ???
                Return: CF clear if successful
                            EAX = ???
                        CF set on error
            0Dh clear ???
                Return: CF clear
            0Eh ???
                EBX = ???
                ECX = ???
                Return: CF clear
            0Fh ???
                EBX = ???
                ECX = ???
                Return: CF clear
            10h ???
                Return: CF clear
                Note:   invokes VMMcall 00010184h
            11h ???
                Return: CF clear
                Note:   invokes VMMcall 00010160h
            12h ???
                ???
            13h pop up system error dialogue
                Return: CF clear
                        AX = ??? or 0000h
            14h "IFSMgr_GetConversionTablePtrs"
                Return: CF clear
                        DX:AX -> ???
                Note:   invokes VxDcall 00400051h
            15h "Boost_With_Decay"
                EBX = ???
                ECX = ???
                EDX = ???
                Return: CF clear
            else
                Return: CF set
SeeAlso: #02668,#02670
--------W-2F1684BX002B-----------------------
INT 2F - MS Windows - VCOMM - GET API ENTRY POINT
        AX = 1684h
        BX = 002Bh (virtual device ID for VCOMM device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02670)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02670)
Call VCOMM.VXD entry point with:
        AX = function number
            0000h open COM/LPT port
                BX = port number (00h-7Fh = COMx, 80h-FFh = LPTx)
                Return: DX:AX = handle???
            0001h set comm state
                ???
                Return: AX = ???
            0002h setup comm port
                ???
                Return: AX = status (0000h failed, FFFFh success)
            0003h transmit character
                EBX = handle???
                CL = character to transmit
                Return: AX = status???
            0004h close comm port
                EBX = handle???
                Return: ???
            0005h clear comm error
                EBX = handle???
                EAX = ???
                Return: AX = status???
            0006h "EscapeCommFunction"
                EBX = handle???
                CX = ???
                EAX = ???
                Return: DX:AX = ???
            0007h purge buffers
                EBX = handle???
                CX = ???
                Return: AX = status???
            0008h set comm event mask
                EBX = handle???
                CX = new event mask
                Return: AX = status???
            0009h get comm event mask
                EBX = handle???
                Return: AX = current event mask
            000Ah ???
                EBX = handle???
                Return: ???
            000Bh "WriteComm"
                EBX = handle???
                CX = number of characters to write
                ES???:BX -> buffer (if CX > 1)
                SI??? low byte contains character if CX=1
                Return: AX = status
                        EAX high word may be destroyed
            000Ch "ReadComm"
                EBX = handle???
                CX = number of bytes to read
                ES???:DI -> buffer
                Return: AX = status ???
                        ZF = ???
            000Dh set ??? callback
                EBX = handle???
                CX = ???
                DX = ???
                Return: AX = status???
            else
                Return: AX = 0000h
SeeAlso: #02669,#02671
--------W-2F1684BX002D-----------------------
INT 2F P - MS Windows - W32S - GET API ENTRY POINT
        AX = 1684h
        BX = 002Dh (virtual device ID for W32S device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0030-----------------------
INT 2F P - MS Windows - MACH32 - GET API ENTRY POINT
        AX = 1684h
        BX = 0030h (virtual device ID for MACH32 device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0032-----------------------
INT 2F - MS Windows - SERVER / VSERVER - GET API ENTRY POINT
        AX = 1684h
        BX = 0032h (virtual device ID for SERVER device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02671)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",#01296 at INT 20"Windows"

(Table 02671)
Call Windows95 VSERVER.VXD protected-mode entry point with:
        AX = function number
            0003h NOP
                Return: AX = 0000h
            0004h NOP
                Return: AX = 0000h
            0007h NOP
                Return: AX = 0000h
            0008h NOP
                Return: nothing
            000Fh ???
                Return: AX = status
                            0000h successful
                            0842h on error
            0010h ???
                Return: AX = status
                            0000h successful
                            0842h on error
            else
                Return: AX = 0032h
SeeAlso: #02670,#02672
--------W-2F1684BX0033-----------------------
INT 2F - MS Windows - CONFIGMG - GET API ENTRY POINT
        AX = 1684h
        BX = 0033h (virtual device ID for CONFIGMG device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02672)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02672)
Call CONFIGMG.VXD entry point with:
        AX = function number
            0000h get CONFIGMG version
                Return: CF clear
                        AH = major version
                        AL = minor version
            ...
            005Ah
            else
                Return: CF set
                        AX = 0020h
SeeAlso: #01297 at INT 20"Windows",#02671,#02673
--------W-2F1684BX0036-----------------------
INT 2F - MS Windows - VFBACKUP - GET API ENTRY POINT
        AX = 1684h
        BX = 0036h (virtual device ID for VFBACKUP device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02676)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02676)
Call VFBACKUP.VXD entry point with:
        nothing -- this API is a NOP for the default Windows95 VFBACKUP
SeeAlso: #02673,#01126
--------W-2F1684BX0037-----------------------
INT 2F - MS Windows - ENABLE.VXD - GET API ENTRY POINT
        AX = 1684h
        BX = 0037h (virtual device ID for ENABLE device) (see #02677)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02676)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02677)
Call Windows95 ENABLE.VXD entry point with:
        AX = function number
            0000h get ENABLE version
                Return: CF clear
                        AX = version (AH = major, AL = minor)
            0001h
                EBX = ???
                Return: ???
            0002h get ???
                Return: CF clear
                        DX:AX = ???
            0003h get ???
                Return: CF clear
                        DX:AX = ???
            0004h ???
                EBX = ???
                ECX = ???
                EDX = ???
                Return: CF clear if successful
                        CF set on error
            else
                Return: CF set
SeeAlso: #02676,#02678
--------W-2F1684BX0038-----------------------
INT 2F - MS Windows - VCOND - GET API ENTRY POINT
        AX = 1684h
        BX = 0038h (virtual device ID for VCOND device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02678)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02678)
Call VCOND.VXD virtual-86 entry point with:
        AX = function number
            0202h
            0203h
            0204h
            0205h
            0206h
            0207h
            0208h
            0209h
            020Ah
            020Bh
            020Dh
            020Eh
            020Fh
            0210h
            0401h
            0402h
            0403h
            0404h
            0405h
            else
                NOP
SeeAlso: #02679,#02677

(Table 02679)
Call VCOND.VXD protected-mode entry point with:
        AX = function number
            0301h
            0302h
            0303h
            0304h
            0305h
            0306h
            0307h
            0308h
            else
                NOP
SeeAlso: #02678,#02676
--------W-2F1684BX003B-----------------------
INT 2F - MS Windows - DSVXD - GET API ENTRY POINT
        AX = 1684h
        BX = 003Bh (virtual device ID for DSVXD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX003D-----------------------
INT 2F - MS Windows - BIOS VxD - GET API ENTRY POINT
        AX = 1684h
        BX = 003Dh (virtual device ID for BIOS device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02680)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02680)
Call BIOS.VXD entry point with:
        AX = function number
            0000h get BIOS.VXD version
                Return: CF clear
                        AH = major version
                        AL = minor version
            0100h ???
                Return: AX = 0000h
                Note:   calls CONFIGMG services 804Eh/804Fh
            0200h ???
                Return: CF clear if successful
                            AX = ???
                        CF set on error
                            AX = error code???
                Note:   invokes VxDcall 00290002h
            0300h ???
                Return: CF clear if successful
                            AX = ???
                        CF set on error
                            AX = error code???
            else
                Return: CF set
SeeAlso: #02679,#02681
--------W-2F1684BX003E-----------------------
INT 2F - MS Windows - WSOCK - GET API ENTRY POINT
        AX = 1684h
        BX = 003Eh (virtual device ID for WSOCK device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX011F-----------------------
INT 2F P - MS Windows - VFLATD - GET API ENTRY POINT
        AX = 1684h
        BX = 011Fh (virtual device ID for VFLATD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02681)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",AX=1684/BX=045Dh,INT 20"Windows"

(Table 02681)
Call VFLATD.VXD entry point with:
        DL = function number
            00h get VFLATD version and ???
                Return: CF clear
                        EAX = version (AH = major, AL = minor)
                        EBX = ???
                        ECX = ???
                        EDX = ??? or 00000000h
            01h ???
                AX = ???
                CX = ???
                Return: EAX = ???
                        EDX = ???
            02h ???
                ???
            03h ???
                EAX = ???
                EBX = ???
                ESI = ???
                CX = ???
                DH = ???
                Return: EAX = ???
                        EDX = ???
                        CF clear
            04h ???
                DH = ???
                EAX = ???
                ECX = ???
                Return: CF clear
                        EAX = ???
                        EDX = ???
            05h ???
                ???
                Note:   locks some linear memory and calls fn 02h
            06h ???
                ???
                Return: CF clear if successful
                        CF set on error
                Note:   calls fn 02h and unlocks some linear memory
            else
                Return: CF set
SeeAlso: #02680
--------W-2F1684BX0200-----------------------
INT 2F - MS Windows - VIPX - GET API ENTRY POINT
        AX = 1684h
        BX = 0200h (virtual device ID for VIPX device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0202-----------------------
INT 2F - MS Windows - WINICE - GET API ENTRY POINT
        AX = 1684h
        BX = 0202h (virtual device ID for WINICE device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0203-----------------------
INT 2F P - MS Windows - VCLIENT - GET API ENTRY POINT
        AX = 1684h
        BX = 0203h (virtual device ID for VCLIENT device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0205-----------------------
INT 2F - MS Windows - BCW - GET API ENTRY POINT
        AX = 1684h
        BX = 0205h (virtual device ID for BCW device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0207-----------------------
INT 2F R - MS Windows - DPMS VxD - GET API ENTRY POINT
        AX = 1684h
        BX = 0207h (virtual device ID for DPMS device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0234-----------------------
INT 2F - MS Windows - VCOMMUTE - GET API ENTRY POINT
        AX = 1684h
        BX = 0234h (virtual device ID for VCOMMUTE device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0442-----------------------
INT 2F P - MS Windows - VTDAPI - GET API ENTRY POINT
        AX = 1684h
        BX = 0442h (virtual device ID for VTDAPI device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02682)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02682)
Call VTDAPI.VXD entry point with:
        EAX = function number
            0000h
            0001h
            0002h
            0003h
            0004h
            0005h
            0006h
            0007h
            0008h
            0009h
            000Ah
            000Bh
            else
                Return: nothing???
SeeAlso: #02682
--------W-2F1684BX0444-----------------------
INT 2F - MS Windows - VADMAD - GET API ENTRY POINT
        AX = 1684h
        BX = 0444h (virtual device ID for VADMAD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02683)
                  0000h:0000h if the VxD does not support an API

(Table 02683)
Call VADMAD entry point with:
        DX = operation
            0000h set VADMAD mode
                AX = desired mode
            0001h set VADMAD channel
                AX = desired channel
Note:   after setting mode/channel, start the DMA operation with an OUT to
          I/O port 0Bh (channels 0-3) or D6h (channels 4-7)
SeeAlso: #01268 at INT 20"Windows"
--------W-2F1684BX0445-----------------------
INT 2F - MS Windows - VSBD - GET API ENTRY POINT
        AX = 1684h
        BX = 0445h (virtual device ID for VSBD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0446-----------------------
INT 2F - MS Windows - VADLIBD - GET API ENTRY POINT
        AX = 1684h
        BX = 0446h (virtual device ID for VADLIBD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0449-----------------------
INT 2F P - MS Windows - vjoyd - GET API ENTRY POINT
        AX = 1684h
        BX = 0449h (virtual device ID for "vjoyd" device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02684)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02684)
Call VJOYD.VXD entry point with:
        AX = function number
            0000h get VJOYD version
                Return: AH = major version
                        AL = minor version
            0001h ???
                DX = ???
                Return: DX:AX = ???
            0002h ???
                DX = ???
                Return: DX:AX = ???
            0003h ???
                Retrun: AX = 0001h
            0004h ???
                DX = ???
                Return: DX:AX = ???
            0005h ???
                Return: ???
            else
                Return: EAX = 00000000h
SeeAlso: #02682,#02685
--------W-2F1684BX044A-----------------------
INT 2F - MS Windows - mmdevldr - GET API ENTRY POINT
        AX = 1684h
        BX = 044Ah (virtual device ID for "mmdevldr" device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02685)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02685)
Call MMDEVLDR.VXD entry point with:
        DX = function number
            0000h ???
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = error code (000Bh)
                Note:   invokes VxDCall 17000Eh ("CallAtAppyTime")
            0001h ???
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = error code (000Bh)
                Note:   invokes VxDCall 17000Eh ("CallAtAppyTime")
            0002h ???
                EDX = ???
                Return: CF clear if successful
                            AX = 0000h
                            EDX = ???
                        CF set on error
                            AX = error code
            0003h ???
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = error code
                Note:   invokes VxDcall 2A0002h ("VWIN32_QueueUserApc")
            0004h set Win32 event
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = error code
                Note:   invokes VxDcall 2A000Eh ("VWIN32_SetWin32Event")
            0005h ??? (allocates some memory)
                Return: CF clear
                        AX = 0000h
            0006h ??? (frees memory)
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = error code
            else
                Return: CF set
                        AX = 000Bh (invalid function)
SeeAlso: #02684,#02686
--------W-2F1684BX045D-----------------------
INT 2F P - MS Windows - VflatD - GET API ENTRY POINT
        AX = 1684h
        BX = 045Dh (virtual device ID for VflatD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",AX=1684h/BX=011Fh,INT 20"Windows"
--------W-2F1684BX045F-----------------------
INT 2F - MS Windows - azt16 - GET API ENTRY POINT
        AX = 1684h
        BX = 045Fh (virtual device ID for "azt16" device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02686)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h/BX=3110h,AX=1684h"DEVICE API",INT 20"Windows"

(Table 02686)
Call azt16.VXD entry point with:
        DX = function number
            0000h get azt16 version
                Return: CF clear
                        AX = version (AH=major, AL=minor)
            0001h ???
                AX = subfunction
                    0000h ???
                        Return:
                    0001h ???
                        ECX = ???
                    else error
                Return: CF clear if successful
                            ???
                        CF set on error
                            AX = error code
            0002h ???
                AX = ???
                BX = ???
                Return: ???
            0003h ???
                AX = ???
                BX = ???
                Return: ???
            0004h ???
                BX = ???
                CX = ???
                Return: CF clear if successful
                             AX = 0001h
                        CF set on error
                             AX = 0000h
            0005h ???
                BX = ???
                CX = ???
                Return: CF clear if successful
                             AX = 0001h
                        CF set on error
                             AX = 0000h
            0006h ???
                BX = ???
                ECX = ???
                Return: CF clear if succesful
                            AX = ???
                        CF set on error
                            AX = FFFFh
            0100h get azt16 version
                Return: CF clear
                        AX = version (AH=major, AL=minor)
            0101h
                AX = ???
                ECX = ???
                Return: CF clear if successful
                            AX = 0001h
                        CF set on error
                            AX = 0000h
            0102h ???
                AX = ???
                Return: CF clear if successful
                        CF set on error
                            AX = reason??? (0/1/2)
            0103h ???
                AX = ???
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
                            AX = reason??? (1/3)
            0200h ???
                EDX = ???
                ???
                Return: CF clear if successful
                            DX:AX = ???
                        CF set on error
                            DX:AX = 0000h:0000h
            0201h ???
                ???
                Return: CF clear
                        AX= 0000h
            else
                Return: CF set
SeeAlso: #02685,#02705
--------W-2F1684BX0460-----------------------
INT 2F P - MS Windows - UNIMODEM - GET API ENTRY POINT
        AX = 1684h
        BX = 0460h (virtual device ID for UNIMODEM device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02687)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02687)
Call UNIMODEM.VXD protected-mode entry point with:
        AX = function number
            0000h
                Return: AX = ???
            0001h
                Return: AX = ???
            0002h
                Return: AX = ???
            0003h
                Return: AX = ???
            0004h
                Return: AX = ???
            0005h
                Return: AX = ???
            0006h
                Return: AX = ???
            0007h
                Return: AX = ???
            else
                Return: AX = 0002h
SeeAlso: #02686,#02688
--------W-2F1684BX0480-----------------------
INT 2F - MS Windows - VNetSup - GET API ENTRY POINT
        AX = 1684h
        BX = 0480h (virtual device ID for VNetSup device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02688)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02688)
Call VNetSup.VXD entry point with:
        AX = function number
            0000h
                Return: AX = ???
            0001h
                Return: AX = ???
            0002h
                Return: AX = ???
            else
                Return: CF set
                        AX = 0001h
SeeAlso: #02687,#02689
--------W-2F1684BX0482-----------------------
INT 2F - MS Windows - VBrowse - GET API ENTRY POINT
        AX = 1684h
        BX = 0482h (virtual device ID for VBrowse device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0483-----------------------
INT 2F - MS Windows - VSHARE - GET API ENTRY POINT
        AX = 1684h
        BX = 0483h (virtual device ID for VSHARE device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02689)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02689)
Call Windows95 VSHARE.VXD entry point with:
        AX = function number
            0000h get VSHARE version
                Return: AH = major version
                        AL = (BCD?) minor version
            else
                NOP
SeeAlso: #02688
--------W-2F1684BX0484-----------------------
INT 2F P - MS Windows - IFSMgr - GET API ENTRY POINT
        AX = 1684h
        BX = 0484h (virtual device ID for IFSMgr device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0486-----------------------
INT 2F - MS Windows - VFAT - GET API ENTRY POINT
        AX = 1684h
        BX = 0486h (virtual device ID for VFAT device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0487-----------------------
INT 2F - MS Windows - NWLINK - GET API ENTRY POINT
        AX = 1684h
        BX = 0487h (virtual device ID for NWLINK device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX0489-----------------------
INT 2F R - MS Windows - VIP - GET API ENTRY POINT
        AX = 1684h
        BX = 0489h (virtual device ID for VIP device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX048A-----------------------
INT 2F - MS Windows 3.11 - VXDLDR - GET API ENTRY POINT
        AX = 1684h
        BX = 048Ah (virtual device ID for VTCP device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX048A-----------------------
INT 2F - MS Windows - VCACHE - GET API ENTRY POINT
        AX = 1684h
        BX = 048Ah (virtual device ID for VCACHE device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02691)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02690)
Call Windows95 VCACHE.VXD entry point with:
        Return: CF set
SeeAlso: #02689,#02691
--------W-2F1684BX048D-----------------------
INT 2F - MS Windows - RASMAC - GET API ENTRY POINT
        AX = 1684h
        BX = 048Dh (virtual device ID for RASMAC device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX048E-----------------------
INT 2F - MS Windows - NWREDIR - GET API ENTRY POINT
        AX = 1684h
        BX = 048Eh (virtual device ID for NWREDIR device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02691)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02691)
Call Windows95 NWREDIR.VXD entry point with:
        Return: CF set
                EAX = FFFFFFFFh
SeeAlso: #02690
--------W-2F1684BX0494-----------------------
INT 2F - MS Windows - NSCL - GET API ENTRY POINT
        AX = 1684h
        BX = 0494h (virtual device ID for NSCL device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02692,#02693)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02692)
Call Windows95 NSCL.VXD virtual-86 entry point with:
        AL = function number
            00h
            01h
            02h
            03h
            04h
            05h
            06h
            07h
            08h
            09h
            0Ah
            else
                Return: AX = FFFFh
SeeAlso: #02691,#02692

(Table 02693)
Call Windows95 NSCL.VXD protected-mode entry point with:
        AL = function number
            00h
            01h
            02h
            03h
            else
                Return: AX = FFFFh
SeeAlso: #02692
--------W-2F1684BX0499-----------------------
INT 2F - MS Windows - PPPMAC - GET API ENTRY POINT
        AX = 1684h
        BX = 0499h (virtual device ID for PPPMAC device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX049A-----------------------
INT 2F - MS Windows - VDHCP - GET API ENTRY POINT
        AX = 1684h
        BX = 049Ah (virtual device ID for VDHCP device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX049B-----------------------
INT 2F - MS Windows - VNBT - GET API ENTRY POINT
        AX = 1684h
        BX = 049Bh (virtual device ID for VNBT device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX1021-----------------------
INT 2F - MS Windows - VMB - GET API ENTRY POINT
        AX = 1684h
        BX = 1021h (virtual device ID for VMB device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX28A0-----------------------
INT 2F - MS Windows - PHARLAPX - GET API ENTRY POINT
        AX = 1684h
        BX = 28A0h (virtual device ID for PHARLAPX device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02694)
                  0000h:0000h if the VxD does not support an API

(Table 02694)
Call PHARLAPX VxD entry point with:
        AX = function
            0001h get PHARLAP.386 version
                Return: AX = version number (AH = major, AL = minor)
        ---queue functions---
            0101h allocate a new message queue
                CX = size of queue data buffer in bytes
                Return: DX:AX = handle for new queue, or 0000h:0000h on error
            0102h allocate a new key queue
                CX = size of queue data buffer in bytes
                EDX = VM handle into which keys will be pasted
                Return: DX:AX = handle for new queue, or 0000h:0000h on error
            0103h free message queue
                EDX = queue handle
                Return: AX = status (0000h,0003h,0007h) (see #02695)
            0104h free key queue
                EDX = queue handle
                Return: AX = status (0000h,0003h,0005h) (see #02695)
            0105h add message to communications queue
                EDX = queue handle
                BX = length of message data in bytes
                CX = length of message header in bytes
                ES:(E)SI -> message header
                GS:(E)DI -> message data
                Return: AX = status (0000h-0003h,0007h) (see #02695)
            0106h remove message from queue
                EDX = queue handle
                CX = length of buffer in bytes
                ES:(E)SI -> buffer for message
                Return: AX = status (0000h,0003h,0006h,0007h,0008h) (see #02695)
                        CX = length of returned message (if AX=0000h or 0008h)
            0107h flush queue (remove all data)
                EDX = queue handle
                Return: AX = status (0000h,0003h) (see #02695)
            0108h add PasteKey structure(s) to key queue
                EDX = queue handle
                CX = number of PasteKey structures in buffer
                ES:(E)SI -> PasteKey array (see #02696)
                Return: AX = status (0000h-0003h) (see #02695)
            0109h register enqueueing callback function
                EDX = queue handle
                ECX = function argument
                ES:(E)SI -> callback function
                Return: AX = status (0000h,0003h,0009h) (see #02695)
            010Ah register dequeueing callback function
                EDX = queue handle
                ECX = function argument
                ES:(E)SI -> callback function
                Return: AX = status (0000h,0003h,0009h) (see #02695)
            010Bh unregister enqueueing callback function
                EDX = queue handle
                Return: AX = status (0000h,0003h,0009h) (see #02695)
            010Ch unregister dequeueing callback function
                EDX = queue handle
                Return: AX = status (0000h,0003h,0009h) (see #02695)
            010Dh get message queue status
                EDX = queue handle
                Return: AX = status (0000h,0003h) (see #02695)
                        CX = number of pending messages
            010Eh peek at message in queue
                EDX = queue handle
                BX = number of message in queue (0000h = first)
                CX = size of buffer in bytes
                ES:(E)SI -> buffer for message
                Return: AX = status (0000h,0003h,0006h,0008h) (see #02695)
                        CX = length of returned message (if AX=0000h or 0008h)
            010Fh peek at last message in queue
                EDX = queue handle
                CX = size of buffer in bytes
                ES:(E)SI -> buffer for message
                Return: AX = status (0000h,0003h,0006h,0008h) (see #02695)
                        CX = length of returned message (if AX=0000h or 0008h)
            0110h replace last message in queue
                EDX = queue handle
                CX = length of message header in bytes
                BX = length of message data in bytes
                ES:(E)SI -> message header
                GS:(E)DI -> message data
                Return: AX = status (0000h,0002h,0003h) (see #02695)
            0111h set permitted message count for queue
                EDX = queue handle
                CX = maximum number of messages to enqueue (FFFFh = unlimited)
                Return: AX = status (0000h,0003h) (see #02695)
        ---generalized VxD services---
            0202h call VxD function
                ES:(E)BX -> in/out register-set buffer
                Return: buffer updated
            0203h map flat
                ???
        --system register functions---
            0301h read system registers into buffer
                ES:(E)SI -> 512-byte buffer
                Return: AX = 0000h
                        buffer filled (mostly zeros)
            0302h copy linear memory into buffer
                EDX = linear address
                CX = number of bytes to copy
                ES:(E)SI -> buffer
                Return: AX = 0000h
            0303h copy data into linear memory
                EDX = linear address
                CX = number of bytes to copy
                ES:(E)SI -> buffer
                Return: AX = 0000h
            0304h freeze VM
                ???
            0305h unfreeze VM
                ???
        ---name registration functions---
            0401h register name
                EDX = magic number to associate with name
                ES:(E)SI -> name to register
                Return: AX = status (0000h,0009h) (see #02695)
            0402h unregister name
                ES:(E)SI -> name to be unregistered
                Return: AX = status (0000h,0009h) (see #02695)
            0403h look up name
                ES:(E)SI -> name to look up
                Return: DX:AX = magic number or 0000h:0000h if not registered
            0404h get name list handle
                Return: DX:AX = name list handle
                                0000h:0000h if not initialized
        ---special DOS server routines (undocumented)---
            0501h register
            0502h unregister
            0503h validate VM
            0504h get INT9 count
            0505h get screen line
            0506h get shift status
            0507h get server PB pointer
            0508h initialize DOS shell
            0509h get last VM handle

(Table 02695)
Values for PHARLAPX function status:
 00h    successful
 01h    data is too large to fit in queue
 02h    queue is full
 03h    invalid queue handle
 04h    invalid VM handle for queue
 05h    error starting a paste operation
 06h    queue is empty
 07h    a VM is blocked waiting on the queue
 08h    message was too long (truncated)
 09h    unable to register or unregister specified callback
SeeAlso: #02694

Format of PHARLAPX PasteKey structure:
Offset  Size    Description     (Table 02696)
 00h    BYTE    ASCII code
 01h    BYTE    scan code (see #00006)
 02h    WORD    shift states
SeeAlso: #02694

Format of PHARLAPX VxD-call register structure:
Offset  Size    Description     (Table 02697)
 00h    DWORD   call number
 04h    WORD    input register map (see #02698)
 06h    WORD    output register map (see #02698)
 08h  7 DWORDs  values for EAX, EBX, ECX, EDX, EBP, ESI, EDI on call
 24h  4 WORDs   values for DS, ES, FG, GS on call
 2Ch    DWORD   EFLAGS on call
 30h  7 DWORDs  returned values of EAX, EBX, ECX, EDX, EBP, ESI, EDI
 4Ch  4 WORDs   returned values of DS, ES, FS, GS
 54h    DWORD   returned EFLAGS
SeeAlso: #02694

Bitfields for PHARLAPX VxD-call register map:
Bit(s)  Description     (Table 02698)
 0      value in EAX field is valid
 1      value in EBX field is valid
 2      value in ECX field is valid
 3      value in EDX field is valid
 4      value in EBP field is valid
 5      value in ESI field is valid
 6      value in EDI field is valid
 7      value in DS field is valid
 8      value in ES field is valid
 9      value in FS field is valid
 10     value in GS field is valid
 11     value in EFLAGS field is valid
SeeAlso: #02697
--------W-2F1684BX28A1-----------------------
INT 2F - MS Windows - PharLap VxD - GET API ENTRY POINT
        AX = 1684h
        BX = 28A1h (virtual device ID for PharLap device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",AX=1684h/BX=28A0h,INT 20"Windows"
--------W-2F1684BX2925-----------------------
INT 2F - MS Windows - EDOS - GET API ENTRY POINT
        AX = 1684h
        BX = 2925h (virtual device ID for EDOS device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02699)
                  0000h:0000h if the VxD does not support an API

(Table 02699)
Call EDOS entry point with:
        AX = 0000h get EDOS version number
            Return: AH = major version
                    AL = minor version
        AX = 0001h display message
            CX = 0
            DX:BX -> ASCIZ Message
        AX = 0002h get EDOS error coded
            Return: EAX = time in milliseconds that Windows has been running
        AX = 0003h execute windows program
            Return: EAX = cumulative amount of time the virtual machine has
                        been active, in milliseconds
        AX = 0008h get/set priority
            BX = 0000h??? foreground
                 0001h background
            DI = 0000h get
                 0001h set
            DX = priority setting
            Return: CX = foreground priority
                    DX = background priority
                    BX:AX = flags
                        00000001h exclusive ON
                        00000010h background ON
                    SI = CPU percentage
--------W-2F1684BX292D-----------------------
INT 2F - MS Windows - VSBPD - GET API ENTRY POINT
        AX = 1684h
        BX = 292Dh (virtual device ID for VSBPD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX295A-----------------------
INT 2F - MS Windows - GRVSULTR - GET API ENTRY POINT
        AX = 1684h
        BX = 295Ah (virtual device ID for GRVSULTR device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
--------W-2F1684BX3099-----------------------
INT 2F - MS Windows - VVidramD - GET API ENTRY POINT
        AX = 1684h
        BX = 3099h (virtual device ID for VVidramD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02701)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02701)
Call VVidramD (VIDRAM.VXD) virtual-86 entry point with:
        AX = function number
            0000h map page???
                BX = page number???
                Return: CF clear if successful
                        CF set on error
            0001h ???
                Return: CF clear if successful
                        CF set on error
            else
                Return: CF set
SeeAlso: #02700,#02702
--------W-2F1684BX30F6-----------------------
INT 2F P - MS Windows - WSVV - GET API ENTRY POINT
        AX = 1684h
        BX = 30F6h (virtual device ID for WSVV device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02702)
Call WSVV.VXD protected-mode entry point with:
        AX = function number
            ????
        Return: ???
SeeAlso: #02701,#02703
--------W-2F1684BX310E-----------------------
INT 2F - MS Windows - WPS - GET API ENTRY POINT
        AX = 1684h
        BX = 310Eh (virtual device ID for WPS device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02703)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02703)
Call WPS protected-mode entry point with:
        DX = function
            0000h get WPS.386 version
                Return: CF clear
                        AX = version (AH = major, AL = minor)
            0001h get number of installed VxDs
                Return: CF clear
                        AX = number of installed VxDs
            0002h get VxD characteristics
                AX = number of VxD
                ES:BX -> buffer for VxD characteristics structure (see #02704)
                Return: CF clear
                        ES:BX buffer filled
SeeAlso: #02702,#02706

Format of WPS.386 VxD characteristics structure:
Offset  Size    Description     (Table 02704)
 00h    WORD    VxD ID number
 02h    BYTE    VxD minor version
 03h    BYTE    VxD major version
 04h    BYTE    DDK minor version
 05h    BYTE    DDK major version
 06h    WORD    flags
                bit 0: V86 API supported
                bit 1: PM API supported
                bit 2: services supported
 08h    DWORD   start order
 0Ch  9 BYTEs   ASCIZ VxD name
SeeAlso: #02703
--------W-2F1684BX3110-----------------------
INT 2F - MS Windows - VSGLX16.386 - GET API ENTRY POINT
        AX = 1684h
        BX = 3110h (virtual device ID for VSGLX16.386) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02705)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h/BX=045Fh,AX=1684h"DEVICE API",INT 20"Windows"

(Table 02705)
Call VSGLX16.386 entry point with:
        DX = function number
            0000h get azt16 version
                Return: CF clear
                        AX = version returned by "azt16" device
            0001h get ???
                AX = ??? (always fails if nonzero)
                ES:BX -> buffer for ???
                        first DWORD of buffer must be set to length of buffer
                          (in bytes, 1 <= size <= 92) before calling
                Return: CF clear if successful
                            AX = 0001h
                        CF set on error (invalid pointer, bad buffer size)
                            AX = 0000h
            0002h
                AX = ???
                BX = ???
                Return: CF clear if successful
                            AX = ???
                        CF set on error
                            AX = error code
            0003h
                AX = ???
                BX = ???
                Return: CF clear if successful
                        CF set on error
            0004h set ???
                ES:DI -> buffer containing ???
                BX = ???
                CX = number of bytes to copy
                Return: CF clear if successful
                            AX = 0001h
                        CF set on error
                            AX = 0000h
            0005h get ???
                ES:DI -> buffer for ???
                BX = ???
                CX = number of bytes to copy
                Return: CF clear if successful
                            AX = 0001h
                        CF set on error
                            AX = 0000h
            else
                Return: CF set
SeeAlso: #02686
--------W-2F1684BX31CF-----------------------
INT 2F - MS Windows - STAT.386 - GET API ENTRY POINT
        AX = 1684h
        BX = 31CFh (virtual device ID for STAT.386) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02706)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02706)
Call STAT.386 entry point with:
        AX = function
            0000h get version
                Return: AX = STAT.386 version (AH = major, AL = minor)
            0001h execute RDMSR/WRMSR/RDTSC
                BH = 00h
                BL = second opcode byte (30h=WRMSR,31h=RDTSC,32h=RDMSR)
                EDX:EDI = value to be written (for BL=30h)
                ECX = MSR number for RDMSR/WRMSR
                Return: EDX:EAX = value read (RDTSR/RDMSR only)
SeeAlso: #02703,#02707
--------W-2F1684BX34DC-----------------------
INT 2F - QEMM v8.01 - MAGNARAM VxD - GET API ENTRY POINT
        AX = 1684h
        BX = 34DCh (virtual device ID for MAGNARAM) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02707)
                  0000h:0000h if the VxD does not support an API
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02707)
Call MAGNARAM MAGNA95.VXD protected-mode entry point with:
        AX = function number
            0000h get version and ???
                Return: AX = version (AH = major, AL = minor)
                        CX = ???
                            bit 0: ???
                            bit 1: ???
            0001h get ???
                Return: CF clear
                        DX:AX = ??? SHL 2
            0002h
                Return: CF clear if successful
                            AX = ???
                            DX = ???
                        CF set on error
            0003h get ???
                Return: CF clear
                        DX:AX = ??? SHL 2
            0004h ???
                Return: CF clear
                        DX:AX = ???
            0005h ???
                Return: CF clear
                        DX:AX = ???
            0006h ???
                Return: CF clear
                        DX:AX = ???
            0007h ???
                Return: CF clear
                        DX:AX = ???
            0008h ???
                Return: CF clear
                        DX:AX = ???
            0009h ???
                Return: CF clear
                        DX:AX = ???
            000Ah ???
                Return: CF clear
                        DX:AX = ???
            000Bh get ???
                Return: CF clear
                        DX:AX = ??? SHL 2
            000Ch get ???
                Return: CF clear
                        DX:AX = ??? SHL 2
            000Dh get ???
                Return: CF clear
                        DX:AX = ??? SHL 2
            000Eh get ???
                Return: CF clear
                        AX = ???
                        DX = ???
            000Fh get ???
                Return: CF clear
                        DX:AX = ???
            0010h get ???
                Return: CF clear
                        DX:AX = ???
            0011h get ???
                Return: CF clear
                        DX:AX = ???
            0012h get ???
                Return: CF clear
                        DX:AX = ???
            0013h get ???
                Return: CF clear
                        DX:AX = ???
            0014h get ???
                Return: CF clear
                        DX:AX = ???
            0015h get ???
                Return: CF clear
                        DX:AX = ???
            else
                Return: CF set
SeeAlso: #02706,#02708
--------W-2F1684BX357E-----------------------
INT 2F - MS Windows - DSOUND - GET API ENTRY POINT
        AX = 1684h
        BX = 357Eh (virtual device ID for DSOUND device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"
----------2F1684BX377B-----------------------
INT 2F - MS Windows - MX1501HAD - GET API ENTRY POINT
        AX = 1684h
        BX = 377Bh (virtual device ID for MX1501HAD device)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02708)
                  0000h:0000h if the VxD does not support an API
Note:   The drivers VCMD95C.VXD and VCMD.386 are part of the driver disks
          provided with the chip-card-reader/keyboard combination MX 1501 HAD,
          produced by Cherry
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02708)
Call CHERRY VCMD95C.VXD entry point with:
        AX = function
            0001h get version
                Return: AX = version number (0100h) (AH = major, AL = minor)
            0002h hook INT 09 (and 8???)
            0003h unhook INT 09 (and 8???)
            0004h get number of bytes in FIFO
                Return: AX = bytes in FIFO
            0005h get next FIFO-data
                Return: AX = data
                        BL = port number
                        BH = direction (1=in, 0=out)
                        DX:CX = timestamp
            0006h clear FIFO
            0007h output byte
                DX = port number
                BL = keyboard command
                Return: data in FIFO (see #02710)
                       (value, port, in/out, timestamp)
            0008h input byte
                DX = port number
                Return: data in FIFO (see #02710)
                        (value, port, in/out, timestamp)
            0009h input byte immediately
                DX = port number
                Return: AX = data
            000Ah read next FIFO data (nondestructive)
                Return: AX = data
                        BL = port number
                        BH = direction (1=in, 0=out)
                        DX:CX = timestamp
            000Bh get timestamp
                Return: DX:CX = timestamp (in ms)
            000Ch enable IRQ 1
            000Dh disable IRQ 1
            000Eh enable data retrieval
                Note:   Sets a flag in the internal mode-byte which
                          tells the driver to recognize the data
            000Fh disable data retrieval
                Note:   resets a flag in the internal mode-byte
            0010h get retrieval mode
                Return: AX = current retrieval mode
            0011h set retrieval mode
                BX = new retrieval mode (see #02709)
                Return: AX = old retrieval mode
            0012h get command value
                Return: AX = command value
            0013h set command value
                BX = command value
SeeAlso: #02706,#02711

Bitfields for retrieval mode:
Bit(s)  Description     (Table 02709)
 0      enable data retrieval
 1      0 = interrupt-driven
        1 = polling mode
 2      0 = read port 60h everytime
        1 = read port 60h only when OBF of port 64h is set
 3      0 = don't call old INT 9
        1 = call INT 9 before our INT-handler
 4-7    reserved
SeeAlso: #02708,#02710

Format of FIFO entry (1024 entries in FIFO):
Offset  Size    Description     (Table 02710)
 00h    BYTE    data byte
 01h    BYTE    I/O port
 02h    BYTE    direction (1=in, 0=out)
 03h    BYTE    reserved
 04h    DWORD   timestamp
SeeAlso: #02708,#02709
--------W-2F1684BX38DA-----------------------
INT 2F - MS Windows - VIWD - GET API ENTRY POINT
        AX = 1684h
        BX = 38DAh (virtual device ID for VIWD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02711)
                  0000h:0000h if the VxD does not support API in current mode
SeeAlso: AX=1684h"DEVICE API",INT 20"Windows"

(Table 02711)
Call VIWD.VXD entry point with:
        DX = function number
            0000h ???
                Return: CF clear
                        AX = ???
            0004h ???
                Return: CF clear
                        DX = 0000h
            0006h
                Return: CF clear
            000Ah
                AX = ???
                Return: CF clear if successful
                        CF set on error
            000Ch
            000Dh
            000Eh
                Return: CF clear
            000Fh
                Return: CF clear
            0010h
            0011h
            0015h
                Return: CF clear if successful
                            AX = ???
                        CF set on error
                            AX = ???
                        DX = 0000h
            0016h
            0017h
                Return: CF clear if successful
                            AX = ???
                        CF set on error
                            AX = ???
                        DX = 0000h
            0018h ???
                CX = ???
                Return: CF clear if successful
                            AX = 0000h
                        CF set on error
            else
                Return: CF set
SeeAlso: #02708,#02712
--------W-2F1684BX4321-----------------------
INT 2F - MS Windows - POSTMSG - GET API ENTRY POINT
        AX = 1684h
        BX = 4321h (virtual device ID for POSTMSG device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02712,#02714)
                  0000h:0000h if the VxD does not support an API

(Table 02712)
Call POSTMSG protected-mode entry point with:
        AX = window handle
        CX:BX -> callback procedure (see #02713)
Return: nothing
Note:   this call registers a WinApp with the VxD; the callback must be in a
          fixed, non-discardable code segment
SeeAlso: #02714,#02715

(Table 02713)
Values POSTMSG callback routine is called with:
        STACK:  DWORD   "lParam" parameter from DOSApp
                WORD    "wParam" parameter from DOSApp
                WORD    Windows message number (WM_USER + 100h)
                WORD    registered HWND

(Table 02714)
Call POSTMSG V86-mode entry point with:
        BX = wParam value to pass to protected-mode callback
        DX:AX = lParam value to pass to protected-mode callback
Return: CF clear if successful
        CF set on error (no WinApp registered)
SeeAlso: #02712
--------W-2F1684BX7FE0-----------------------
INT 2F - MS Windows - VSWITCHD - GET API ENTRY POINT
        AX = 1684h
        BX = 7FE0h (virtual device ID for VSWITCHD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02715)
                  0000h:0000h if the VxD does not support an API

(Table 02715)
Call VSWITCHD entry point with:
        AX = function
            0000h toggle windowed mode (simulate Alt-Enter keypress)
                Return: nothing
            0001h get windowed mode
                Return: CF clear if VM is windowed
                        CF set if VM is full-screen
SeeAlso: #02712,#02716
--------W-2F1684BX8888-----------------------
INT 2F - MS Windows - VbillD - GET API ENTRY POINT
        AX = 1684h
        BX = 8888h (virtual device ID for VbillD device) (see #02642)
        ES:DI = 0000h:0000h
Return: ES:DI -> VxD API entry point (see #02716)
                  0000h:0000h if the VxD does not support an API

(Table 02716)
Call VbillD entry point with:
        AX = function
            0001h set reverse video
            0002h set normal video
Return: ???
SeeAlso: #02715
--------W-2F1685-----------------------------
INT 2F - MS Windows - SWITCH VMs AND CALLBACK
        AX = 1685h
        BX = VM ID of virtual machine to switch to
        CX = flags (see #02717)
        DX:SI = priority boost (refer to VMM.INC)
        ES:DI -> FAR procedure to callback
Return: CF set on error
            AX = error code
                01h invalid VM ID
                02h invalid priority boost
                03h invalid flags
        CF clear if successful
            event will be or has been called
Notes:  some DOS devices, such as networks, need to call functions in a
          specific VM. This call forces the appropriate VM to be installed.
        the callback procedure must preserve all registers and return with IRET
SeeAlso: AX=1683h,INT 15/AX=1117h,AX=DB06h"WINGO"

Bitfields for VM switching flags:
Bit(s)  Description     (Table 02717)
 0      wait until interrupts enabled
 1      wait until critical section unowned
 2-15   reserved (zero)
--------W-2F1688BX0BAD-----------------------
INT 2F U - MS Windows 3.0, 386MAX v6.01 - GET ALIAS SELECTOR TO LDT
        AX = 1688h
        BX = 0BADh
Return: AX = 0000h if supported
            BX = alias selector for LDT
Note:   use the LSL instruction or GetSelectorLimit() to find LDT size
        this call should be considered obsolete for Windows 3.1+, as the
          alias selector can be retrieved via the API entry point for
          "MS-DOS" retrieved from INT 2F/AX=168Ah (see #02720)
SeeAlso: AX=1687h,#02720
--------W-2F1689-----------------------------
INT 2F U - MS Windows 3.0+ - KERNEL IDLE CALL
        AX = 1689h
        BX = status flags (see #04105)
Return: ???
Desc:   the Windows KERNEL idle loop calls this function, which VMM uses as an
          indication that the system is idle, which in turn generates INT 28
          and INT 2F/AX=1607h/BX=0018h callouts
SeeAlso: AX=1680h,AX=1607h/BX=0018h,INT 15/AX=1000h,INT 28

Bitfields for Kernel Idle status flags:
Bit(s)  Description     (Table 04106)
 15-1   reserved
 0      "Win_Idle_Mouse_Busy"
--------W-2F168B-----------------------------
INT 2F - MS Windows 3.1 - SET FOCUS TO SPECIFIED VIRTUAL MACHINE
        AX = 168Bh
        BX = virtual machine ID (see AX=1683h), 0000h for current DOS box
Return: AL = 00h if focus set to specified VM
Notes:  documented on the Microsoft Developer's Network CD-ROM
        if the VM is a windowed DOS box, it will be set to full screen
SeeAlso: AX=1683h
--------W-2F168C-----------------------------
INT 2F - MS Windows 3.1 - RESTART COMMAND
        AX = 168Ch
        ???
Return: ???
Note:   WIN.COM executes specified application
--------W-2F168EDX0000-----------------------
INT 2F - Windows95 - TITLE - SET APPLICATION TITLE
        AX = 168Eh
        DX = 0000h
        ES:DI -> ASCIZ application title (max 79 chars+NUL)
Return: AX = status
            0000h failed
            0001h successful
Note:   if ES:DI is 0000h:0000h or points at an empty string, the current
          title is removed
BUG:    this function can return a successful status even though the title was
          not changed; reportedly, waiting for two clock ticks after program
          startup solves this problem
SeeAlso: AX=168Eh/DX=0001h,AX=168Eh/DX=0002h
--------W-2F168EDX0001-----------------------
INT 2F - Windows95 - TITLE - SET VIRTUAL MACHINE TITLE
        AX = 168Eh
        DX = 0001h
        ES:DI -> ASCIZ virtual machine title (max 29 chars+NUL)
Return: AX = status
            0000h failed
            0001h successful
Notes:  if ES:DI is 0000h:0000h or points at an empty string, the current
          title is removed
        the VM title should only be changed on explicit instruction from the
          user
BUG:    this function can return a successful status even though the title was
          not changed; reportedly, waiting for two clock ticks after program
          startup solves this problem
SeeAlso: AX=168Eh/DX=0000h,AX=168Eh/DX=0003h
--------W-2F168EDX0002-----------------------
INT 2F - Windows95 - TITLE - GET APPLICATION TITLE
        AX = 168Eh
        DX = 0002h
        ES:DI -> buffer for ASCIZ application title
        CX = size of buffer in bytes
Return: AX = status
            0000h failed
            0001h successful
Desc:   copy as much of the application's window title as possible to the given
          buffer, appending a terminating NUL to the buffer
SeeAlso: AX=168Eh/DX=0000h,AX=168Eh/DX=0003h
--------W-2F168EDX0003-----------------------
INT 2F - Windows95 - TITLE - GET VIRTUAL MACHINE TITLE
        AX = 168Eh
        DX = 0003h
        ES:DI -> buffer for ASCIZ virtual-machine title
        CX = size of buffer in bytes
Return: AX = status
            0000h failed
            0001h successful
Desc:   copy as much of the virtual machine's title as possible to the given
          buffer, appending a terminating NUL to the buffer
SeeAlso: AX=168Eh/DX=0001h,AX=168Eh/DX=0002h
--------W-2F168FDH00-------------------------
INT 2F - Windows95 - CLOSE-AWARENESS - ENABLE/DISABLE CLOSE COMMAND
        AX = 168Fh
        DH = 00h
        DL = new state
            00h disabled
            01h enabled
Return: AX = status
            0000h successful
            else failed
Desc:   enable or disable the system menu Close command for an application
SeeAlso: AX=168Fh/DH=01h,AX=168Fh/DH=02h
--------W-2F168FDH01-------------------------
INT 2F - Windows95 - CLOSE-AWARENESS - QUERY CLOSE
        AX = 168Fh
        DH = 01h
        DL = 00h (reserved)
Return: AX = status
            0000h Close command selected but not yet acknowledged
            0001h Close command issued and acknowledged
            168Fh Close command not selected -- application should continue
Desc:   determine whether the user has requested that the application be closed
          by selecting the system menu's Close option
SeeAlso: AX=168Fh/DH=00h,AX=168Fh/DH=02h
--------W-2F168FDH02-------------------------
INT 2F - Windows95 - CLOSE-AWARENESS - ACKNOWLEDGE CLOSE
        AX = 168Fh
        DH = 02h
        DL = 00h (reserved)
Return: AX = status
            0000h successful
            else failed
Note:   once a Close command has been issued, no further keyboard input is
          available to the application until it calls this function to
          acknowledge the Close request
SeeAlso: AX=168Fh/DH=00h,AX=168Fh/DH=03h
--------W-2F168FDH03-------------------------
INT 2F - Windows95 - CLOSE-AWARENESS - CANCEL CLOSE
        AX = 168Fh
        DH = 03h
        DL = 00h (reserved)
Return: AX = status
            0000h successful
            else failed
Desc:   cancels a close request which has already been acknowledged if the
          application determines that it will not exit at this time
SeeAlso: AX=168Fh/DH=00h,AX=168Fh/DH=03h
--------W-2F1700-----------------------------
INT 2F - MS Windows "WINOLDAP" - IDENTIFY WinOldAp VERSION
        AX = 1700h
Return: AX = 1700h if this version of WINOLDAP doesn't support clipboard
        AX <> 1700h
            AL = WINOLDAP major version
            AH = WINOLDAP minor version
Program: WinOldAp (WINOLDAP.MOD) is a Microsoft Windows extension supporting
          "old" (character-mode) application access to Dynamic Data Exchange,
          menus, and the Windows clipboard.
Note:   this installation check DOES NOT follow the format used by other
          software of returning AL=FFh
SeeAlso: AX=1701h,AX=4601h
Index:  installation check;WINOLDAP
--------W-2F1701-----------------------------
INT 2F - MS Windows "WINOLDAP" - OPEN CLIPBOARD
        AX = 1701h
Return: AX = status
            nonzero success
            0000h   clipboard is already open
SeeAlso: AX=1700h,AX=1702h,AX=1703h,AX=1704h,INT 16/AX=CB00h
--------W-2F1702-----------------------------
INT 2F - MS Windows "WINOLDAP" - EMPTY CLIPBOARD
        AX = 1702h
Return: AX = status
            nonzero clipboard has been emptied
            0000h   failure
SeeAlso: AX=1700h,AX=1701h,AX=1703h,AX=1704h,INT 16/AX=CB05h
--------W-2F1703-----------------------------
INT 2F - MS Windows "WINOLDAP" - SET CLIPBOARD DATA
        AX = 1703h
        DX = clipboard format supported by WinOldAp (see #02723)
        ES:BX -> data (see #02724,#02725)
        SI:CX = size of data
Return: AX = status
            nonzero data copied into the Clipboard
            0000h   failure
SeeAlso: AX=1701h,AX=1705h,INT 16/AX=CB04h

(Table 02723)
Values for WinOldAp clipboard format:
 01h    text
 02h    bitmap
 03h    metafile picture
 04h    SYLK
 05h    DIF
 06h    TIFF
 07h    OEM text
 08h    DIB bitmap
 80h    special format (used by Windows WRITE, maybe other Windows applets???)
 81h    DSP text
 82h    DSP bitmap

Format of Windows Clipboard bitmap:
Offset  Size    Description     (Table 02724)
 00h    WORD    type (0000h)
 02h    WORD    width of bitmap in pixels
 04h    WORD    height of bitmap in pixels
 06h    WORD    bytes per line
 08h    BYTE    number of color planes
 09h    BYTE    number of adjacent color bits in pixel
 0Ah    DWORD   pointer to start of data
 0Eh    WORD    width in 0.1mm units
 10h    WORD    height in 0.1mm units
 12h  N BYTEs   bitmap data

Format of Windows metafile picture:
Offset  Size    Description     (Table 02725)
 00h    WORD    mapping mode
 02h    WORD    X extent
 04h    WORD    Y extent
 06h    WORD    picture data
--------W-2F1704-----------------------------
INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA SIZE
        AX = 1704h
        DX = clipboard format supported by WinOldAp (see #02723)
Return: DX:AX = size of data in bytes, including any headers
                0000h:0000h if no data in this format in the Clipboard
Note:   Windows reportedly rounds up the size of the data to a multiple of 32
          bytes
SeeAlso: AX=1700h,AX=1703h,AX=1705h
--------W-2F1705-----------------------------
INT 2F - MS Windows "WINOLDAP" - GET CLIPBOARD DATA
        AX = 1705h
        DX = clipboard format supported by WinOldAp (see #02723)
        ES:BX -> buffer
Return: AX = status
            nonzero success
            0000h   error, or no data in this format in Clipboard
SeeAlso: AX=1700h,AX=1704h,INT 16/AX=CB03h
--------W-2F1708-----------------------------
INT 2F - MS Windows "WINOLDAP" - CloseClipboard
        AX = 1708h
Return: AX = status
            0000h failure
            nonzero success
--------W-2F1709-----------------------------
INT 2F - MS Windows "WINOLDAP" - COMPACT CLIPBOARD
        AX = 1709h
        SI:CX = desired size in bytes
Return: DX:AX = number of bytes in largest block of free memory
Note:   WinOldAp is responsible for including the size of any headers
--------W-2F170A-----------------------------
INT 2F - MS Windows "WINOLDAP" - GET DEVICE CAPABILITIES
        AX = 170Ah
        DX = GDI information index (see #02726)
Return: AX = integer value of the desired item
              (see #02727,#02728,#02729,#02730,#02731,#02732,#02733)
Note:   This function returns the device-capability bits for the given display

(Table 02726)
Values for GDI information index:
 00h    device driver version
 02h    device classification
 04h    width in mm
 06h    height in mm
 08h    width in pixels
 0Ah    height in pixels
 0Ch    bits per pixel
 0Eh    number of bit planes
 10h    number of brushes supported by device
 12h    number of pens supported by device
 14h    number of markers supported by device
 16h    number of fonts supported by device
 18h    number of colors
 1Ah    size required for device descriptor
 1Ch    curve capabilities
 1Eh    line capabilities
 20h    polygon capabilities
 22h    text capabilities
 24h    clipping capabilities
 26h    bitblt capabilities
 28h    X aspect
 2Ah    Y aspect
 2Ch    length of hypotenuse of aspect
 58h    logical pixels per inch of width
 5Ah    logical pixels per inch of height
SeeAlso: #02727,#02728,#02729,#02730,#02731,#02732,#02733

(Table 02727)
Values for device classification:
 00h    vector plotter
 01h    raster display
 02h    raster printer
 03h    raster camera
 04h    character-stream, PLP
 05h    Metafile, VDM
 06h    display-file
SeeAlso: #02726,#02728,#02729,#02730,#02731,#02732,#02733

Bitfields for curve capabilities:
Bit(s)  Description     (Table 02728)
 0      circles
 1      pie wedges
 2      chord arcs
 3      ellipses
 4      wide lines
 5      styled lines
 6      wide styled lines
 7      interiors
SeeAlso: #02726,#02727,#02729,#02730,#02731,#02732,#02733

Bitfields for line capabilities:
Bit(s)  Description     (Table 02729)
 1      polylines
 2      markers
 3      polymarkers
 4      wide lines
 5      styled lines
 6      wide styled lines
 7      interiors
SeeAlso: #02726,#02727,#02728,#02730,#02731,#02732,#02733

Bitfields for polygon capabilities:
Bit(s)  Description     (Table 02730)
 0      polygons
 1      rectangles
 2      trapezoids
 3      scanlines
 4      wide borders
 5      styled borders
 6      wide styled borders
 7      interiors
SeeAlso: #02726,#02727,#02728,#02729,#02731,#02732,#02733

Bitfields for text capabilities:
Bit(s)  Description     (Table 02731)
 0      output precision character
 1      output precision stroke
 2      clippping precision stroke
 3      90-degree character rotation
 4      arbitrary character rotation
 5      independent X and Y scaling
 6      double-size
 7      integer scaling
 8      continuous scaling
 9      bold
 10     italic
 11     underline
 12     strikeout
 13     raster fonts
 14     vector fonts
 15     reserved
SeeAlso: #02726,#02727,#02728,#02729,#02730,#02732,#02733

(Table 02732)
Values for clipping capabilities:
 00h    none
 01h    clipping to rectangles
SeeAlso: #02726,#02727,#02728,#02729,#02730,#02731,#02733

Bitfields for raster capabilities:
Bit(s)  Description     (Table 02733)
 0      simple bitBLT
 1      device requires banding support
 2      device requires scaling support
 3      supports >64K bitmap
SeeAlso: #02726,#02727,#02728,#02729,#02730,#02731,#02732
--------W-2F4000-----------------------------
INT 2F - Windows 3+ (OS/2 2.x???) - GET VIRTUAL DEVICE DRIVER (VDD) CAPABILTIES
        AX = 4000h
Return: AL = video virtualization (see #02746)
Notes:  This function is used by display drivers to find out what capabilities
          exist for the VDD driver and also trigger the VDD driver to call
          functions 4005h and 4006h (and 4001h/4002h under OS/2?).  This
          function also gives the Video Driver hardware access to the video
          registers.
        Once the background/foreground callouts have been activated by a
          call to this function, the application *must* handle those callouts
          and save/restore the video memory itself.

(Table 02746)
Values for Windows video virtualization:
 01h    does not virtualize video access
 02h    virtualizes the video when in text mode
 03h    virtualizes the video when in text mode or single plane graphics modes
 04h    virtualizes the video when in text mode, single plane graphics modes,
          and VGA multiplane modes
 FFh    virtualizes the video fully
--------W-2F4003-----------------------------
INT 2F - Windows 3.x - ENTERING VIDEO DRIVER CRITICAL SECTION
        AX = 4003h
Note:   This critical section must be exited within 1 second.
SeeAlso: AX=4004h
--------W-2F4004-----------------------------
INT 2F - Windows 3.x - EXITING VIDEO DRIVER CRITICAL SECTION
        AX = 4004h
SeeAlso: AX=4003h
--------W-2F4005-----------------------------
INT 2F C - Windows 3.x - SWITCHING DOS TO BACKGROUND
        AX = 4005h
Notes:  called by Windows when the DOS box is about to be placed in the
          background and the video driver should save any necessary state
          information (this may be called only in Standard mode)
        this callout is not made unless the application has first called
          AX=4000h
SeeAlso: AX=4001h,AX=4006h
--------W-2F4006-----------------------------
INT 2F C - Windows 3.x - SWITCHING DOS TO FOREGROUND
        AX = 4006h
Notes:  called by Windows when the DOS box is about to be placed in the
          foreground and the video driver should restore any necessary state
          information (this may be called only in Standard mode)
        this callout is not made unless the application has first called
          AX=4000h
SeeAlso: AX=4002h,AX=4005h
--------W-2F4007-----------------------------
INT 2F - Windows 3.x - ENABLE VDD TRAPPING OF VIDEO REGISTERS
        AX = 4007h
Note:   used by Windows Standard mode
--------W-2F4680-----------------------------
INT 2F U - MS Windows v3.0 - INSTALLATION CHECK
        AX = 4680h
Return: AX = result
            0000h MS Windows 3.0 running in real (/R) or standard (/S) mode,
                  or DOS 5 DOSSHELL active
            nonzero  no Windows, Windows prior to 3.0, or Windows3 in enhanced
                  mode
Note:   Windows 3.1 finally provides an installation check which works in all
          modes (see AX=160Ah)
SeeAlso: AX=1600h,AX=160Ah
--------W-2F4B06-----------------------------
INT 2F - MS Windows - WIN.COM - GET ??? POINTER TO WIN.COM
        AX = 4B06h
Return: AX = 0000h
        ES:BX -> ??? function in WIN.COM
Note:   the entry point is called with
            AX = 0001h or 0003h
            BX = ???
SeeAlso: AX=4B80h
--------W-2F4B20-----------------------------
INT 2F - MS Windows 3+ - WIN.COM - SET PROGRAM TO EXECUTE ON EXIT
        AX = 4B20h
Return: AX = 0000h if successful
            DX:CX -> 256-byte buffer for pathname and commandline (see #02824)
Notes:  when the Windows function ExitWindows is called with an exit code of
          44h, WIN.COM executes the program specified in the returned buffer
          and then restarts Windows
        the returned address is a real-mode segment:offset value
SeeAlso: AX=4B21h

Format of WIN.COM buffer:
Offset  Size    Description     (Table 02824)
 00h 128 BYTEs  commandline for program (count byte, command tail, 0Dh)
 80h 128 BYTEs  ASCIZ pathname of program to execute
Note:   the order above is for a Windows95 DOS box; it may be reversed under
          Windows 3.x
--------W-2F4B21-----------------------------
INT 2F - Windows95 - WIN.COM - GET NESTING LEVEL
        AX = 4B21h
Return: AH = 00h if WIN.COM already active
            AL = number of instances of WIN.COM in memory
SeeAlso: AX=4B20h
--------W-2F4B80-----------------------------
INT 2F - MS Windows - WSWAP.EXE - RESET INTERNAL VARIABLES
        AX = 4B80h
Return: nothing
Note:   called by WINOLDAP.MOD
SeeAlso: AX=4B06h
--------W-30---------------------------------
INT 30 P - MS Windows 3.1+ - PROTECTED-MODE CALLBACK
SeeAlso: INT 20"Windows"
--------W-2FF200-----------------------------
INT 2F - WINX - INSTALLATION CHECK
        AX = F200h
Return: AX = 00FFh if installed
Program: WINX is a DOS/Windows utilities by Al Williams which can be used to
          launch Windows applications from a DOS Box; it was published in
          "DOS and Windows Protected Mode-Programming with DOS Extenders"
          (Addison-Wesley) and should not be confused with the Windows driver
          of the same name which is part of the DESQview/X package
--------W-2FF201-----------------------------
INT 2F - WINX - RETURN ADDRESS OF SERVER BUFFER
        AX = F201h
Return: AX = status
            FFFFh if WINX is busy processing a different request
            0000h if successful
                BX:CX = address of server buffer (see #03125)

Format of WINX server buffer:
Offset  Size    Description     (Table 03125)
 00h    BYTE    command/status
                00h buffer available
                01h buffer contains result
                02h change directory
                03h execute program
                FFh terminate windows portion of WINX
 01h  ? BYTEs   command (03h) or directory (02h)
  or
 01h    DWORD   result (01h)
--------W-2FF202-----------------------------
INT 2F - WINX - SET SERVER'S WORKING DIRECTORY
        AX = F202h
        BX:CX -> directory
Return: AX = status
            FFFFh if WINX is busy processing a different request
            0000h if successful
SeeAlso: AX=F200h,AX=F203h
--------W-2FF203-----------------------------
INT 2F - WINX - EXECUTE COMMAND
        AX = F203h
        BX:CX -> command
Return: AX = status
            0000h if successful
            FFFFh if WINX is busy processing a different request
SeeAlso: AX=F200h,AX=F202h
--------W-2FF200-----------------------------
INT 2F - WINX - INSTALLATION CHECK
        AX = F200h
Return: AX = 00FFh if installed
Program: WINX is a DOS/Windows utilities by Al Williams which can be used to
          launch Windows applications from a DOS Box; it was published in
          "DOS and Windows Protected Mode-Programming with DOS Extenders"
          (Addison-Wesley) and should not be confused with the Windows driver
          of the same name which is part of the DESQview/X package
--------W-2FF201-----------------------------
INT 2F - WINX - RETURN ADDRESS OF SERVER BUFFER
        AX = F201h
Return: AX = status
            FFFFh if WINX is busy processing a different request
            0000h if successful
                BX:CX = address of server buffer (see #03125)

Format of WINX server buffer:
Offset  Size    Description     (Table 03125)
 00h    BYTE    command/status
                00h buffer available
                01h buffer contains result
                02h change directory
                03h execute program
                FFh terminate windows portion of WINX
 01h  ? BYTEs   command (03h) or directory (02h)
  or
 01h    DWORD   result (01h)
--------W-2FF202-----------------------------
INT 2F - WINX - SET SERVER'S WORKING DIRECTORY
        AX = F202h
        BX:CX -> directory
Return: AX = status
            FFFFh if WINX is busy processing a different request
            0000h if successful
SeeAlso: AX=F200h,AX=F203h
--------W-2FF203-----------------------------
INT 2F - WINX - EXECUTE COMMAND
        AX = F203h
        BX:CX -> command
Return: AX = status
            0000h if successful
            FFFFh if WINX is busy processing a different request
SeeAlso: AX=F200h,AX=F202h
