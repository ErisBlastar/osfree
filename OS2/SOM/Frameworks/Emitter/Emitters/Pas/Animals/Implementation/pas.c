
/*
 *  This file was generated by the SOM Compiler.
 *  Generated using:
 *     SOM incremental update: 2.24
 */


/*
 *  This file was generated by the SOM Compiler and Emitter Framework.
 *  Generated using template emitter:
 *      SOM Emitter emitctm: 2.23.1.9
 */

#ifndef SOM_Module_pas_Source
#define SOM_Module_pas_Source
#endif
#define PascalEmitter_Class_Source

#include "pas.ih"
#include <scparm.h>
#include <sctdef.h>
#include <scseqnce.h>
#include <scmodule.h>
#include <scstruct.h>
#include <scconst.h>
#include <scenum.h>
#include <scenumnm.h>
#include <scunion.h>
#include <scattrib.h>
#include <scclass.h>
#include "sequences.h"
#include "strpas.h"
#include <string.h>

#define DEBUG

#ifdef DEBUG
  #define debug(s,...) somPrintf(__func__"(): "##s"\n" ,##__VA_ARGS__)
#else
  #define debug(x, ...)
#endif

#define GEN_SOM_CLASSES         1
#define GEN_PASCAL_CLASSES      0

#define PARAM_CLASS             1
#define PARAM_CLASS_PTR         2

static PLINKITEM MakeTypeLinkItem(PIDLSEQUENCE TypeItems,
                                  PIDLSEQUENCE LinkItems, SOMTEntryC *et,
                                  SOMTCommonEntryC *decl);

// Cоздание описателя элемента в общем списке элементов TypeItems

static PTYPEITEM MakeTypeItem(PIDLSEQUENCE TypeItems, long DefType,
                         boolean NeedAddPtr,
                         char *Name,
                         SOMTEntryC *entry)
{
  PTYPEITEM             TypeItem;

  TypeItem = calloc( 1, sizeof(TYPEITEM) );
  TypeItem->Obj = entry;
  TypeItem->DefType = DefType;
  TypeItem->PtrFlag = NeedAddPtr;
  TypeItem->Name = strdup( Name );
  if ( entry )
    TypeItem->Comment = __get_somtEntryComment(entry);
  seqInit( (PIDLSEQUENCE)&TypeItem->LinkItems, 0, sizeof(PLINKITEM) );
  seqInsert( TypeItems, sizeof(PTYPEITEM), &TypeItem );
  return TypeItem;
}

// Поиск описателя элемента по объекту Emitter Framework

static PTYPEITEM GetTypeItemByObj(PIDLSEQUENCE TypeItems, SOMTEntryC *en)
{
  PTYPEITEM             TypeItem;
  unsigned long         i;

  for (i=0; i<TypeItems->length; i++)
  {
    TypeItem = *(PTYPEITEM *)seqAt( TypeItems, sizeof(PTYPEITEM), i );
    if ( TypeItem->Obj &&
         __get_somtEntryName(en) == __get_somtEntryName(TypeItem->Obj) )
      return TypeItem;
  }
  return NULL;
}

// Cоздание поля описателя элемента (в его списке LinkItems)

static PLINKITEM MakeSimpleLinkItem(PIDLSEQUENCE TypeItems, PIDLSEQUENCE LinkItems,
                                    SOMTEntryC *en)
{
  PLINKITEM             LinkItem;

  LinkItem = calloc( 1, sizeof(LINKITEM) );
  LinkItem->Obj = en;
////  LinkItem->PtrDeep = 0;
////  LinkItem->FieldName = NULL;
//  LinkItem->Name = strdup( __get_somtEntryName(en) );
////  LinkItem->TypeItem = NULL;
////  LinkItem->ArrayDim = 0;
  seqInsert( LinkItems, sizeof(PLINKITEM), &LinkItem );
  return LinkItem;
}

// Cоздание описателя последовательности

static PTYPEITEM CollectSequence(PIDLSEQUENCE TypeItems, SOMTSequenceEntryC *seq,
                            SOMTCommonEntryC *decl)
{
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  char                  cBuf[128], cSeqType[128], *pcSeqType;
  unsigned long         pos;
  unsigned long         SeqLen = __get_somtSeqLength(seq);
  SOMTEntryC            *st = __get_somtSeqType(seq);

  // обработка вложенных последовательностей
  if ( __get_somtElementType(st) == SOMTSequenceE ) // тип послед-ти - посл-ть?
  {
    TypeItem = CollectSequence(TypeItems, st, decl);
    sprintf(cSeqType, "sequence_%s",
            __get_somtEntryName( __get_somtSeqType(TypeItem->Obj) ));
    pcSeqType = cSeqType;
  }
  else
    pcSeqType = __get_somtEntryName(st);

  pos = sprintf( cBuf, "%s_IDL_SEQUENCE_%s", __get_somtEntryName(decl),
                 pcSeqType/*__get_somtEntryName(st)*/ );
  if ( SeqLen ) // для обеспечения уникальности дополняем имя длинной очереди
    sprintf( &cBuf[pos], "_%u", SeqLen );
  TypeItem = MakeTypeItem(TypeItems, dtSequence, TRUE, cBuf, seq);

  debug("collect sequence: %s", TypeItem->Name);

  LinkItem = MakeSimpleLinkItem( TypeItems, (PIDLSEQUENCE)&TypeItem->LinkItems,
                                 __get_somtSeqType(seq) );
  // используем это поле под хранение длины очереди (оно свободно т.к.
  // типом последовательности не может быть массив)
  LinkItem->ArrayLen[0] = !SeqLen ? 1 : SeqLen;

  return TypeItem;
}

// Cоздание описателя структуры

static void CollectStruct(PIDLSEQUENCE TypeItems, SOMTStructEntryC* struc)
{
  SOMTTypedefEntryC     *member;
  SOMTCommonEntryC      *decl;
  PTYPEITEM             TypeItem;

  TypeItem = MakeTypeItem(TypeItems, dtStruct, TRUE,
                          __get_somtEntryName(struc), struc);

  debug("collect struct: %s", TypeItem->Name);
  for (member=_somtGetFirstMember(struc); member; member=_somtGetNextMember(struc))
  {
    for (decl=_somtGetFirstDeclarator(member);decl;decl=_somtGetNextDeclarator(member))
      MakeTypeLinkItem( TypeItems, (PIDLSEQUENCE)&TypeItem->LinkItems,
                        __get_somtTypeObj(member), decl );
  }
}

// Cоздание описателя объединения

static void CollectUnion(PIDLSEQUENCE TypeItems, SOMTUnionEntryC* un)
{
  PTYPEITEM                     TypeItem;
  SOMTUnionEntryC_somtCaseEntry *ce;

  TypeItem = MakeTypeItem(TypeItems, dtUnion,
                          TRUE, __get_somtEntryName(un), un);

  debug("collect union: %s", TypeItem->Name);
  // 0й LinkItem - описание типа переключателя объединения
  MakeSimpleLinkItem( TypeItems, (PIDLSEQUENCE)&TypeItem->LinkItems,
                      __get_somtSwitchType(un) );
  // поля объединения
  for (ce=_somtGetFirstCaseEntry(un); ce; ce=_somtGetNextCaseEntry(un))
    MakeTypeLinkItem( TypeItems, (PIDLSEQUENCE)&TypeItem->LinkItems,
                      ce->memberType, ce->memberDeclarator );
}

// Cоздание описателя объявления типа
// здесь также создаются описатели промежуточных объявлений типов для раскладки
// конструкций вроде: typedef struct St {} MySt; typedef **MyPntToArrOfPnts[10];

static PLINKITEM MakeTypeLinkItem(PIDLSEQUENCE TypeItems,
                                  PIDLSEQUENCE LinkItems, SOMTEntryC *et,
                                  SOMTCommonEntryC *decl)
{
  PLINKITEM     LinkItem, ScanLinkItem, res;
  PTYPEITEM     TypeItem;
  long          dim;
  char          cBuf[128];
  unsigned long i;
  long          ArrayDim, ArrayLen[32];

  if ( !__get_somtIsReference(et) )
    switch ( __get_somtElementType(et) )
    {
      case SOMTSequenceE:
        if ( !GetTypeItemByObj(TypeItems, et) )
          CollectSequence(TypeItems, et, decl);
        break;
      case SOMTStructE:
        CollectStruct(TypeItems, et);
        break;
      case SOMTUnionE:
        CollectUnion(TypeItems, et);
        break;
    }

  LinkItem = MakeSimpleLinkItem( TypeItems, LinkItems, et );
  LinkItem->PtrDeep = strlen(__get_somtPtrs(decl));
  LinkItem->FieldName = strdup( __get_somtEntryName(decl) );
  res = LinkItem;

  debug("\tfield: %s, DeepPtr=%d", LinkItem->FieldName, LinkItem->PtrDeep);

  if ( _somtIsArray(decl,&dim) )
  {
    // читаем размерности массива
    ArrayDim = 0;
    if ( dim = _somtGetFirstArrayDimension(decl) )
      for (; dim; dim = _somtGetNextArrayDimension(decl) )
      {
        ArrayLen[ArrayDim] = dim;
        ArrayDim++;
      }
    else {
      ArrayLen[0] = 1;
      ArrayDim = 1;
    }

    if ( LinkItem->PtrDeep > 1 ) // указатель на массив указателей ==>
    {                            // необходимо дополнительное объявление
                                 // типа-массива, и объявление указателя на его
      LinkItem->PtrDeep--;

      // смотрим, нет ли уже найденного объявления идентичного массива
      for (i=0; i<TypeItems->length; i++)
      {
        TypeItem = *(PTYPEITEM *)seqAt( TypeItems, sizeof(PTYPEITEM), i );
        if ( TypeItem->DefType != dtTypedef || TypeItem->PtrFlag ||
             TypeItem->Obj || TypeItem->LinkItems._length != 1 )
          continue;
        ScanLinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                            sizeof(PLINKITEM), 0 );
        if ( !ScanLinkItem || LinkItem->PtrDeep != 1 ||
             ScanLinkItem->ArrayDim != ArrayDim || ScanLinkItem->Obj != et ||
             memcmp(&ScanLinkItem->ArrayLen, &ArrayLen, ArrayDim * sizeof(long)) )
          continue;

        LinkItem->TypeItem = TypeItem;  // есть такой - биндим к нему
        return res;
      }

      // теоретически, тут с именами могут быть накладки при одинаковом типе
      // элементов и разных размерах... может, стОит в имени дописывать
      // размерность массива... ?
      sprintf( cBuf, "%s_IDL_ARRAY_%s", __get_somtEntryName(decl), __get_somtEntryName(et) );
      TypeItem = MakeTypeItem(TypeItems, dtTypedef, FALSE, cBuf, NULL);

      LinkItem->TypeItem = TypeItem; // биндим к созданному объявлению массива

      LinkItem = MakeSimpleLinkItem( TypeItems,
                                     (PIDLSEQUENCE)&TypeItem->LinkItems, et );
      LinkItem->PtrDeep = 1;
    }

    LinkItem->ArrayDim = ArrayDim;
    memcpy(&LinkItem->ArrayLen, &ArrayLen, ArrayDim * sizeof(long));
  }

  return res;
}

// Уничтожение LinkItem

static long destroyLinkItem(unsigned long idx, void *item)
{
  PLINKITEM     LinkItem = *(PLINKITEM *)item;

  free(LinkItem->FieldName);
  return 1;
}

// Уничтожение TypeItem

static long destroyTypeItem(unsigned long idx, void *item)
{
  PTYPEITEM     TypeItem = *(PTYPEITEM *)item;

  seqDone((PIDLSEQUENCE)&TypeItem->LinkItems, sizeof(PLINKITEM),
          destroyLinkItem);
  free(TypeItem->Name);
  return 1;
}

#ifdef DEBUG

// debugTypeItems()
// Дебаговый вывод списка описателей TypeItems

static long debugLinkItem(unsigned long idx, void *item)
{
  PTYPEITEM     UplinkTypeItem;
  PLINKITEM     LinkItem = *(PLINKITEM *)item;

  if ( !LinkItem )
    debug("  %u: NULL");
  UplinkTypeItem = LinkItem->TypeItem;
  debug("  %u: %s->%s", idx,
    LinkItem->FieldName ? LinkItem->FieldName : "",
    UplinkTypeItem ? UplinkTypeItem->Name : "");
  return 1;
}

static long debugTypeItem(unsigned long idx, void *item)
{
  PTYPEITEM     TypeItem = *(PTYPEITEM *)item;

  debug("%u: %s", idx, TypeItem->Name);
  seqForEach((PIDLSEQUENCE)&TypeItem->LinkItems, sizeof(PLINKITEM),
             debugLinkItem);
  return 1;
}

static void debugTypeItems(PIDLSEQUENCE TypeItems)
{
  debug("-- "__func__"() --");
  seqForEach(TypeItems, sizeof(PTYPEITEM), debugTypeItem);
  debug("----------------------");
}

#else
  #define debugTypeItems(x)
#endif

// Построение графа, описывающего связи между полями описателей и описателями
// т.е. установка значений LinkItem->TypeItem у полей описателей на основе
// ссылок на объекты Emitter Framework

static void BindTypes(PIDLSEQUENCE TypeItems)
{
  unsigned long i, j, k;
  PTYPEITEM     TypeItem, UplinkTypeItem;
  PLINKITEM     LinkItem;

  for (i=0; i<TypeItems->length; i++)
  {
    TypeItem = *(PTYPEITEM *)seqAt( TypeItems, sizeof(PTYPEITEM), i );
    for (j=0; j < TypeItem->LinkItems._length; j++)
    {
      LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                      sizeof(PLINKITEM), j );
      if ( !LinkItem->TypeItem && LinkItem->Obj )
        for (k=0; k<TypeItems->length; k++)
        {
          UplinkTypeItem = *(PTYPEITEM *)seqAt( TypeItems, sizeof(PTYPEITEM), k );
          if ( UplinkTypeItem->Obj && __get_somtEntryName(UplinkTypeItem->Obj)
               == __get_somtEntryName(LinkItem->Obj) )
          {
            LinkItem->TypeItem = UplinkTypeItem;
            UplinkTypeItem->BindCount++;
            debug("bind: %s.%s -> %s", TypeItem->Name, LinkItem->FieldName,
                                       UplinkTypeItem->Name);
            break;
          }
        }
    }
  }

  debugTypeItems(TypeItems);
}

// Сортировка описателей: все поля описателей должны ссылаться на описатели
// с меньшим индексом в списке TypeItems

static void SortTypes(PIDLSEQUENCE TypeItems)
{
  long          i, j, k, l;
  PTYPEITEM     UplinkTypeItem, TypeItem;
  PLINKITEM     LinkItem;
  boolean       found;
  PTYPEITEM     SwapBuf;

  for (i=0; i < (long)TypeItems->length-1; i++)
  {
    l = -1;
TestItem:
    TypeItem = *(PTYPEITEM *)seqAt( TypeItems, sizeof(PTYPEITEM), i );
    for (j=0; j < TypeItem->LinkItems._length; j++)
    {
      LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&(TypeItem->LinkItems),
                                      sizeof(PLINKITEM), j );
      if ( UplinkTypeItem = LinkItem->TypeItem )
      {
        found = FALSE;
        for (k=i+1; k < TypeItems->length; k++)
        {
          if ( UplinkTypeItem == *(PTYPEITEM *)seqAt(TypeItems, sizeof(PTYPEITEM), k) )
          {
            found = l != k;
            if ( !found ) // надо попробовать добиться такой ситуации (конструкции в idl)
              somPrintf("Warning! Cycled links.");
            break;
          }
        }
        if ( found )
        {
          l = k;
          seqSwap(TypeItems, sizeof(PTYPEITEM), i, k, &SwapBuf);
          goto TestItem;
        }
      }
    }
  }
}

// LinkItemStr()
// Строковое представление типа LinkItem в нотации паскаля

static char *PasTypeStr(char *pcBuf, SOMTEntryC *Obj,
                        unsigned long GenerateRealSOMClassesDef)
{
  char          *pcTypeName;

  pcTypeName = __get_somtEntryName(Obj);

  if ( __get_somtElementType(Obj) == SOMTClassE && GenerateRealSOMClassesDef )
    sprintf(pcBuf, "Real%s", pcTypeName);
  else {
    if ( strncmp(pcTypeName,"unsigned ",9) )
      return pcTypeName;

    *pcBuf = 'u';
    strcpy(&pcBuf[1],&pcTypeName[9]);
  }

  return pcBuf;
}

static char *LinkItemStr(char *pcBuf, PLINKITEM LinkItem,
                          unsigned long GenerateRealSOMClassesDef)
{
  unsigned long i;
  char          *pcPrefix = NULL;
  char          cTypeName[92];
  PTYPEITEM     UplinkTypeItem;

  if ( LinkItem->ArrayDim )
  {
    strcpy(pcBuf,"array [");
    pcBuf = strchr(pcBuf,'\0');
    for (i=0; i<LinkItem->ArrayDim; i++)
    {
      if ( i ) *(pcBuf++) = ',';
      sprintf(pcBuf, "0..%u", LinkItem->ArrayLen[i]-1);
      pcBuf = strchr(pcBuf,'\0');
    }
    strcpy(pcBuf,"] of ");
    pcBuf = strchr(pcBuf,'\0');
  }


  if ( !LinkItem->Obj ||
       strncmp(__get_somtEntryName(LinkItem->Obj), "void*", 5) )
  {
    UplinkTypeItem = (PTYPEITEM)(LinkItem->TypeItem);
    if ( UplinkTypeItem && ( UplinkTypeItem->DefType == dtTypedef ||
         UplinkTypeItem->DefType == dtPTypedef ) )
    {
      if ( LinkItem->PtrDeep <= 1 )
      {
        pcPrefix = UplinkTypeItem->DefType == dtTypedef ? "^T" : "^P";
        if ( !LinkItem->PtrDeep )
          pcPrefix++;
      }
    }
    else {
      if ( !LinkItem->PtrDeep )
        pcPrefix = "T";
      else if ( LinkItem->PtrDeep == 1 )
        pcPrefix = "P";
      else if ( LinkItem->PtrDeep == 2 )
        pcPrefix = "^P";
    }
  }

  if ( pcPrefix )
  {
    sprintf( pcBuf, "%s%s", pcPrefix,
      UplinkTypeItem ? UplinkTypeItem->Name :
                       PasTypeStr(cTypeName,LinkItem->Obj,
                                  GenerateRealSOMClassesDef) );
  } else
    strcpy( pcBuf, "pointer" );

  return pcBuf;
}

// Вывод объявлений типов.

static void PutupTypedefs(PIDLSEQUENCE TypeItems,
                          unsigned long *pCurrentPasSection,
                          SOMTTemplateOutputC *template)
{
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  unsigned long         i, j;
  char                  cBuf[128];

  for (i=0; i<TypeItems->length; i++)
  {
    TypeItem = *(PTYPEITEM *)seqAt( TypeItems, sizeof(PTYPEITEM), i );
    // описываем только объявления типов, dtClass - предварительное объявление
    // класса, выводим только если на него были ссылки (BindCount != 0)
    if ( !(TypeItem->DefType & dtTypeMask) ||
         (TypeItem->DefType == dtClass && !TypeItem->BindCount) )
      continue;

    if ( !(*pCurrentPasSection & dtTypeMask) )
    {
      _somtOutputSection(template, "pasTypedefsPrologS");
      *pCurrentPasSection = TypeItem->DefType;
    }

    _somtSetSymbolCopyBoth(template, "pasComment", TypeItem->Comment);
    _somtSetSymbolCopyBoth(template, "defDeclName", TypeItem->Name);

    // дополнительное рисование указателя на то что дальше будем выводить.
    if ( TypeItem->PtrFlag && ( TypeItem->DefType != dtTypedef ) )
      _somtOutputSection(template, "pasPtrToRecTypedefS");

    switch ( TypeItem->DefType )
    {
      case dtClass:
        _somtOutputSection(template, "pasForwardClassS");
        break;

      case dtTypedef:
      case dtPTypedef:
        LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                        sizeof(PLINKITEM), 0 );
        LinkItemStr(cBuf, LinkItem, GEN_SOM_CLASSES);
        _somtSetSymbolCopyBoth(template, "typedefPasBaseType", cBuf);
       _somtOutputSection(template,
          TypeItem->DefType == dtTypedef ? "pasTypedefS" : "pasPTypedefS");
        _somtOutputSection(template, "pasTypedefEpilogS");
        break;

      case dtStruct:
        _somtOutputSection(template, "pasStructS");
        for (j=0; j<TypeItem->LinkItems._length; j++)
        {
          LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                          sizeof(PLINKITEM), j );
          _somtSetSymbolCopyBoth(template, "structFieldName", LinkItem->FieldName);
          LinkItemStr(cBuf, LinkItem, GEN_SOM_CLASSES);
          _somtSetSymbolCopyBoth(template, "typedefPasBaseType", cBuf);
          _somtOutputSection(template, "pasStructMemberS");
        }
        _somtOutputSection(template, "pasStructEpilogS");
        break;

      case dtUnion:
        LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                        sizeof(PLINKITEM), 0 );
        LinkItemStr(cBuf, LinkItem, GEN_SOM_CLASSES);
        _somtSetSymbolCopyBoth(template, "switchType", cBuf);
        _somtOutputSection(template, "pasUnionS");
        for (j=1; j<TypeItem->LinkItems._length; j++)
        {
          sprintf(cBuf, "%u", (j-1));
          _somtSetSymbolCopyBoth(template, "unionMemberLabel", cBuf);
          LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                          sizeof(PLINKITEM), j );
          _somtSetSymbolCopyBoth(template, "unionMemberName", LinkItem->FieldName);
          LinkItemStr(cBuf, LinkItem, GEN_SOM_CLASSES);
          _somtSetSymbolCopyBoth(template, "unionMemberType", cBuf);
          _somtOutputSection(template, "pasUnionMemberS");
        }
        _somtOutputSection(template, "pasUnionEpilogS");
        break;

      case dtSequence:
        LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                        sizeof(PLINKITEM), 0 );
        sprintf(cBuf, "%u", LinkItem->ArrayLen[0]);
        _somtSetSymbolCopyBoth(template, "sequenceMax", cBuf);
        LinkItemStr(cBuf, LinkItem, GEN_SOM_CLASSES);
        _somtSetSymbolCopyBoth(template, "sequenceType", cBuf);
        _somtOutputSection(template, "pasSequenceS");
        break;

      case dtEnum:
        _somtSetSymbolCopyBoth(template, "typedefPasBaseType", "Tlong");
       _somtOutputSection(template, "pasTypedefS");
        break;

      default:
        debug("Aukhtung!");
    }
  }
}

// Вывод структуры ClassData

static void PutupClassData(SOMTClassEntryC *cls, PIDLSEQUENCE TypeItems,
                           SOMTTemplateOutputC *template)
{
  SOMTMethodEntryC      *me;
  SOMTDataEntryC        *de;
  string                rn, mn;

  _somtOutputSection(template, "classDataPrologS");

  for (rn=_somtGetFirstReleaseName(cls); rn; rn=_somtGetNextReleaseName(cls))
  {
    for (de=_somtGetFirstData(cls); de; de=_somtGetNextData(cls))
      if ( !strcmp(rn, __get_somtEntryName(de)) ) break;

    if ( !de )
    {
      _somtSetSymbolCopyBoth(template, "dataName", rn);
      _somtOutputSection(template, "classDataS");
    }
  }

  for (me=_somtGetFirstMethod(cls); me; me=_somtGetNextMethod(cls))
  {
    mn = __get_somtEntryName(me);
    for (rn=_somtGetFirstReleaseName(cls); rn; rn=_somtGetNextReleaseName(cls))
      if ( !strcmp(mn,rn) ) break;

    if ( !rn )
    {
      _somtSetSymbolCopyBoth(template, "dataName", mn);
      _somtOutputSection(template, "classDataS");
    }
  }
  _somtOutputSection(template, "classDataEpilogS");
}

static int IsPointerType(SOMTEntryC *td)
{
  long  P, Dim;

  if ( __get_somtElementType(td) != SOMTTypedefBE )
    return 0;
  P = strlen(__get_somtPtrs(td)) + IsPointerType(__get_somtTypedefType(td));
  if ( _somtIsArray(td,&Dim) ) P--;
  return P>0 ? 1 : 0;
}

static int IsStructType(SOMTEntryC *td)
{
  long          Dim;
  SOMTTypes     somt = __get_somtElementType(td);

  if ( somt==SOMTTypedefBE && ( _somtIsArray(td,&Dim) || _somtIsPointer(td) ) )
    return 0;

  return somt==SOMTSequenceE || somt==SOMTStructE || somt==SOMTUnionE ||
         ( somt==SOMTTypedefBE && IsStructType(__get_somtTypeObj(td)) );
}

// GetParamClassItem() возвращает флаги для параметра метода:
//   PARAM_CLASS - параметр является классом
//   PARAM_CLASS_PTR - параметр является указателем на класс

static unsigned long GetParamClassItem(char **pcClassName, SOMTEntryC *et, SOMTCommonEntryC *decl)
{
  long          Dim;
  SOMTTypes     somt = __get_somtElementType(et);
  unsigned long ptr, flags = 0, upflags;

  if ( !decl )
  {
    decl = et;
    if ( somt==SOMTTypedefBE )
      et = __get_somtTypedefType(et);
    else goto l00;
  }

  ptr = strlen(__get_somtPtrs(decl));
  if ( _somtIsArray(decl,&Dim) || ptr > 1 )
    return 0;
  if ( ptr )
    flags |= PARAM_CLASS_PTR;

l00:
  if ( somt==SOMTTypedefBE )
  {
    upflags = GetParamClassItem(pcClassName, et, NULL);
    if ( (upflags & PARAM_CLASS_PTR) && ptr )
      return 0;
    return flags | upflags;
  }

  if ( somt == SOMTClassE )
  {
    *pcClassName = __get_somtEntryName(et);
    flags |= PARAM_CLASS;
  }
  return flags;
}

// Cоздание поля описателя метода
// здесь создаются промежуточные типы для описания параметров методов:
// массивов, указателей.

static PLINKITEM MakeFuncLinkItem(PIDLSEQUENCE TypeItems,
                                  PIDLSEQUENCE LinkItems, SOMTEntryC *et,
                                  SOMTCommonEntryC *decl, char *pcName,
                                  boolean IsResult)
{
  PTYPEITEM     TypeItem;
  PLINKITEM     LinkItem;
  char          cBuf[128];
  long          CritPD;

  LinkItem = MakeTypeLinkItem( TypeItems, LinkItems, et, decl );

  // если тип - структура/последовательность/объединение или прямой потомок от
  // неё, но не массив или указатель на неё, то аргумент - обязательно указатель,
  // но только для "somtInE", т.к. в др. случае аргумент будет объявлен как var.
  if ( !IsResult && !LinkItem->PtrDeep &&
       __get_somtParameterDirection(decl)==somtInE && IsStructType(et) )
    LinkItem->PtrDeep = 1;

  CritPD = __get_somtElementType(et) == SOMTTypedefBE ? 0 : 1;
  if ( LinkItem->PtrDeep>CritPD || LinkItem->ArrayDim || LinkItem->TypeItem )
  {
    CritPD = LinkItem->PtrDeep;
    if ( LinkItem->ArrayDim ) CritPD--;

    sprintf( cBuf, IsResult ? "_IDL_TYPE_RES_%s" : "_IDL_TYPE_%s_%s",
             pcName, LinkItem->FieldName );

    TypeItem = MakeTypeItem(TypeItems, (CritPD>0 ? dtPTypedef : dtTypedef),
                            FALSE, cBuf, NULL);

    // перетаскиваем LinkItem в создаваемое промежуточное объявление типа
    seqDelete(LinkItems, sizeof(PLINKITEM), &LinkItem);
    seqInsert((PIDLSEQUENCE)&TypeItem->LinkItems, sizeof(PLINKITEM), &LinkItem);

    LinkItem = MakeSimpleLinkItem( TypeItems, LinkItems, NULL );
    LinkItem->TypeItem = TypeItem;
    LinkItem->PtrDeep = 0;
    LinkItem->ArrayDim = 0;
    LinkItem->FieldName = strdup( __get_somtEntryName(decl) );
  }
  return LinkItem;
}

// Установка символов шаблона для описания метода.

static void SetMethodHeaderTemplate(SOMTTemplateOutputC *template,
                               PIDLSEQUENCE TypeItems, SOMTMethodEntryC *entry)
{
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  boolean               IsFunction;
  char                  cBuf[256];
  char                  cHdrParamList[256], *pcHdrParamList;
  char                  cParamList[256], *pcParamList;
  char                  cFullList[256], *pcFullList;
  unsigned long         ParamId, i;

  TypeItem = GetTypeItemByObj(TypeItems, entry);
  if ( !TypeItem )
  {
    debug("Warning! %s() was not found in 'TypeItems' list.",
      __get_somtEntryName(entry));
    return;
  }
  IsFunction = TypeItem->DefType == dtFunction;

  _somtSetSymbolCopyBoth(template, "pasMethodFunc",
    IsFunction ? "function" : "procedure");
  if ( IsFunction )
  {
    *(unsigned short *)&cBuf = ' :';
    LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                    sizeof(PLINKITEM), 0 );
    LinkItemStr(&cBuf[2], LinkItem, GEN_SOM_CLASSES);
    _somtSetSymbolCopyBoth(template, "pasMethodResult", "Result := ");
    ParamId = 1;
  }
  else {
    cBuf[0] = '\0';
    _somtSetSymbolCopyBoth(template, "pasMethodResult", "");
    ParamId = 0;
  }
  _somtSetSymbolCopyBoth(template, "pasMethodType", cBuf);

  strcpy(cFullList,"somSelf\nev");
  if ( TypeItem->LinkItems._length == ParamId )
  {
    cHdrParamList[0] = '\0';
    cParamList[0] = '\0';
  }
  else {
    pcHdrParamList = cHdrParamList;
    pcParamList = cParamList;
    pcFullList = strchr(cFullList, '\0');
    for (i=ParamId; i<TypeItem->LinkItems._length; i++)
    {
      *(pcHdrParamList++) = i == ParamId ? '(' : '\n';
      LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                      sizeof(PLINKITEM), i );
      pcHdrParamList += sprintf(pcHdrParamList, "%s %s: ",
        LinkItem->ArrayLen[0] ? "var" : "const", LinkItem->FieldName);

      if ( LinkItem->MethodParamClassFl & PARAM_CLASS )
        pcHdrParamList += sprintf(pcHdrParamList, "%c%s",
          LinkItem->MethodParamClassFl & PARAM_CLASS_PTR ? 'P' : 'T',
          LinkItem->MethodParamClassName);
      else {
        LinkItemStr(pcHdrParamList, LinkItem, GEN_PASCAL_CLASSES); // здесь 3й параметр ниначто уже не влияет...
        pcHdrParamList = strchr( pcHdrParamList, '\0' );
      }

      if ( i != ParamId ) *(pcParamList++) = '\n';
      pcParamList += sprintf(pcParamList, "%s %s: ",
        LinkItem->ArrayLen[0] ? "var" : "const", LinkItem->FieldName);
      LinkItemStr(pcParamList, LinkItem, GEN_SOM_CLASSES);
      pcParamList = strchr( pcParamList, '\0' );

      *(pcFullList++) = '\n';
      if ( LinkItem->MethodParamClassFl & PARAM_CLASS )
      {
        if ( LinkItem->MethodParamClassFl & PARAM_CLASS_PTR )
          pcFullList += sprintf(pcFullList, "@%s^", LinkItem->FieldName);
        else
          pcFullList = strchr( strcpy(pcFullList, LinkItem->FieldName), '\0' );
        pcFullList = strchr( strcpy(pcFullList, ".classObject"), '\0' );
      }
      else
        pcFullList = strchr( strcpy(pcFullList, LinkItem->FieldName), '\0' );
    }
    *(unsigned short *)pcHdrParamList = '\0)';
  }
  _somtSetSymbolCopyBoth(template, "pasMethodHdrParamList", cHdrParamList);
  _somtSetSymbolCopyBoth(template, "pasMethodParamList", cParamList);
  _somtSetSymbolCopyBoth(template, "pasMethodFullParamNameList", cFullList);
}


/*
 * Сбор объявлений типов.
 */

SOM_Scope void  SOMLINK somtGetTypedef(PascalEmitter *somSelf,
                                       SOMTTypedefEntryC* td)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  SOMTCommonEntryC      *decl;
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  SOMTEntryC            *tobj = __get_somtTypeObj(td);
  PascalEmitterMethodDebug("PascalEmitter","somtGetTypedef");

  for (decl=_somtGetFirstDeclarator(td);decl;decl=_somtGetNextDeclarator(td))
  {
    TypeItem = MakeTypeItem((PIDLSEQUENCE)&EmitterData->TypeItems,
       ( !strncmp(__get_somtEntryName(tobj),"void*",5) || IsPointerType(decl) )
         ? dtPTypedef : dtTypedef,
       FALSE, __get_somtEntryName(decl), decl);

    debug("collect typedef: %s", TypeItem->Name);
    LinkItem = MakeTypeLinkItem( (PIDLSEQUENCE)&EmitterData->TypeItems,
                                 (PIDLSEQUENCE)&TypeItem->LinkItems,
                                 tobj, decl );
  }
}

/*
 * Сбор объявлений структур.
 */

SOM_Scope void  SOMLINK somtGetStruct(PascalEmitter *somSelf,
                                      SOMTStructEntryC* struc)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  PascalEmitterMethodDebug("PascalEmitter","somtGetStruct");

  CollectStruct( (PIDLSEQUENCE)&EmitterData->TypeItems, struc );
}

/*
 * Сбор объявлений объединений.
 */

SOM_Scope void  SOMLINK somtGetUnion(PascalEmitter *somSelf,
                                     SOMTUnionEntryC* un)
{
  PascalEmitterData             *EmitterData = PascalEmitterGetData(somSelf);
  PascalEmitterMethodDebug("PascalEmitter","somtGetUnion");

  CollectUnion( (PIDLSEQUENCE)&EmitterData->TypeItems, un );
}

/*
 * Сбор параметров функций.
 */

SOM_Scope void  SOMLINK somtGetMethodParamTypes(PascalEmitter *somSelf,
                                                SOMTMethodEntryC* me)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  SOMTEntryC            *et = __get_somtTypeObj(me);
  SOMTParameterEntryC   *Param = _somtGetFirstParameter(me);
  char                  *pcMethodName = __get_somtEntryName(me);
  PTYPEITEM             TypeItem, ScanTypeItem;
  PLINKITEM             LinkItem, CopyLinkItem;
  unsigned long         i;
  char                  *pcName = __get_somtEntryName(me);
  boolean               IsFunc = __get_somtElementType(et) != SOMTVoidBE;
  PascalEmitterMethodDebug("PascalEmitter","somtGetMethodParamTypes");

  TypeItem = MakeTypeItem((PIDLSEQUENCE)&EmitterData->TypeItems,
                          IsFunc ? dtFunction : dtProcedure,
                          FALSE, pcName, me);

  // Поиск LinkItem описателя атрибута если обрабатываем метод чтения/записи
  // этого атрибута, если находим - делаем дубликат LinkItem и отдаём его.
  // Необходимо для исключения генерации большого числа промежуточных типов
  // (для ф-ии чтения, процедуры записи и для описателя самого атрибута).
  if ( !strncmp(pcName, IsFunc ? "_get_" : "_set_", 5) )
    for (i=0; i<((PIDLSEQUENCE)&EmitterData->TypeItems)->length; i++)
    {
      ScanTypeItem = *(PTYPEITEM *)seqAt( (PIDLSEQUENCE)&EmitterData->TypeItems,
                                          sizeof(PTYPEITEM), i );
      if ( ScanTypeItem->DefType == dtAttrib &&
           !strcmp(ScanTypeItem->Name,&pcName[5]) )
      {
        CopyLinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&ScanTypeItem->LinkItems,
                                            sizeof(PLINKITEM), 0 );
        LinkItem = MakeSimpleLinkItem( (PIDLSEQUENCE)&EmitterData->TypeItems,
                                       (PIDLSEQUENCE)&TypeItem->LinkItems,
                                       CopyLinkItem->Obj );
        LinkItem->FieldName = strdup( CopyLinkItem->FieldName );
        LinkItem->PtrDeep = CopyLinkItem->PtrDeep;
        LinkItem->ArrayDim = CopyLinkItem->ArrayDim;
        memcpy(&LinkItem->ArrayLen, &CopyLinkItem->ArrayLen, 32*sizeof(long));
        LinkItem->TypeItem = CopyLinkItem->TypeItem;
        return;
      }
    }

  if ( TypeItem->DefType == dtFunction )
    MakeFuncLinkItem( (PIDLSEQUENCE)&EmitterData->TypeItems,
                      (PIDLSEQUENCE)&TypeItem->LinkItems,
                      __get_somtTypeObj(me), me, pcMethodName, TRUE );

  for (; Param; Param=_somtGetNextParameter(me) )
  {
//debug("==> %u", GetParamClassItem( &pcName, __get_somtTypeObj(Param), Param ) );
//debug("--> %s", pcName );
    LinkItem = MakeFuncLinkItem( (PIDLSEQUENCE)&EmitterData->TypeItems,
                                 (PIDLSEQUENCE)&TypeItem->LinkItems,
                                 __get_somtTypeObj(Param), Param,
                                 pcMethodName, FALSE );
    LinkItem->ArrayLen[0] = __get_somtParameterDirection(Param) == somtInE ?
                            0 : 1;

    LinkItem->MethodParamClassFl =
      GetParamClassItem( &LinkItem->MethodParamClassName,
                         __get_somtTypeObj(Param), Param );
  }
}

/*
 * Сбор атрибутов класса.
 */

SOM_Scope void  SOMLINK somtGetAttribute(PascalEmitter *somSelf,
                                         SOMTAttributeEntryC* att)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  SOMTDataEntryC        *decl;
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  PascalEmitterMethodDebug("PascalEmitter","somtGetAttribute");

  for (decl=_somtGetFirstAttributeDeclarator(att); decl;
      decl=_somtGetNextAttributeDeclarator(att))
  {
    TypeItem = MakeTypeItem((PIDLSEQUENCE)&EmitterData->TypeItems, dtAttrib,
                            FALSE, __get_somtEntryName(decl), decl);

    LinkItem = MakeFuncLinkItem( (PIDLSEQUENCE)&EmitterData->TypeItems,
                                 (PIDLSEQUENCE)&TypeItem->LinkItems,
                                 __get_somtAttribType(att), decl,
                                 TypeItem->Name, TRUE );
    LinkItem->ArrayLen[0] = __get_somtIsReadonly(att) ? 1 : 0;
  }
}

/*
 * Сбор типов констант.
 */

SOM_Scope void  SOMLINK somtGetConstant(PascalEmitter *somSelf,
                                        SOMTConstEntryC* con)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  PTYPEITEM             TypeItem;
  PascalEmitterMethodDebug("PascalEmitter","somtGetConstant");

  TypeItem = MakeTypeItem((PIDLSEQUENCE)&EmitterData->TypeItems, dtConst,
                          FALSE, __get_somtEntryName(con), con);
  MakeSimpleLinkItem( (PIDLSEQUENCE)&EmitterData->TypeItems,
                      (PIDLSEQUENCE)&TypeItem->LinkItems,
                      __get_somtConstTypeObj(con) );
}

/*
 * Сбор перечислений.
 */

SOM_Scope void  SOMLINK somtGetEnum(PascalEmitter *somSelf, SOMTEnumEntryC* en)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  SOMTEnumNameEntryC    *member;
  char                  cBuf[128];
  PascalEmitterMethodDebug("PascalEmitter","somtGetEnum");

  TypeItem = MakeTypeItem((PIDLSEQUENCE)&EmitterData->TypeItems, dtEnum,
                          TRUE, __get_somtEntryName(en), en);

  for ( member = _somtGetFirstEnumName(en); member;
        member = _somtGetNextEnumName(en) )
  {
    LinkItem = MakeSimpleLinkItem( (PIDLSEQUENCE)&EmitterData->TypeItems,
                                   (PIDLSEQUENCE)&TypeItem->LinkItems,
                                   NULL );
    sprintf(cBuf, "%s_%s", __get_somtEntryName(en), __get_somtEntryName(member));
    LinkItem->FieldName = strdup( cBuf );
    LinkItem->ArrayLen[0] = __get_somtEnumVal(member);
  }
}

/*
 * "заглушка".
 */

SOM_Scope void  SOMLINK somtEmitNULLFn(PascalEmitter *somSelf,
                                       SOMTEntryC* td)
{
}

/*
 * Реализация методов класса (секция паскаля 'implementation')
 */

SOM_Scope void  SOMLINK somtEmitMethodImplementationProlog(PascalEmitter *somSelf)
{
  _somtOutputSection( __get_somtTemplate(somSelf),
                      "pasImplementationPrologS" );
}

/*
 * Реализация метода класса
 */

SOM_Scope void  SOMLINK somtEmitMethodImplementation(PascalEmitter *somSelf,
                                                     SOMTMethodEntryC* entry)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  SOMTTemplateOutputC   *template = __get_somtTemplate(somSelf);
  PascalEmitterMethodDebug("PascalEmitter","somtEmitMethodImplementation");

  SetMethodHeaderTemplate(template,
                          (PIDLSEQUENCE)&EmitterData->TypeItems, entry);
  _somtOutputSection(template, "pasMethodImplementationS");
}

/*
 * Управление последовательностью секций
 */

SOM_Scope boolean  SOMLINK somtGenerateSections(PascalEmitter *somSelf)
{
  SOMTClassEntryC       *cls = __get_somtTargetClass(somSelf);
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);

  PascalEmitterMethodDebug("PascalEmitter","somtGenerateSections");

  seqInit( (PIDLSEQUENCE)&EmitterData->TypeItems, 0,
           sizeof(PTYPEITEM) );
  EmitterData->buf = malloc(65535);
  EmitterData->CurrentPasSection = 0;

  _somtFileSymbols(somSelf);
  _somtEmitProlog(somSelf);

  if ( cls )
  {
    _somtScanBases(somSelf, "somtEmitBaseIncludesProlog",
      "somtEmitBaseIncludes", "somtEmitBaseIncludesEpilog");
  }

  // формируем список "носителей типов" (typedef/struct/union/sequence/etc...)
  _somtScanTypedefs(somSelf, "somtEmitNULLFn", "somtGetTypedef", "somtEmitNULLFn");
  _somtScanStructs(somSelf, "somtEmitNULLFn", "somtGetStruct", "somtEmitNULLFn");
  _somtScanUnions(somSelf, "somtEmitNULLFn", "somtGetUnion", "somtEmitNULLFn");
  // сбор атрибутов
  if ( cls ) {
    debug("-- сбор атрибутов");
    _somtScanAttributes(somSelf, "somtEmitNULLFn",
                        "somtGetAttribute", "somtEmitNULLFn");
  }
  if ( cls ) {
    // добавляем класс как "носитель типа", понадобится если на него есть ссылки
//    MakeTypeItem((PIDLSEQUENCE)&EmitterData->TypeItems, dtClass, FALSE,
//                 __get_somtEntryName(cls), cls);

    // сбор методов
    debug("-- сбор методов");
    _somtScanMethods(somSelf,
                     "somtImplemented", "somtEmitNULLFn",
                     "somtGetMethodParamTypes", "somtEmitNULLFn", 0);
  }
  // сбор констант
  debug("-- сбор констант");
  _somtScanConstants(somSelf, "somtEmitNULLFn", "somtGetConstant",
                     "somtEmitNULLFn");
  // сбор перечислений
  debug("-- сбор перечислений");
  _somtScanEnums(somSelf, "somtEmitNULLFn",
                 "somtGetEnum", "somtEmitNULLFn");

  // настройка связей "носителей типов" (формирование графа)
  debug("-- настройка связей \"носителей типов\" (формирование графа)");
  BindTypes( (PIDLSEQUENCE)&EmitterData->TypeItems );

  // сортировка "носителей типов"
  debug("-- сортировка \"носителей типов\"");
  SortTypes( (PIDLSEQUENCE)&EmitterData->TypeItems );

  // вывод результата ( секция паскаля "type" )
  debug("-- вывод результата ( секция паскаля \"type\" )");
  PutupTypedefs( (PIDLSEQUENCE)&EmitterData->TypeItems,
                  &EmitterData->CurrentPasSection,
                 __get_somtTemplate(somSelf) );

  if ( cls )
  {
    // вывод структуры ClassData
    debug("-- вывод структуры ClassData");
    PutupClassData( cls, (PIDLSEQUENCE)&EmitterData->TypeItems,
                    __get_somtTemplate(somSelf) );

    // вывод класса
    debug("-- вывод класса");
    _somtEmitClass(somSelf);
    _somtScanMethods(somSelf,
                     "somtImplemented", "somtEmitMethodsProlog",
                     "somtEmitMethod", "somtEmitMethodsEpilog", 0);
    _somtScanAttributes(somSelf, "somtEmitAttributeProlog",
                        "somtEmitAttribute", "somtEmitAttributeEpilog");
    EmitterData->CurrentPasSection = dtConst;
  }

  // вывод констант
  debug("-- вывод констант");
  _somtScanConstants(somSelf, "somtEmitNULLFn", "somtEmitConstant",
                     "somtEmitNULLFn");
  // вывод значений перечислений
  debug("-- вывод значений перечислений");
  _somtScanEnums(somSelf, "somtEmitNULLFn", "somtEmitEnum", "somtEmitNULLFn");

  if ( cls )
  {
    // реализация методов класса
    debug("-- реализация методов класса");
    _somtScanMethods(somSelf,
                     "somtImplemented", "somtEmitMethodImplementationProlog",
                     "somtEmitMethodImplementation", "somtEmitMethodsEpilog",
                     0);
    debug("-- somtScanBases()");
    _somtScanBases(somSelf, "somtEmitBaseProlog", "somtEmitBase",
                   "somtEmitBaseEpilog");
  }

  debug("-- somtEmitEpilog()");
  _somtEmitEpilog(somSelf);

  debug("done...");
  free(EmitterData->buf);
  seqDone((PIDLSEQUENCE)&EmitterData->TypeItems, sizeof(PTYPEITEM),
          destroyTypeItem);

  return TRUE;
}

/*
 * Эмитер метода.
 */

SOM_Scope void  SOMLINK somtEmitMethod(PascalEmitter *somSelf,
                                       SOMTMethodEntryC* entry)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  PascalEmitterMethodDebug("PascalEmitter","somtEmitMethod");

  SetMethodHeaderTemplate( __get_somtTemplate(somSelf),
                           (PIDLSEQUENCE)&EmitterData->TypeItems, entry );

  PascalEmitter_parent_SOMTEmitC_somtEmitMethod(somSelf, entry);
}

/*
 * Эмитер атрибута.
 */

SOM_Scope void  SOMLINK somtEmitAttribute(PascalEmitter *somSelf,
                                          SOMTAttributeEntryC* att)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  SOMTTemplateOutputC   *template = __get_somtTemplate(somSelf);
  SOMTDataEntryC        *decl;
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  char                  cBuf[128];
  PascalEmitterMethodDebug("PascalEmitter","somtEmitAttribute");

  for (decl=_somtGetFirstAttributeDeclarator(att); decl;
      decl=_somtGetNextAttributeDeclarator(att))
  {
    TypeItem = GetTypeItemByObj((PIDLSEQUENCE)&EmitterData->TypeItems, decl);
    if ( !TypeItem )
    {
      debug("Warning! attribute '%s' was not found in 'TypeItems' list.",
        __get_somtEntryName(decl));
      continue;
    }
    _somtSetSymbolCopyBoth(template, "attributeComment", TypeItem->Comment);

    LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                    sizeof(PLINKITEM), 0 );
    _somtSetSymbolCopyBoth(template, "pasAttributeName", LinkItem->FieldName);
    LinkItemStr(cBuf, LinkItem, GEN_PASCAL_CLASSES);
    _somtSetSymbolCopyBoth(template, "pasAttributeType", cBuf);
    _somtOutputSection(template, LinkItem->ArrayLen[0] ?
                       "pasAttributeROS" : "pasAttributeRWS");
  }
}

/*
 * Эмитер интерфейса
 */

SOM_Scope void  SOMLINK somtEmitInterface(PascalEmitter *somSelf,
                                          SOMTClassEntryC* intfc)
{
    /* PascalEmitterData *somThis = PascalEmitterGetData(somSelf); */
    PascalEmitterMethodDebug("PascalEmitter","somtEmitInterface");

    PascalEmitter_parent_SOMTEmitC_somtEmitInterface(somSelf,
                                                     intfc);
}

/*
 * Эмитер определения констант.
 */

SOM_Scope void  SOMLINK somtEmitConstant(PascalEmitter *somSelf,
                                         SOMTConstEntryC* con)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  SOMTTemplateOutputC   *template = __get_somtTemplate(somSelf);
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  char                  cBuf[128];
  PascalEmitterMethodDebug("PascalEmitter","somtEmitConstant");

  if ( EmitterData->CurrentPasSection != dtConst )
  {
    _somtOutputSection(template, "pasConstantsPrologS");
    EmitterData->CurrentPasSection = dtConst;
  }
  TypeItem = GetTypeItemByObj((PIDLSEQUENCE)&EmitterData->TypeItems, con);
  LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                  sizeof(PLINKITEM), 0 );

  passtrIDLConst( EmitterData->buf, __get_somtConstVal(con) );

  _somtSetSymbolCopyBoth(template, "pasConstantValueEvaluated",
                         EmitterData->buf);
  _somtSetSymbolCopyBoth(template, "pasConstType",
                         LinkItemStr(cBuf, LinkItem, GEN_SOM_CLASSES));

  PascalEmitter_parent_SOMTEmitC_somtEmitConstant(somSelf,
                                                  con);
}

/*
 * Эмитер определения перечислений.
 */

/*
 * Эмитер определения значений перечислений.
 */

SOM_Scope void  SOMLINK somtEmitEnum(PascalEmitter *somSelf,
                                     SOMTEnumEntryC* en)
{
  PascalEmitterData     *EmitterData = PascalEmitterGetData(somSelf);
  SOMTTemplateOutputC   *template = __get_somtTemplate(somSelf);
  PTYPEITEM             TypeItem;
  PLINKITEM             LinkItem;
  unsigned long         i;
  char                  cBuf[128];
  PascalEmitterMethodDebug("PascalEmitter","somtEmitEnum");

  if ( EmitterData->CurrentPasSection != dtConst )
  {
    _somtOutputSection(template, "pasConstantsPrologS");
    EmitterData->CurrentPasSection = dtConst;
  }

  TypeItem = GetTypeItemByObj((PIDLSEQUENCE)&EmitterData->TypeItems, en);

  for (i=0; i<TypeItem->LinkItems._length; i++)
  {
    _somtSetSymbolCopyBoth(template, "constantComment",
      i ? NULL : TypeItem->Comment );
    LinkItem = *(PLINKITEM *)seqAt( (PIDLSEQUENCE)&TypeItem->LinkItems,
                                    sizeof(PLINKITEM), i );
    _somtSetSymbolCopyBoth(template, "constantName", LinkItem->FieldName);
    sprintf(cBuf, "%u", LinkItem->ArrayLen[0]);
    _somtSetSymbolCopyBoth(template, "pasConstantValueEvaluated", cBuf);
    _somtSetSymbolCopyBoth(template, "pasConstType", cBuf);

    _somtOutputSection(template, "constantS");
  }
}

/*
 * Эмитер класса
 */

SOM_Scope void  SOMLINK somtEmitClass(PascalEmitter *somSelf)
{
  SOMTTemplateOutputC   *template;
  char                  cBuf[9];
  SOMTClassEntryC       *cls = __get_somtTargetClass(somSelf);
  SOMTClassEntryC       *bc;
  PascalEmitterMethodDebug("PascalEmitter","somtEmitClass");

  template = __get_somtTemplate(somSelf);
  sprintf(cBuf, "%d", __get_somtBaseCount(cls));
  _somtSetSymbolCopyBoth(template, "baseCount", cBuf);

  bc = _somtGetFirstBaseClass(cls);
  _somtSetSymbolCopyBoth(template, "directBase",
    bc ? __get_somtEntryName(bc) : "SOMMI");

  PascalEmitter_parent_SOMTEmitC_somtEmitClass(somSelf);
}

