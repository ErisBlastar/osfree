#
# Copyright (C) 1998-2001, The University of Queensland
# Copyright (C) 2001, Sun Microsystems, Inc
#
# See the file "LICENSE.TERMS" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL
# WARRANTIES.
#

# File: 80386.ssl
# Desc: This file contains a semantic description of the 80386 and 387
# processors. 
# (C) 1998-2001 The University of Queensland, BT group
#

# $Revision: 1.1 $
# 16 Oct 98 - Mike: lower case register names to be consistent with sparc
# 27 Oct 98 - Mike: added many missing relative branch instructions
# 28 Oct 98 - Mike: fixed many CALL etc instructions
# 30 Oct 98 - Mike: fixed some IEAXs that were EAXs
# 30 Oct 98 - Mike: added a missing set of CMP instructions
# 04 Nov 98 - Mike: removed sign extend from relative branches and calls
# 05 Nov 98 - Mike: removed sign extend from immediate constants also; the
#               sign extension is already done by the toolkit
# 05 Nov 98 - Mike: corrected many of the bit number errors
# 27 Jan 99 - Ian:  Modified registers for detailed information, 
#                   (indexing remains the same)
# 27 Nov 98 - Mike: simplified CWDE
# 28 Jan 99 - Mike: Added BT series instructions
# 16 Feb 99 - Mike: Fixed J*LE series instruction semantics
# 04 Mar 99 - Mike: Many fixes to make it parse
# 09 Mar 99 - Mike: More fixes to make it parse: underscores on instruction
#                       names, sin(), FPOP, etc
# 11 Mar 99 - Mike: Removed the last few reg80's. Much reformatting. Fixed
#               inconsistency with STi.ST (thanks, Intel!)
# 16 Mar 99 - Mike: Fixed LOGICALFLAGS() (wasn't done at all!)
# 25 Mar 99 - Mike: Simplified SETNE etc to be ~ZF inst of (ZF = 0)
# 25 Mar 99 - Mike: Fixed instr like CMPib to use modrm ins of r[reg8]
# 28 May 99 - Mike: fixed order of mov to/from eax and memory
# 30 Jun 99 - Mike: simplified shifts (only 1 temp, instead of 2)
# 14 Jul 99 - Mike: fixed PUSH.Ib; added ENDIANNESS
# 09 Sep 99 - Mike: Added FADDP and FSUBP instructions
# 20 Apr 00 - Mike: Fixed a compare that was 64 bits (should be 32).
#                   Also many reg32 -> r[reg32]... these are important now!
# 05 Jul 00 - Mike: Fixed ARITHid and ARITHiw: had r[reg32] inst of modrm
# 12 Jul 00 - Mike: Changed order of operands to fsize() etc (operand now last)
# 28 Aug 00 - Mike: Cleaned up IMUL instructions; added 2 missing forms
# 29 Aug 00 - Mike: Fixed several LOG instructions; had r[tmp1] inst of modrm:
#                   Example "andb %cl,%cl"
# 05 Sep 00 - Mike: Result of float comparison is tmpd now
# 21 Sep 00 - Mike: Result of integer comparisons is tmpb, tmph if needed
# 25 Sep 00 - Mike: Arg to SETFFLAGS was incorrect; more tempds with fcompares
# 28 Sep 00 - Mike: Some FCOMxx instructions were missing the "%st -f"
# 02 Oct 00 - Mike: Added long comment to justify the way FLD.STi is decoded
# 03 Oct 00 - Mike: Fixed SHR, SAR (had erroneous assignment to r[tmp2]
# 09 Oct 00 - Mike: Fixed CWD, CDQ semantics (had 0 and -1 swapped)
# 30 Nov 00 - Mike: Removed most {size} except where applying to memory;
#               trunc->truncu or truncs as appropriate
# 11 Feb 01 - Nathan: Add register sizes for special registers
# 06 Mar 01 - Mike: Changed TEST instructions to use appropriately sized temps
# 08 Mar 01 - Mike: Fixed sizes of operands of MOV.RMB and MOV.RMOD
# 12 Mar 01 - Simon: Retabbed, reformatted, rewrote, really I did.
# 13 Mar 01 - Simon: Fixed sizes of operands in MOV.EB.IVOW and MOV.EB.IVOD
# 19 Mar 01 - Mike: SETFFLAGS takes two operands now, as required by
#               processSubFlags; changed FXCH to use tempD
# 20 Mar 01 - Mike: Removed superfluous entries for FXCH, FUCOM, FUCOMP, etc
#              (had separate versions for i=1, i.e. implied operand of %st1;
#              these are not different instructions, just assembler shortcuts)
# 22 Mar 01 - Mike: Use correct temp names (e.g. tmpb for byte temporaries)
#              Also cast memory operands to flags functions (e.g. modrm{8},...)
# 23 Mar 01 - Mike: Restored some important comments
# 24 Mar 01 - Mike: Repaired some 1OW, 1OD from IOW, IOD (shift/rotate)
# 26 Mar 01 - Mike: F[U]COMP[P] instructions have added temporaries to avoid
#              the side effect of FPOP changing register numbers
# 30 Mar 01 - Mike: Fixed semantics of MOV[ZS]X; was relying on the difference
#               between the assignment size and size cast of the RHS
# 19 Apr 01 - Mike: Fixed semantics of MOVS.VOD
# 24 Apr 01 - Mike: Major overhaul of the string instructions; loops are now
#               implicit (defined by %SKIP and %RPT)
# 17 Jun 01 - Nathan: Major fixup of this file. Don't ask me for details, I've
#               completely lost track of the number of buf-fixes by now...
#                

# Constants defined in hexadecimal (modelling manual) 
MAX8BITS  := 0xFF;
MAX16BITS := 0xFFFF;
MAX32BITS := 0xFFFFFFFF;
MAX64BITS := 0xFFFFFFFFFFFFFFFF;
MAX8POS   := 0x7F;
MAX8NEG   := 0x80;
MAX16POS  := 0x7FFF;
MAX16NEG  := 0x8000;
MAX32POS  := 0x7FFFFFFF;
MAX32NEG  := 0x80000000;

ENDIANNESS LITTLE;

INTEGER
[ %eax, %ecx, %edx, %ebx,
  %esp, %ebp, %esi, %edi ][32] -> 24..31,
%ax[16] -> 0 SHARES %eax@[0..15],
%cx[16] -> 1 SHARES %ecx@[0..15],
%dx[16] -> 2 SHARES %edx@[0..15],
%bx[16] -> 3 SHARES %ebx@[0..15],
%sp[16] -> 4 SHARES %esp@[0..15],
%bp[16] -> 5 SHARES %ebp@[0..15],
%si[16] -> 6 SHARES %esi@[0..15],
%di[16] -> 7 SHARES %edi@[0..15],
%al[8]  -> 8 SHARES %ax@[0..7],
%cl[8]  -> 9 SHARES %cx@[0..7],
%dl[8]  -> 10 SHARES %dx@[0..7],
%bl[8]  -> 11 SHARES %bx@[0..7],
%ah[8]  -> 12 SHARES %ax@[8..15],
%ch[8]  -> 13 SHARES %cx@[8..15],
%dh[8]  -> 14 SHARES %dx@[8..15],
%bh[8]  -> 15 SHARES %bx@[8..15],
%cs[16]  -> 16,
%ss[16]  -> 17,
%ds[16]  -> 18,
%es[16]  -> 19,
%fs[16]  -> 20,
%gs[16]  -> 21,
%pc[32] -> -1,
[ %NF, %ZF, %AF, %PF,
  %CF, %OF, %DF, %IF,
  %SKIP, %RPT, %FLF,
  %C2, %FZF ][1] -> -1;

FLOAT
[ %st0, %st1,        # stack head, stack neck
  %st2, %st3, %st4, %st5, %st6, %st7 ][80] -> 32..39;

INTEGER
%fsw[16] -> 40, #Float status word(16 Bit register Containing information about
                #The state of the FPU.  stores the top of stack pointer
                #information aswell as the exception flags and stack fault
                #information)

%fstp[3] -> 41, #Floating point stack pointer.  Holds the top of stack pointer.
                #NB is bits 11->13 inclusive of the fsw(defined above).

%fcw[16] -> 42; #Floating point Control Word (16 bit register holding
                #information such as the infinity control, rounding control,
                #precision control and exception masks.

# Note: 16-bit addressing forms not implemented - these are all for 32-bit
# addressing modes.

OPERAND	modrm32 := { Indir_32, Disp8_32, Disp32_32, Abs32_32, Reg_32, Index_32, 
		     Base_32, Index8_32, Base8_32, Index32_32, Base32_32, 
		     ShortIndex_32, IndirMem_32 },
	modrm16 := { Indir_16, Disp8_16, Disp32_16, Abs32_16, Reg_16, Index_16, 
		     Base_16, Index8_16, Base8_16, Index32_16, Base32_16, 
		     ShortIndex_16, IndirMem_16 },
	modrm8  := { Indir_8, Disp8_8, Disp32_8, Abs32_8, Reg_8, Index_8, 
		     Base_8, Index8_8, Base8_8, Index32_8, Base32_8, 
		     ShortIndex_8, IndirMem_8 },
        mem := { Indir, Disp8, Disp32, Abs32, Index, Base, Index8, Base8, 
                     Index32, Base32, ShortIndex, IndirMem };

OPERAND Indir         r32			*32* r[r32],
	Disp8         i8, r32			*32* r[r32] + sgnex(8,32,i8),
	Disp32        i32, r32			*32* r[r32] + i32,
	Abs32         i32			*32* i32,
	Index         base, index, ss		*32* r[base] + (r[index] << ss),
	Base          base			*32* r[base],
	Index8        i8, base, index, ss	*32* r[base] + (r[index] << ss) + sgnex(8,32,i8),
	Base8         i8, base			*32* r[base] + sgnex(8,32,i8),
	Index32       i32, base, index, ss	*32* r[base] + (r[index] << ss) + i32,
	Base32        i32, base			*32* r[base] + i32,
	ShortIndex    i32, index, ss		*32* (r[index] << ss) + i32,
	IndirMem      i32			*32* i32;

OPERAND Indir_32      r32			*32* m[ r[r32] ],
	Disp8_32      i8, r32			*32* m[ r[r32] + sgnex(8,32,i8) ],
	Disp32_32     i32, r32			*32* m[ r[r32] + i32 ],
	Abs32_32      i32			*32* m[ i32 ],
	Reg_32        r32			*32* r[r32],
	Index_32      base, index, ss		*32* m[ r[base] + (r[index] << ss) ],
	Base_32       base			*32* m[ r[base] ],
	Index8_32     i8, base, index, ss	*32* m[ r[base] + (r[index] << ss) + sgnex(8,32,i8) ],
	Base8_32      i8, base			*32* m[ r[base] + sgnex(8,32,i8) ],
	Index32_32    i32, base, index, ss	*32* m[ r[base] + (r[index] << ss) + i32 ],
	Base32_32     i32, base			*32* m[ r[base] + i32 ],
	ShortIndex_32 i32, index, ss		*32* m[ (r[index] << ss) + i32 ],
	IndirMem_32   i32			*32* m[ i32 ];

OPERAND Indir_16      r32			*16* m[ r[r32] ],
	Disp8_16      i8, r32			*16* m[ r[r32] + sgnex(8,32,i8) ],
	Disp32_16     i32, r32			*16* m[ r[r32] + i32 ],
	Abs32_16      i32			*16* m[ i32 ],
	Reg_16        r16			*16* r[r16],
	Index_16      base, index, ss		*16* m[ r[base] + (r[index] << ss) ],
	Base_16       base			*16* m[ r[base] ],
	Index8_16     i8, base, index, ss	*16* m[ r[base] + (r[index] << ss) + sgnex(8,32,i8) ],
	Base8_16      i8, base			*16* m[ r[base] + sgnex(8,32,i8) ],
	Index32_16    i32, base, index, ss	*16* m[ r[base] + (r[index] << ss) + i32 ],
	Base32_16     i32, base			*16* m[ r[base] + i32 ],
	ShortIndex_16 i32, index, ss		*16* m[ (r[index] << ss) + i32 ],
	IndirMem_16   i32			*16* m[ i32 ];

OPERAND Indir_8       r32			*8*  m[ r[r32] ],
	Disp8_8       i8, r32			*8*  m[ r[r32] + sgnex(8,32,i8) ],
	Disp32_8      i32, r32			*8*  m[ r[r32] + i32 ],
	Abs32_8       i32			*8*  m[ i32 ],
	Reg_8         r8			*8*  r[r8],
	Index_8       base, index, ss		*8*  m[ r[base] + (r[index] << ss) ],
	Base_8        base			*8*  m[ r[base] ],
	Index8_8      i8, base, index, ss	*8*  m[ r[base] + (r[index] << ss) + sgnex(8,32,i8) ],
	Base8_8       i8, base			*8*  m[ r[base] + sgnex(8,32,i8) ],
	Index32_8     i32, base, index, ss	*8*  m[ r[base] + (r[index] << ss) + i32 ],
	Base32_8      i32, base			*8*  m[ r[base] + i32 ],
	ShortIndex_8  i32, index, ss		*8*  m[ (r[index] << ss) + i32 ],
	IndirMem_8    i32			*8*  m[ i32 ];



ADDFLAGS8(op1, op2, result)  {
            *1* %CF := ((op1@[7:7]) & (op2@[7:7]))
                        | (~(result@[7:7]) & ((op1@[7:7]) | (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) & (op2@[7:7]) & ~(result@[7:7]))
                        | (~(op1@[7:7]) & ~(op2@[7:7]) & (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS16(op1, op2, result)  {
            *1* %CF := ((op1@[15:15]) & (op2@[15:15]))
                        | (~(result@[15:15]) & ((op1@[15:15]) | (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) & (op2@[15:15]) & ~(result@[15:15]))
                        | (~(op1@[15:15]) & ~(op2@[15:15]) & (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS32(op1, op2, result)  {
            *1* %CF := ((op1@[31:31]) & (op2@[31:31]))
                        | (~(result@[31:31]) & ((op1@[31:31]) | (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) & (op2@[31:31]) & ~(result@[31:31]))
                        | (~(op1@[31:31]) & ~(op2@[31:31]) & (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS8(op1, op2, result)  {
            *1* %CF := (~(op1@[7:7]) & (op2@[7:7]))
                        | ((result@[7:7]) & (~(op1@[7:7]) | (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) & ~(op2@[7:7]) & ~(result@[7:7]))
                        | (~(op1@[7:7]) & (op2@[7:7]) & (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS16(op1, op2, result)  {
            *1* %CF := (~(op1@[15:15]) & (op2@[15:15]))
                        | ((result@[15:15]) & (~(op1@[15:15]) | (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) & ~(op2@[15:15]) & ~(result@[15:15]))
                        | (~(op1@[15:15]) & (op2@[15:15]) & (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#       *1*  %PF := ??
#       *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS32(op1, op2, result)  {
            *1* %CF := (~(op1@[31:31]) & (op2@[31:31]))
                        | ((result@[31:31]) & (~(op1@[31:31]) | (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) & ~(op2@[31:31]) & ~(result@[31:31]))
                        | (~(op1@[31:31]) & (op2@[31:31]) & (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

LOGICALFLAGS8(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[7:7]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS16(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[15:15]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS32(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[31:31]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

IMULTFLAGS8(result)  {
            *1* %CF := [(result@[8:15] = 0)?1:0]
            *1* %OF := [(result@[8:15] = 0)?1:0]
};

IMULTFLAGS16(result)  {
            *1* %CF := [(result@[16:31] = 0)?1:0]
            *1* %OF := [(result@[16:31] = 0)?1:0]
};

IMULTFLAGS32(result)  {
            *1* %CF := [(result@[32:63] = 0)?1:0]
            *1* %OF := [(result@[32:63] = 0)?1:0]
};

MULTFLAGS8(result)  {
            *1* %CF := [result@[8:15] ~= 0?1:0]
            *1* %OF := [result@[8:15] ~= 0?1:0]
};

MULTFLAGS16(result)  {
            *1* %CF := [result@[16:31] ~= 0?1:0]
            *1* %OF := [result@[16:31] ~= 0?1:0]
};

MULTFLAGS32(result)  {
            *1* %CF := [result@[32:63] ~= 0?1:0]
            *1* %OF := [result@[32:63] ~= 0?1:0]
};

ROLFLAGS8(result, op1, count)  {
            *1* %CF := result@[7:7]
            *1* %OF := [count = 1?op1@[7:7] ^ %CF :-1]
};

ROLFLAGS16(result, op1, count)  {
            *1* %CF := result@[15:15]
            *1* %OF := [count = 1?op1@[15:15] ^ %CF:-1]
};

ROLFLAGS32(result, op1, count)  {
            *1* %CF := result@[31:31]
            *1* %OF := [count = 1?op1@[31:31] ^ %CF:-1]
};

RORFLAGS8(result, op1, count)  {
            *1* %CF := result@[7:7]
            *1* %OF := [count = 1?op1@[7:7] ^ (op1@[6:6]):-1]
};

RORFLAGS16(result, op1, count)  {
            *1* %CF := result@[15:15]
            *1* %OF := [count = 1?op1@[15:15] ^ (op1@[14:14]):-1]
};

RORFLAGS32(result, op1, count)  {
            *1* %CF := result@[31:31]
            *1* %OF := [count = 1?op1@[31:31] ^ (op1@[30:30]):-1]
};

SALFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(8 - count):(8 - count)]
            *1* %OF := [count = 1?result@[7:7] ^ %CF:-1]
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
};

SALFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(16 - count):(16 - count)]
            *1* %OF := [count = 1?result@[15:15] ^ %CF:-1]
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
};

SALFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(32 - count):(32 - count)]
            *1* %OF := [count = 1?result@[31:31] ^ %CF:-1]
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
};

SARFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?0:-1]
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
};
SARFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?0:-1]
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
};
SARFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?0:-1]
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
};

SHRFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?result@[7:7] ^ %CF:-1]
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
};

SHRFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?result@[15:15] ^ %CF:-1]
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
};

SHRFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?result@[31:31] ^ %CF:-1]
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
};

SHLDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(32 - count):(32 - count)]
            *1* %OF := [count = 1?result@[31:31] ^ %CF:-1]
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
};

SHLDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(64 - count):(64 - count)]
            *1* %OF := [count = 1?result@[63:63] ^ %CF:-1]
            *1* %NF := result@[63:63]
            *1* %ZF := [result = 0?1:0]
};

SHRDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?result@[31:31] ^ %CF:-1]
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
};

SHRDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?result@[63:63] ^ %CF:-1]
            *1* %NF := result@[63:63]
            *1* %ZF := [result = 0?1:0]
};

SETFFLAGS(op1, op2)  {
            *1* %FZF := [(op1 = op2) ? 1 : 0]
            *1* %FLF := [(op1 < op2) ? 1 : 0]
            *1* %C2 := 0 # [ (op1 > op2) ? 1 : 0]
};

TRAP(cond, op1) {
            *32* %eax := %pc
};

FETCHEXEC   *1*  %CTI := 0
            *32* r[tmp] := execute( %pc )
            *32* %pc := [%CTI = 0 ? r[tmp] : %pc ];

OP1 := { "+", "-" };
ARIT := { "ADD", "SUB" };

ARIT[IDX]^"IAL" i8 
            *8* r[tmpb] := %al
            *8* %al := %al OP1[IDX] i8;
ADD.IAL   i8 ADDFLAGS8(r[tmpb], i8, %al);
SUB.IAL   i8 SUBFLAGS8(r[tmpb], i8, %al);

ARIT[IDX]^"IAX" i16 
            *16* r[tmph] := %ax
            *16* %ax := %ax OP1[IDX] i16;
ADD.IAX   i16 ADDFLAGS16(r[tmph], i16, %ax);
SUB.IAX   i16 SUBFLAGS16(r[tmph], i16, %ax);

ARIT[IDX]^"IEAX" i32 
            *32* r[tmp1] := %eax
            *32* %eax := %eax OP1[IDX] i32;
ADD.IEAX   i32 ADDFLAGS32(r[tmp1], i32, %eax);
SUB.IEAX   i32 SUBFLAGS32(r[tmp1], i32, %eax);

ARIT[IDX]^"ID" modrm32, i32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := modrm32 OP1[IDX] i32;
ADD.ID   modrm32, i32 ADDFLAGS32(r[tmp1], i32, modrm32);
SUB.ID   modrm32, i32 SUBFLAGS32(r[tmp1], i32, modrm32);

ARIT[IDX]^"IW" modrm16, i16 
            *16* r[tmph] := modrm16
            *16* modrm16 := modrm16 OP1[IDX] i16;
ADD.IW   modrm16, i16 ADDFLAGS16(r[tmph], i16, modrm16);
SUB.IW   modrm16, i16 SUBFLAGS16(r[tmph], i16, modrm16);

ARIT[IDX]^"IB" modrm8, i8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := modrm8 OP1[IDX] i8;
ADD.IB   modrm8, i8 ADDFLAGS8(r[tmpb], i8, modrm8);
SUB.IB   modrm8, i8 SUBFLAGS8(r[tmpb], i8, modrm8);

ARIT[IDX]^"IOWB" modrm16, i8 
            *16* r[tmph] := modrm16
            *16* r[tmph2] := sgnex(8,16,i8)
            *16* modrm16 := modrm16 OP1[IDX] r[tmph2];
ADD.IOWB   modrm16, i8 ADDFLAGS16(r[tmph], r[tmph2], modrm16);
SUB.IOWB   modrm16, i8 SUBFLAGS16(r[tmph], r[tmph2], modrm16);

ARIT[IDX]^"IODB" modrm32, i8 
            *32* r[tmp1] := modrm32
            *32* r[tmp2] := sgnex(8,32,i8)
            *32* modrm32 := modrm32 OP1[IDX] r[tmp2];
ADD.IODB   modrm32, i8 ADDFLAGS32(r[tmp1], r[tmp2], modrm32);
SUB.IODB   modrm32, i8 SUBFLAGS32(r[tmp1], r[tmp2], modrm32);

ARIT[IDX]^"MRB" modrm8, r8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := r[tmpb] OP1[IDX] r[r8];
ADD.MRB   modrm8, r8 ADDFLAGS8(r[tmpb], r[r8], modrm8);
SUB.MRB   modrm8, r8 SUBFLAGS8(r[tmpb], r[r8], modrm8);

ARIT[IDX]^"MROW" modrm16, r16 
            *16* r[tmph] := modrm16
            *16* modrm16 := r[tmph] OP1[IDX] r[r16];
ADD.MROW   modrm16, r16 ADDFLAGS16(r[tmph], r[r16], modrm16);
SUB.MROW   modrm16, r16 SUBFLAGS16(r[tmph], r[r16], modrm16);

ARIT[IDX]^"MROD" modrm32, r32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := modrm32 OP1[IDX] r[r32];
ADD.MROD   modrm32, r32 ADDFLAGS32(r[tmp1], r[r32], modrm32);
SUB.MROD   modrm32, r32 SUBFLAGS32(r[tmp1], r[r32], modrm32);

ARIT[IDX]^"RMB" r8, modrm8 
            *8* r[tmpb] := r[r8]
            *8* r[r8] := r[r8] OP1[IDX] modrm8;
ADD.RMB   r8, modrm8 ADDFLAGS8(r[tmpb], modrm8, r[r8]);
SUB.RMB   r8, modrm8 SUBFLAGS8(r[tmpb], modrm8, r[r8]);

ARIT[IDX]^"RMOW" r16, modrm16 
            *16* r[tmph] := r[r16]
            *16* r[r16] := r[r16] OP1[IDX] modrm16;
ADD.RMOW   r16, modrm16 ADDFLAGS16(r[tmph], modrm16, r[r16]);
SUB.RMOW   r16, modrm16 SUBFLAGS16(r[tmph], modrm16, r[r16]);

ARIT[IDX]^"RMOD" r32, modrm32 
            *32* r[tmp1] := r[r32]
            *32* r[r32] := r[r32] OP1[IDX] modrm32;
ADD.RMOD   r32, modrm32 ADDFLAGS32(r[tmp1], modrm32, r[r32]);
SUB.RMOD   r32, modrm32 SUBFLAGS32(r[tmp1], modrm32, r[r32]);

CMP.IAL   i8 
            *8* r[tmpb] := %al - i8
            SUBFLAGS8(%al, i8, r[tmpb]);

CMP.IAX   i16 
            *16* r[tmph] := %ax - i16
            SUBFLAGS16(%ax, i16, r[tmph]);

CMP.IEAX   i32 
            *32* r[tmp1] := %eax - i32
            SUBFLAGS32(%eax, i32, r[tmp1]);

CMP.ID   modrm32, i32 
            *32* r[tmp1] := modrm32 - i32
            SUBFLAGS32(modrm32, i32, r[tmp1]);

CMP.IW   modrm16, i16 
            *16* r[tmph] := modrm16 - i16
            SUBFLAGS16(modrm16, i16, r[tmph]);

CMP.IB   modrm8, i8 
            *8* r[tmpb] := modrm8 - i8
            SUBFLAGS8(modrm8, i8, r[tmpb]);

CMP.MRB   modrm8, r8 
            *8* r[tmpb] := modrm8 - r[r8]
            SUBFLAGS8(modrm8, r[r8], r[tmpb]);

CMP.RMB   r8, modrm8 
            *8* r[tmpb] := r[r8] - modrm8
            SUBFLAGS8(r[r8], modrm8, r[tmpb]);

CMP.IODB   modrm32, i8
            *32* r[tmp2] := sgnex(8,32,i8)
            *32* r[tmp1] := modrm32 - r[tmp2]
            SUBFLAGS32(modrm32, r[tmp2], r[tmp1]);

CMP.IOWB   modrm16, i8 
            *16* r[tmph2] := sgnex(8,16,i8)
            *16* r[tmph] := modrm16 - r[tmph2]
            SUBFLAGS16(modrm16, r[tmph2], r[tmph]);

CMP.MROW   modrm16, r16 
            *16* r[tmph] := modrm16 - r[r16]
            SUBFLAGS16(modrm16, r[r16], r[tmph]);

CMP.MROD   modrm32, r32 
            *32* r[tmp1] := modrm32 - r[r32]
            SUBFLAGS32(modrm32, r[r32], r[tmp1]);

CMP.RMOW   r16, modrm16 
            *16* r[tmph] := r[r16] - modrm16
            SUBFLAGS16(r[r16], modrm16, r[tmph]);

CMP.RMOD   r32, modrm32 
            *32* r[tmp1] := r[r32] - modrm32
            SUBFLAGS32(r[r32], modrm32, r[tmp1]);

OP1 := { "&", "|", "^" };
LOG := { "AND", "OR", "XOR" };

LOG[IDX]^"IAL" i8 
            *8* %al := %al OP1[IDX] i8
            LOGICALFLAGS8(%al);

LOG[IDX]^"IAX" i16 
            *16* %ax := %ax OP1[IDX] i16
            LOGICALFLAGS16(%ax);

LOG[IDX]^"IEAX" i32 
            *32* %eax := %eax OP1[IDX] i32
            LOGICALFLAGS32(%eax);

LOG[IDX]^"ID" modrm32, i32 
            *32* modrm32 := modrm32 OP1[IDX] i32
            LOGICALFLAGS32(modrm32);

LOG[IDX]^"IW" modrm16, i16 
            *16* modrm16 := modrm16 OP1[IDX] i16
            LOGICALFLAGS16(modrm16);

LOG[IDX]^"IB" modrm8, i8 
            *8* modrm8 := modrm8 OP1[IDX] i8
            LOGICALFLAGS8(modrm8);

LOG[IDX]^"IOWB" modrm16, i8 
            *16* modrm16 := modrm16 OP1[IDX] sgnex(8,16,i8)
            LOGICALFLAGS16(modrm16);

LOG[IDX]^"IODB" modrm32, i8 
            *32* modrm32 := modrm32 OP1[IDX] sgnex(8,32,i8)
            LOGICALFLAGS32(modrm32);

LOG[IDX]^"MRB" modrm8, r8 
            *8* modrm8 := modrm8 OP1[IDX] r[r8]
            LOGICALFLAGS8(modrm8);

LOG[IDX]^"MROW" modrm16, r16 
            *16* modrm16 := modrm16 OP1[IDX] r[r16]
            LOGICALFLAGS16(modrm16);

LOG[IDX]^"MROD" modrm32, r32 
            *32* modrm32 := modrm32 OP1[IDX] r[r32]
            LOGICALFLAGS32(modrm32);

LOG[IDX]^"RMB" r8, modrm8 
            *8* r[r8] := r[r8] OP1[IDX] modrm8
            LOGICALFLAGS8(r[r8]);

LOG[IDX]^"RMOW" r16, modrm16 
            *16* r[r16] := r[r16] OP1[IDX] modrm16
            LOGICALFLAGS16(r[r16]);

LOG[IDX]^"RMOD" r32, modrm32 
            *32* r[r32] := r[r32] OP1[IDX] modrm32
            LOGICALFLAGS32(r[r32]);

OP2 := { "+", "-" };
ARITH_C := { "ADC", "SBB" };

ARITH_C[IDX]^"IAL" i8 
            *8* r[tmpb] := %al
            *8* %al := %al OP2[IDX] i8 OP2[IDX] zfill(1,8,%CF);
ADC.IAL   i8 ADDFLAGS8(r[tmpb], i8, %al);
SBB.IAL   i8 SUBFLAGS8(r[tmpb], i8, %al);
ARITH_C[IDX]^"IAL"   i8 _;

ARITH_C[IDX]^"IAX" i16 
            *16* r[tmph] := %ax
            *16* %ax := %ax OP2[IDX] i16 OP2[IDX] zfill(1,16,%CF);
ADCIAX   i16 ADDFLAGS16(r[tmph], i16, %ax);
SBBIAX   i16 SUBFLAGS16(r[tmph], i16, %ax);

ARITH_C[IDX]^"IEAX" i32 
            *32* r[tmp1] := %eax
            *32* %eax := %eax OP2[IDX] i32 OP2[IDX] zfill(1,32,%CF);
ADC.IEAX   i32 ADDFLAGS32(r[tmp1], i32, %eax);
SBB.IEAX   i32 SUBFLAGS32(r[tmp1], i32, %eax);

ARITH_C[IDX]^"ID" r32, i32 
            *32* r[tmp1] := r[r32]
            *32* r[r32] := r[r32] OP2[IDX] i32 OP2[IDX] zfill(1,32,%CF);
ADC.ID   r32, i32 ADDFLAGS32(r[tmp1], i32, r[r32]);
SBB.ID   r32, i32 SUBFLAGS32(r[tmp1], i32, r[r32]);

ARITH_C[IDX]^"IW" r16, i16 
            *16* r[tmph] := r[r16]
            *16* r[r16] := r[r16] OP2[IDX] i16 OP2[IDX] zfill(1,16,%CF);
ADC.IW   r16, i16 ADDFLAGS16(r[tmph], i16, r[r16]);
SBB.IW   r16, i16 SUBFLAGS16(r[tmph], i16, r[r16]);

ARITH_C[IDX]^"IB" modrm8, i8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := modrm8 OP2[IDX] i8 OP2[IDX] zfill(1,8,%CF);
ADC.IB   modrm8, i8 ADDFLAGS8(r[tmpb], i8, modrm8);
SBB.IB   modrm8, i8 SUBFLAGS8(r[tmpb], i8, modrm8);

ARITH_C[IDX]^"IOWB" modrm16, i8 
            *16* r[tmph1] := modrm16
            *16* r[tmph2] := sgnex(8,16,i8)
            *16* modrm16 := modrm16 OP2[IDX] r[tmph2] OP2[IDX] zfill(1,16,%CF);
ADC.IOWB   modrm16, i8 ADDFLAGS16(r[tmph1], r[tmph2], modrm16);
SBB.IOWB   modrm16, i8 SUBFLAGS16(r[tmph1], r[tmph2], modrm16);

ARITH_C[IDX]^"IODB" modrm32, i8 
            *32* r[tmp1] := modrm32
            *32* r[tmp2] := sgnex(8,32,i8)
            *32* modrm32 := r[tmp1] OP2[IDX] r[tmp2] OP2[IDX] zfill(1,32,%CF);
ADC.IODB   modrm32, i8 ADDFLAGS32(r[tmp1], r[tmp2], modrm32);
SBB.IODB   modrm32, i8 SUBFLAGS32(r[tmp1], r[tmp2], modrm32);

ARITH_C[IDX]^"MRB" modrm8, r8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := r[tmpb] OP2[IDX] r[r8] OP2[IDX] zfill(1,8,%CF);
ADC.MRB   modrm8, r8 ADDFLAGS8(r[tmpb], r[r8], modrm8);
SBB.MRB   modrm8, r8 SUBFLAGS8(r[tmpb], r[r8], modrm8);

ARITH_C[IDX]^"MROW" modrm16, r16 
            *16* r[tmph] := modrm16
            *16* modrm16 := r[tmph] OP2[IDX] r[r16] OP2[IDX] zfill(1,16,%CF);
ADC.MROW   modrm16, r16 ADDFLAGS16(r[tmph], r[r16], modrm16);
SBB.MROW   modrm16, r16 SUBFLAGS16(r[tmph], r[r16], modrm16);

ARITH_C[IDX]^"MROD" modrm32, r32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := modrm32 OP2[IDX] r[r32] OP2[IDX] zfill(1,32,%CF);
ADC.MROD   modrm32, r32 ADDFLAGS32(r[tmp1], r[r32], modrm32);
SBB.MROD   modrm32, r32 SUBFLAGS32(r[tmp1], r[r32], modrm32);

ARITH_C[IDX]^"RMB" r8, modrm8 
            *8* r[tmpb] := r[r8]
            *8* r[r8] := r[r8] OP2[IDX] modrm8 OP2[IDX] zfill(1,8,%CF);
ADC.RMB   r8, modrm8 ADDFLAGS8(r[tmpb], modrm8, r[r8]);
SBB.RMB   r8, modrm8 SUBFLAGS8(r[tmpb], modrm8, r[r8]);

ARITH_C[IDX]^"RMOW" r16, modrm16 
            *16* r[tmph] := r[r16]
            *16* r[r16] := r[r16] OP2[IDX] modrm16 OP2[IDX] zfill(1,16,%CF);
ADC.RMOW   r16, modrm16 ADDFLAGS16(r[tmph], modrm16, r[r16]);
SBB.RMOW   r16, modrm16 SUBFLAGS16(r[tmph], modrm16, r[r16]);

ARITH_C[IDX]^"RMOD" r32, modrm32
            *32* r[tmp1] := r[r32]
            *32* r[r32] := r[r32] OP2[IDX] modrm32 OP2[IDX] zfill(1,32,%CF);
ADC.RMOD   r32, modrm32 ADDFLAGS32(r[tmp1], modrm32, r[r32]);
SBB.RMOD   r32, modrm32 SUBFLAGS32(r[tmp1], modrm32, r[r32]);

BT.od   modrm32, r32 
            *1* %CF := modrm32@[r[r32]:r[r32]];

BT.iod  modrm32, i8
            *1* %CF := modrm32@[i8:i8];

BTR.od   modrm32, r32 
            *32* r[tmp1] := 1 << r[r32]
            *1* %CF := modrm32@[r[r32]:r[r32]]
            *32* modrm32 := modrm32 & (0 - r[tmp1] - 1);

BTR.iod   modrm32, i8
            *32* r[tmp1] := 1 << i8
            *1* %CF := modrm32@[i8:i8]
            *32* modrm32 := modrm32 & (0 - r[tmp1] - 1);

BTC.od   modrm32, r32 
            *32* r[tmp1] := 1 << r[r32]
            *1* %CF := modrm32@[r[r32]:r[r32]]
            *32* modrm32 := modrm32 ^ r[tmp1];

BTC.iod   modrm32, i8
            *32* r[tmp1] := 1 << i8
            *1* %CF := modrm32@[i8:i8]
            *32* modrm32 := modrm32 ^ r[tmp1];

BTS.od   modrm32, r32 
            *32* r[tmp1] := 1 << r[r32]
            *1* %CF := modrm32@[r[r32]:r[r32]]
            *32* modrm32 := modrm32 | r[tmp1];

BTS.iod   modrm32, i8
            *32* r[tmp1] := 1 << i8
            *1* %CF := modrm32@[i8:i8]
            *32* modrm32 := modrm32 | r[tmp1];

BT.ow   modrm16, r16 
            *1* %CF := modrm16@[r[r16]:r[r16]];

BT.iow  modrm16, i8
            *1* %CF := modrm16@[i8:i8];

BTR.ow   modrm16, r16 
            *16* r[tmph] := 1 << r[r16]
            *1* %CF := modrm16@[r[r16]:r[r16]]
            *16* modrm16 := modrm16 & (0 - r[tmph] - 1);

BTR.iow   modrm16, i8
            *16* r[tmph] := 1 << i8
            *1* %CF := modrm16@[i8:i8]
            *16* modrm16 := modrm16 & (0 - r[tmph] - 1);

BTC.ow   modrm16, r16 
            *16* r[tmph] := 1 << r[r16]
            *1* %CF := modrm16@[r[r16]:r[r16]]
            *16* modrm16 := modrm16 ^ r[tmph];

BTC.iow   modrm16, i8
            *16* r[tmph] := 1 << i8
            *1* %CF := modrm16@[i8:i8]
            *16* modrm16 := modrm16 ^ r[tmph];

BTS.ow   modrm16, r16 
            *16* r[tmph] := 1 << r[r16]
            *1* %CF := modrm16@[r[r16]:r[r16]]
            *16* modrm16 := modrm16 | r[tmph];

BTS.iow   modrm16, i8
            *16* r[tmph] := 1 << i8
            *1* %CF := modrm16@[i8:i8]
            *16* modrm16 := modrm16 | r[tmph];

# Yes, this is disgustingly verbose. The reader is invited to devise a more
# compact/elegant representation of these operations...
BSF.od    r32, modrm32
            *1* %ZF := [ modrm32 = 0 ? 1 : 0 ]
            *32* r[r32] := [ modrm32@[0:15] ~= 0 ?
                             [ modrm32@[0:7] ~= 0 ?
                               [ modrm32@[0:3] ~= 0 ?
                                 [ modrm32@[0:1] ~= 0 ?
                                   [ modrm32@[0:0] ~= 0 ?  0 :  1 ] :
                                   [ modrm32@[2:2] ~= 0 ?  2 :  3 ] ] :
                                 [ modrm32@[4:5] ~= 0 ?
                                   [ modrm32@[4:4] ~= 0 ?  4 :  5 ] :
                                   [ modrm32@[6:6] ~= 0 ?  6 :  7 ] ] ] :
                               [ modrm32@[8:11] ~= 0 ?
                                 [ modrm32@[8:9] ~= 0 ?
                                   [ modrm32@[8:8] ~= 0 ?  8 : 9 ] :
                                   [ modrm32@[10:10] ~= 0 ? 10 : 11 ] ] :
                                 [ modrm32@[12:13] ~= 0 ?
                                   [ modrm32@[12:12] ~= 0 ? 12 : 13 ] :
                                   [ modrm32@[14:14] ~= 0 ? 14 : 15 ] ] ] ] :
                             [ modrm32@[16:23] ~= 0 ?
                               [ modrm32@[16:19] ~= 0 ?
                                 [ modrm32@[16:17] ~= 0 ?
                                   [ modrm32@[16:16] ~= 0 ? 16 : 17 ] :
                                   [ modrm32@[18:18] ~= 0 ? 18 : 19 ] ] :
                                 [ modrm32@[20:21] ~= 0 ?
                                   [ modrm32@[20:20] ~= 0 ? 20 : 21 ] :
                                   [ modrm32@[22:22] ~= 0 ? 22 : 23 ] ] ] :
                               [ modrm32@[24:27] ~= 0 ?
                                 [ modrm32@[24:25] ~= 0 ?
                                   [ modrm32@[24:24] ~= 0 ? 24 : 25 ] :
                                   [ modrm32@[26:26] ~= 0 ? 26 : 27 ] ] :
                                 [ modrm32@[28:29] ~= 0 ?
                                   [ modrm32@[28:28] ~= 0 ? 28 : 29 ] :
                                   [ modrm32@[30:30] ~= 0 ? 30 : 
                                     [modrm32@[31:31] ~= 0 ? 31 : r[r32] ] ] ] ] ] ];
                              
BSF.ow    r16, modrm16
            *1* %ZF := [ modrm16 = 0 ? 1 : 0 ]
            *16* r[r16] := [ modrm16@[0:7] ~= 0 ?
                             [ modrm16@[0:3] ~= 0 ?
                               [ modrm16@[0:1] ~= 0 ?
                                 [ modrm16@[0:0] ~= 0 ?  0 :  1 ] :
                                 [ modrm16@[2:2] ~= 0 ?  2 :  3 ] ] :
                               [ modrm16@[4:5] ~= 0 ?
                                 [ modrm16@[4:4] ~= 0 ?  4 :  5 ] :
                                 [ modrm16@[6:6] ~= 0 ?  6 :  7 ] ] ] :
                             [ modrm16@[8:11] ~= 0 ?
                               [ modrm16@[8:9] ~= 0 ?
                                 [ modrm16@[8:8] ~= 0 ?  8 : 9 ] :
                                 [ modrm16@[10:10] ~= 0 ? 10 : 11 ] ] :
                               [ modrm16@[12:13] ~= 0 ?
                                 [ modrm16@[12:12] ~= 0 ? 12 : 13 ] :
                                 [ modrm16@[14:14] ~= 0 ? 14 : 
                                   [ modrm16@[15:15] ~= 0 ? 15 : r[16] ] ] ] ] ];
                              
BSR.od    r32, modrm32
            *1* %ZF := [ modrm32 = 0 ? 1 : 0 ]
            *32* r[r32] := [ modrm32@[16:31] ~= 0 ?
                             [ modrm32@[24:31] ~= 0 ?
                               [ modrm32@[28:31] ~= 0 ?
                                 [ modrm32@[30:31] ~= 0 ?
                                   [ modrm32@[31:31] ~= 0 ? 31 : 30 ] :
                                   [ modrm32@[29:29] ~= 0 ? 29 : 28 ] ] :
                                 [ modrm32@[26:27] ~= 0 ?
                                   [ modrm32@[27:27] ~= 0 ? 27 : 26 ] :
                                   [ modrm32@[25:25] ~= 0 ? 25 : 24 ] ] ] :
                               [ modrm32@[20:23] ~= 0 ?
                                 [ modrm32@[22:23] ~= 0 ?
                                   [ modrm32@[23:23] ~= 0 ? 23 : 22 ] :
                                   [ modrm32@[21:21] ~= 0 ? 21 : 20 ] ] :
                                 [ modrm32@[18:19] ~= 0 ?
                                   [ modrm32@[19:19] ~= 0 ? 19 : 18 ] :
                                   [ modrm32@[17:17] ~= 0 ? 17 : 16 ] ] ] ] :
                             [ modrm32@[8:15] ~= 0 ?
                               [ modrm32@[12:15] ~= 0 ?
                                 [ modrm32@[14:15] ~= 0 ?
                                   [ modrm32@[15:15] ~= 0 ? 15 : 14 ] :
                                   [ modrm32@[13:13] ~= 0 ? 13 : 12 ] ] :
                                 [ modrm32@[10:11] ~= 0 ?
                                   [ modrm32@[11:11] ~= 0 ? 11 : 10 ] :
                                   [ modrm32@[9:9] ~= 0 ?  9 :  8 ] ] ] :
                               [ modrm32@[4:7] ~= 0 ?
                                 [ modrm32@[6:7] ~= 0 ?
                                   [ modrm32@[7:7] ~= 0 ?  7 :  6 ] :
                                   [ modrm32@[5:5] ~= 0 ?  5 :  4 ] ] :
                                 [ modrm32@[2:3] ~= 0 ?
                                   [ modrm32@[3:3] ~= 0 ?  3 :  2 ] :
                                   [ modrm32@[1:1] ~= 0 ?  1 : 
                                     [modrm32@[0:0] ~= 0 ? 0 : r[r32] ] ] ] ] ] ];
                              
BSR.ow    r16, modrm16
            *1* %ZF := [ modrm16 = 0 ? 1 : 0 ]
            *16* r[r16] :=   [ modrm16@[8:15] ~= 0 ?
                               [ modrm16@[12:15] ~= 0 ?
                                 [ modrm16@[14:15] ~= 0 ?
                                   [ modrm16@[15:15] ~= 0 ? 15 : 14 ] :
                                   [ modrm16@[13:13] ~= 0 ? 13 : 12 ] ] :
                                 [ modrm16@[10:11] ~= 0 ?
                                   [ modrm16@[11:11] ~= 0 ? 11 : 10 ] :
                                   [ modrm16@[9:9] ~= 0 ?  9 :  8 ] ] ] :
                               [ modrm16@[4:7] ~= 0 ?
                                 [ modrm16@[6:7] ~= 0 ?
                                   [ modrm16@[7:7] ~= 0 ?  7 :  6 ] :
                                   [ modrm16@[5:5] ~= 0 ?  5 :  4 ] ] :
                                 [ modrm16@[2:3] ~= 0 ?
                                   [ modrm16@[3:3] ~= 0 ?  3 :  2 ] :
                                   [ modrm16@[1:1] ~= 0 ?  1 : 
                                     [modrm16@[0:0] ~= 0 ? 0 : r[r16] ] ] ] ] ];
                              

CALL.JVOW   reloc16 
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%pc+4)
            *32* %pc := reloc16
            *1* %CTI := 1;

CALL.JVOD   reloc32 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc+5
            *32* %pc := reloc32
            *1*  %CTI := 1;

CALL.APOD   seg, off
            *32* %esp := %esp - 2
            *16* m[%esp] := %cs
            *16* %cs := seg
            *32* %esp := %esp - 4
            *16* m[%esp] := %pc + 7
            *32* %pc := zfill(16,32,off)
            *1*  %CTI := 1;

CALL.EVOW   modrm16
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%NEXT)
            *32* %pc := zfill(16,32,modrm16)
            *1*  %CTI := 1;

CALL.EVOD   modrm32
            *32* %esp := %esp - 4
            *32* m[%esp] := %NEXT
            *32* %pc := modrm32
            *1*  %CTI := 1;

CBW    
            *16* %ax := sgnex(8,16,%al);

CWDE    
            *32* %eax := sgnex(16,32,%ax);

CLC    
            *1* %CF := 0;

CLD    
            *1* %DF := 0;

CLI    
            *1* %IF := 0;

CMC    
            *1* %CF := ~(%CF);

CMPXCHG.EB.GB   modrm8, r8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := [%al = r[tmpb]?r[r8]:r[tmpb]]
            *8* %al := [%al = r[tmpb]?%al:r[tmpb]]
            *1* %ZF := [%al = r[tmpb]?1:0];

CMPXCHG.EV.GVOW   modrm16, r16 
            *16* r[tmph] := modrm16
            *16* modrm16 := [%ax = r[tmph]?r[r16]:r[tmph]]
            *16* %ax := [%ax = r[tmph]?%ax:r[tmph]]
            *1* %ZF := [%ax = r[tmph]?1:0];

CMPXCHG.EV.GVOD   modrm32, r32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := [%eax = r[tmp1]?r[r32]:r[tmp1]]
            *32* %eax := [%eax = r[tmp1]?%eax:r[tmp1]]
            *1* %ZF := [%eax = r[tmp1]?1:0];

CWD    
            *16* %dx := [%ax < 0?-1:0];

CDQ    
            *32* %edx := [%eax < 0?-1:0];

OP4 := { "-", "+" };
DEC_INC := { "DEC", "INC" };

DEC_INC[IDX].EB modrm8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := modrm8 OP4[IDX] 1;
DEC.EB   modrm8 SUBFLAGS8(r[tmpb], 1, modrm8);
INC.EB   modrm8 ADDFLAGS8(r[tmpb], 1, modrm8);

DEC_INC[IDX].EVOW modrm16
            *16* r[tmph] := modrm16
            *16* modrm16 := modrm16 OP4[IDX] 1;
DEC.EVOW   modrm16 SUBFLAGS16(r[tmph], 1, modrm16);
INC.EVOW   modrm16 ADDFLAGS16(r[tmph], 1, modrm16);

DEC_INC[IDX].EVOD modrm32
            *32* r[tmp1] := modrm32
            *32* modrm32 := modrm32 OP4[IDX] 1;
DEC.EVOD   modrm32 SUBFLAGS32(r[tmp1], 1, modrm32);
INC.EVOD   modrm32 ADDFLAGS32(r[tmp1], 1, modrm32);

DEC_INC[IDX].OW r16 
            *16* r[tmph] := r[r16]
            *16* r[r16] := r[r16] OP4[IDX] 1;
DEC.OW   r16 SUBFLAGS16(r[tmph], 1, r[r16]);
INC.OW   r16 ADDFLAGS16(r[tmph], 1, r[r16]);

DEC_INC[IDX].OD r32 
            *32* r[tmp1] := r[r32]
            *32* r[r32] := r[r32] OP4[IDX] 1;
DEC.OD   r32 SUBFLAGS32(r[tmp1], 1, r[r32]);
INC.OD   r32 ADDFLAGS32(r[tmp1], 1, r[r32]);

DIV.AL   modrm8 
            *16* r[tmph] := %ax
            *8* %al := truncu(16,8,r[tmph] / zfill(8,16,modrm8))
            *8* %ah := truncu(16,8,r[tmph] % zfill(8,16,modrm8))
            undefineflags( );

DIV.AX   modrm16 
            *32* r[tmp1] := (zfill(16,32,%dx) << 16) | zfill(16,32,%ax)
            *16* r[tmph] := modrm16
            *16* %ax := truncu(32,16,r[tmp1] / zfill(16,32,r[tmph]))
            *16* %dx := truncu(32,16,r[tmp1] % zfill(16,32,r[tmph]))
            undefineflags( );

DIV.EAX   modrm32 
            *64* r[tmpl] := (zfill(32,64,%edx) << 32) | zfill(32,64,%eax)
            *32* r[tmp2] := modrm32
            *32* %eax := truncu(64,32,r[tmpl] / zfill(32,64,r[tmp2]))
            *32* %edx := truncu(64,32,r[tmpl] % zfill(32,64,r[tmp2]))
            undefineflags( );

ENTER   i16, i8 
            *32* r[tmp1] := sgnex(8,32,i8)
            *32* %esp := %esp - 4
            *32* m[%esp] := %ebp
            *32* %ebp := %esp
            *32* %esp := %esp - sgnex(16,32,i16);

IDIV   modrm8 
            *16* r[tmph] := %ax
            *8* %al := truncu(16,8,r[tmph] /! sgnex(8,16,modrm8))
            *8* %ah := truncu(16,8,r[tmph] %! sgnex(8,16,modrm8))
            undefineflags( );

IDIV.AX   modrm16 
            *32* r[tmp1] := sgnex(16,32,%dx) << 16 | sgnex(16,32,%ax)
            *16* r[tmph] := modrm16
            *16* %ax := truncu(32,16,r[tmp1] /! sgnex(16,32,r[tmph]))
            *16* %dx := truncu(32,16,r[tmp1] %! sgnex(16,32,r[tmph]))
            undefineflags( );

IDIV.EAX   modrm32 
            *64* r[tmpl] := sgnex(32,64,%edx) << 32 | sgnex(32,64,%eax)
            *32* r[tmp2] := modrm32
            *32* %eax := truncu(64,32,r[tmpl] /! sgnex(32,64,r[tmp2]))
            *32* %edx := truncu(64,32,r[tmpl] %! sgnex(32,64,r[tmp2]))
            undefineflags( );

IMUL.B   modrm8 
            *16* r[tmph] := sgnex(8,16,%al) *! sgnex(8,16,modrm8)
            *16* %ax := r[tmph]
            IMULTFLAGS8(r[tmph]);

IMUL.OW   modrm16 
            *32* r[tmp2] := sgnex(16,32,%ax) *! sgnex(16,32,modrm16)
            *16* %ax := r[tmp2]@[0:15]
            *16* %dx := r[tmp2]@[16:31]
            IMULTFLAGS16(r[tmp2]);

IMUL.OD   modrm32 
            *64* r[tmpl] := sgnex(32,64,%eax) *! sgnex(32,64,modrm32)
            *32* %eax := r[tmpl]@[0:31]
            *32* %edx := r[tmpl]@[32:63]
            IMULTFLAGS32(r[tmpl]);

IMUL.RMOW   r16, modrm16 
            *32* r[tmp] := sgnex(16,32,modrm16) *! sgnex(16,32,r[r16])
            *16* r[r16] := r[tmp]@[0:15]
            IMULTFLAGS16(r[tmp]);

IMUL.RMOD   r32, modrm32 
            *64* r[tmpl] := sgnex(32,64,modrm32) *! sgnex(32,64,r[r32])
            *32* r[r32] := r[tmpl]@[0:31]
            IMULTFLAGS32(r[tmpl]);

IMUL.IVW   r16, modrm16, i16 
            *32* r[tmp] := sgnex(16,32,modrm16) *! sgnex(16,32,i16)
            *16* r[r16] := r[tmp]@[0:15]
            IMULTFLAGS16(r[tmp]);

IMUL.IVD   r32, modrm32, i32 
            *64* r[tmpl] := sgnex(32,64,modrm32) *! sgnex(32,64,i32)
            *32* r[r32] := r[tmpl]@[0:31]
            IMULTFLAGS32(r[tmpl]);

IMUL.Ibow   r16, modrm16, i8 
            *32* r[tmp] := sgnex(16,32,modrm16) *! sgnex(8,32,i8)
            *16* r[r16] := r[tmp]@[0:15]
            IMULTFLAGS16(r[tmp]);

IMUL.Ibod   r32, modrm32, i8 
            *64* r[tmpl] := sgnex(32,64,modrm32) *! sgnex(8,64,i8)
            *32* r[r32] := r[tmpl]@[0:31]
            IMULTFLAGS32(r[tmpl]);

INT.Ib      i8
            TRAP( 1 = 1, i8 );


COND1 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
            "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
            "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF",
            "~(%NF ^ %OF)", "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF",
            "(%NF ^ %OF) | %ZF", "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF",
            "~%ZF", "~%OF", "~%PF", "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP32S := { "JVAOD", "JVNBEOD", "JVAEOD", "JVNBOD", "JVBOD", "JVNAEOD", 
            "JVBEOD", "JVNAOD", "JVCOD", "JVCXZOD", "JVEOD", "JVZOD", "JVGOD",
            "JVNLEOD", "JVGEOD", "JVNLOD", "JVLOD", "JVNGEOD", "JVLEOD", 
            "JVNGOD", "JVNCOD", "JVNEOD", "JVNZOD", "JVNOOD", "JVNPOD", 
            "JVPOOD", "JVNSOD", "JVOOD", "JVPOD", "JVPEOD", "JVSOD" };

JMP32S[IDX]   reloc32 
            *32* %pc := [(COND1[IDX] = 1)?reloc32:%pc+6]
            *1*  %CTI := 1;

COND2 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
           "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
           "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF)",
           "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF", "(%NF ^ %OF) | %ZF",
           "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF", "~%ZF", "~%OF", "~%PF",
           "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };

JMP16S := { "JVAOW", "JVNBEOW", "JVAEOW", "JVNBOW", "JVBOW", "JVNAEOW", 
            "JVBEOW", "JVNAOW", "JVCOW", "JVCXZOW", "JVEOW", "JVZOW", "JVGOW",
            "JVNLEOW", "JVGEOW", "JVNLOW", "JVLOW", "JVNGEOW", "JVLEOW", 
            "JVNGOW", "JVNCOW", "JVNEOW", "JVNZOW", "JVNOOW", "JVNPOW", 
            "JVPOOW", "JVNSOW", "JVOOW", "JVPOW", "JVPEOW", "JVSOW" };

JMP16S[IDX]   reloc16 
            *32* %pc := [(COND2[IDX] = 1)?reloc16:%pc+5] # NB: Size includes opsiz
            *1*  %CTI := 1;

COND3 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
           "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
           "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF)",
           "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF", "(%NF ^ %OF) | %ZF",
           "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF", "~%ZF", "~%OF", "~%PF",
           "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP8S := { "JBA", "JBNBE", "JBAE", "JBNB", "JBB", "JBNAE", "JBBE", "JBNA",
           "JBC", "JBCXZ", "JBE", "JBZ", "JBG", "JBNLE", "JBGE", "JBNL",
           "JBL", "JBNGE", "JBLE", "JBNG", "JBNC", "JBNE", "JBNZ", "JBNO",
           "JBNP", "JBPO", "JBNS", "JBO", "JBP", "JBPE", "JBS" };

JMP8S[IDX]   reloc8 
            *32* %pc := [(COND3[IDX] = 1)?reloc8:%pc + 2]
            *1*  %CTI := 1;

JMP.JB   reloc8 
            *32* %pc := reloc8
            *1*  %CTI := 1;

JMP.JVOW   reloc16 
            *32* %pc := reloc16
            *1*  %CTI := 1;

JMP.JVOD   reloc32 
            *32* %pc := reloc32
            *1*  %CTI := 1;

JMP.EVOW   modrm16 
            *32* %pc := zfill(16,32,modrm16)
            *1*  %CTI := 1;

JMP.EVOD   modrm32 
            *32* %pc := modrm32
            *1*  %CTI := 1;


LEA.OD   r32, mem
            *32* r[r32] := mem;

LEA.OW   r16, mem
            *16* r[r16] := truncs(32,16,mem);

LEAVE    
            *32* %esp := %ebp
            *32* %ebp := m[%esp]
            *32* %esp := %esp + 4;

COND4 := { "%ecx ~= 0", "%ecx ~= 0 and %ZF ~= 0",
           "%ecx ~= 0 and %ZF ~= 1" };
LOOPS := { "LOOP", "LOOPE", "LOOPNE" };

LOOPS[IDX]   reloc 
            *32* %ecx := %ecx - 1
            *32* %pc := [COND4[IDX]?reloc:%pc]
            *1*  %CTI := 1;

MOV.EB.IB   modrm8, i8 
            *8* modrm8 := i8;

MOV.EB.IVOW   modrm16, i16
            *16* modrm16 := i16;

MOV.EB.IVOD   modrm32, i32
            *32* modrm32 := i32;

MOV.IB   r8, i8 
            *8* r[r8] := i8;

MOV.IW   r16, i16 
            *16* r[r16] := i16;

MOV.ID   r32, i32 
            *32* r[r32] := i32;

MOV.MRB   modrm8, r8 
            *8* modrm8 := r[r8];

MOV.MROW   modrm16, r16 
            *16* modrm16 := r[r16];

MOV.MROD   modrm32, r32 
            *32* modrm32 := r[r32];

MOV.OB.AL   i32
            *8* m[i32] := %al;

MOV.OV.EAXOW   i32
            *16* m[i32] := %ax;

MOV.OV.EAXOD   i32
            *32* m[i32] := %eax;

MOV.AL.OB    i32
            *8* %al := m[i32]{8};

MOV.EAX.OVOW i32 
            *16* %ax := m[i32]{16};

MOV.EAX.OVOD i32 
            *32* %eax := m[i32]{32};

MOV.RMB   r8, modrm8 
            *8* r[r8] := modrm8;

MOV.RMOW   r16, modrm16
            *16* r[r16] := modrm16;

MOV.RMOD   r32, modrm32
            *32* r[r32] := modrm32;

MOVSX.GV.EBOW   r16, modrm8
            *16* r[r16] := sgnex(8, 16, modrm8);

MOVSX.GV.EBOD   r32, modrm8
            *32* r[r32] := sgnex(8, 32, modrm8);

MOVSX.GV.EW   r32, modrm16 
            *32* r[r32] := sgnex(16, 32, modrm16);

MOVZX.GV.EBOW   r16, modrm8 
            *16* r[r16] := zfill(8, 16, modrm8);

MOVZX.GV.EBOD   r32, modrm8 
            *32* r[r32] := zfill(8, 32, modrm8);

MOVZX.GV.EW   r32, modrm16 
            *32* r[r32] := zfill(16, 32, modrm16);

MUL^"AL"   modrm8 
            *8* r[tmpb] := modrm8
            *16* %ax := zfill(8,16,%al) * zfill(8,16,r[tmpb])
            MULTFLAGS8(%ax);

MUL.AXOW   modrm16 
            *32* r[tmp2] := zfill(16,32,%ax) * zfill(16,32,modrm16)
            *16* %ax := r[tmp2]@[0:15]
            *16* %dx := r[tmp2]@[16:31]
            MULTFLAGS16(r[tmp2]);

MUL.AXOD   modrm32 
            *32* r[tmp1] := modrm32
            *64* r[tmpl] := zfill(32,64,%eax) * zfill(32,64,r[tmp1])
            *32* %eax := r[tmpl]@[0:31]
            *32* %edx := r[tmpl]@[32:63]
            MULTFLAGS32(r[tmpl]);

NEG.B   modrm8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := 0 - modrm8
            SUBFLAGS8(0, r[tmpb], modrm8);

NEG.OW   modrm16 
            *16* r[tmph] := modrm16
            *16* modrm16 := 0 - modrm16
            SUBFLAGS16(0, r[tmph], modrm16);

NEG.OD   modrm32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := 0 - modrm32
            SUBFLAGS32(0, r[tmp1], modrm32);

NOP    
            _ ;

NOT.B   modrm8 
            *8* modrm8 := 0 - modrm8 - 1;

NOT.OW   modrm16 
            *16* modrm16 := 0 - modrm16 - 1;

NOT.OD   modrm32 
            *32* modrm32 := 0 - modrm32 - 1;

POP.EVOW   modrm16 
            *16* modrm16 := m[%esp]
            *32* %esp := %esp + 2;

POP.EVOD   modrm32 
            *32* modrm32 := m[%esp]
            *32* %esp := %esp + 4;

POP.OW   r16 
            *16* r[r16] := m[%esp]{16}
            *32* %esp := %esp + 2;

POP.OD   r32 
            *32* r[r32] := m[%esp]{32}
            *32* %esp := %esp + 4;

POP.DS      *16* %ds := m[%esp]{16}
            *32* %esp := %esp + 2;
POP.ES      *16* %es := m[%esp]{16}
            *32* %esp := %esp + 2;
POP.FS      *16* %fs := m[%esp]{16}
            *32* %esp := %esp + 2;
POP.GS      *16* %gs := m[%esp]{16}
            *32* %esp := %esp + 2;
POP.SS      *16* %ss := m[%esp]{16}
            *32* %esp := %esp + 2;

PUSH.EVOW   modrm16 
            *32* %esp' := %esp - 2
            *16* m[%esp'] := modrm16;

PUSH.EVOD   modrm32 
            *32* %esp' := %esp - 4
            *32* m[%esp'] := modrm32;

PUSH.IBOW   i8 
            *32* %esp' := %esp - 2
            *16* m[%esp'] := sgnex(8,16,i8);

PUSH.IBOD   i8 
            *32* %esp' := %esp - 4
            *32* m[%esp'] := sgnex(8,32,i8);

PUSH.IVOW   i16 
            *32* %esp' := %esp - 2
            *16* m[%esp'] := i16;

PUSH.IVOD   i32 
            *32* %esp' := %esp - 4
            *32* m[%esp'] := i32;

PUSH.OW   r16 
            *32* %esp' := %esp - 2
            *16* m[%esp'] := r[r16];

PUSH.OD   r32 
            *32* %esp' := %esp - 4
            *32* m[%esp'] := r[r32];

PUSH.CS     *32* %esp := %esp - 2
            *16* m[%esp] := %cs;
PUSH.DS     *32* %esp := %esp - 2
            *16* m[%esp] := %ds;
PUSH.ES     *32* %esp := %esp - 2
            *16* m[%esp] := %es;
PUSH.FS     *32* %esp := %esp - 2
            *16* m[%esp] := %fs;
PUSH.GS     *32* %esp := %esp - 2
            *16* m[%esp] := %gs;
PUSH.SS     *32* %esp := %esp - 2
            *16* m[%esp] := %ss;


OP4 := { "rl", "rr" };
ROT := { "ROL", "ROR" };
ROTC := { "RCL", "RCR" };

ROLS := { "ROL" };
RORS := { "ROR" };
ROT[IDX].B.EB.1 modrm8 
            *8* r[tmpb1] := modrm8
            *8* r[tmpb2] := r[tmpb1] OP4[IDX] 1
            *8* modrm8 := r[tmpb2];
ROL.B.EB.1 modrm8   ROLFLAGS8(r[tmpb2], r[tmpb1], 1);
ROR.B.EB.1 modrm8   RORFLAGS8(r[tmpb2], r[tmpb1], 1);

ROTC[IDX].B.EB.1 modrm8
            *16* r[tmph] := zfill(9,16,(zfill(8,9,modrm8) | zfill(1,9,%CF)<<8) rl 1)
	    *8* modrm8 := truncu(16,8,r[tmph])
            *1* %CF := truncs(16,1,r[tmph]>>8);

ROT[IDX].B.EV.1OW modrm16 
            *16* r[tmph1] := modrm16
            *16* r[tmph2] := r[tmph1] OP4[IDX] 1
            *16* modrm16 := r[tmph2];
ROLS[IDX].B.EV.1OW modrm16   ROLFLAGS16(r[tmph2], r[tmph1], 1);
RORS[IDX].B.EV.1OW modrm16   RORFLAGS16(r[tmph2], r[tmph1], 1);

ROT[IDX].B.EV.1OD modrm32 
            *32* r[tmp1] := modrm32
            *32* r[tmp2] := r[tmp1] OP4[IDX] 1
            *32* modrm32 := r[tmp2];
ROLS[IDX].B.EV.1OD modrm32   ROLFLAGS32(r[tmp2], r[tmp1], 1);
RORS[IDX].B.EV.1OD modrm32   RORFLAGS32(r[tmp2], r[tmp1], 1);

ROT[IDX].B.EB.CL modrm8 
            *8* r[tmpb1] := modrm8
            *8* r[tmpb2] := r[tmpb1] OP4[IDX] %cl
            *8* modrm8 := r[tmpb2];
ROLS[IDX].B.EB.CL   modrm8  ROLFLAGS8(r[tmpb2], r[tmpb1], %cl);
RORS[IDX].B.EB.CL   modrm8  RORFLAGS8(r[tmpb2], r[tmpb1], %cl);

ROT[IDX].B.EV.CLOW modrm16 
            *16* r[tmph1] := modrm16
            *16* r[tmph2] := r[tmph1] OP4[IDX] %cl
            *16* modrm16 := r[tmph2];
ROLS[IDX].B.EV.CLOW   modrm16  ROLFLAGS16(r[tmph2], r[tmph1], %cl);
RORS[IDX].B.EV.CLOW   modrm16  RORFLAGS16(r[tmph2], r[tmph1], %cl);

ROT[IDX].B.EV.CLOD modrm32 
            *32* r[tmp1] := modrm32
            *32* r[tmp2] := r[tmp1] OP4[IDX] %cl
            *32* modrm32 := r[tmp2];
ROLS[IDX].B.EV.CLOD   modrm32  ROLFLAGS32(r[tmp2], r[tmp1], %cl);
RORS[IDX].B.EV.CLOD   modrm32  RORFLAGS32(r[tmp2], r[tmp1], %cl);

ROT[IDX].B.EB.IB modrm8, i8 
            *8* r[tmpb1] := modrm8
            *8* r[tmpb2] := r[tmpb1] OP4[IDX] i8
            *8* modrm8 := r[tmpb2];
ROLS[IDX].B.EB.IB   modrm8, i8  ROLFLAGS8(r[tmpb2], r[tmpb1], i8);
RORS[IDX].B.EB.IB   modrm8, i8  RORFLAGS8(r[tmpb2], r[tmpb1], i8);

ROT[IDX].B.EV.IBOW modrm16, i8 
            *16* r[tmph1] := modrm16
            *16* r[tmph2] := r[tmph1] OP4[IDX] i8!
            *16* modrm16 := r[tmph2];
ROLS[IDX].B.EV.IBOW   modrm16, i8 ROLFLAGS16(r[tmph2], r[tmph1], i8);
RORS[IDX].B.EV.IBOW   modrm16, i8 RORFLAGS16(r[tmph2], r[tmph1], i8);

ROT[IDX].B.EV.IBOD modrm32, i8 
            *32* r[tmp1] := modrm32
            *32* r[tmp2] := r[tmp1] OP4[IDX] i8
            *32* modrm32 := r[tmp2];
ROLS[IDX].B.EV.IBOD   modrm32, i8  ROLFLAGS32(r[tmp2], r[tmp1], i8);
RORS[IDX].B.EV.IBOD   modrm32, i8  RORFLAGS32(r[tmp2], r[tmp1], i8);

# These were wrong anyway; they combine with the opcode as well. For example,
# opcode F2 (REP/REPZ) means "repeat regardless of Z flag" for MOV/LOD/STO,
# but it means "repeat while Z=1" for CMP/SCA.
#REPT := { "REP", "REPNE", "REPNZ" };

#REPT[IDX]    
#            *1* %SKIP := [(%ecx = 0)?1:%SKIP]
#            *1* %RPT := [(%ecx = 0)?0:1]
#            *32* %ecx := [(%ecx > 0)?%ecx - 1:%ecx];

#REPTZF := { "REPE", "REPZ" };

#REPTZF[IDX]    
#            *1* %SKIP := [(%ecx = 0)?1:%SKIP]
#            *1* %RPT := [(%ecx = 0)?0:1]
#            *32* %ecx := [(%ecx > 0 and %ZF = 0)?%ecx - 1:%ecx];

RET    
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4
            *1*  %CTI := 1;

RET.IW   i16 
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4 + sgnex(16,32,i16)
            *1*  %CTI := 1;

SAHF    
            *1* %NF := %ah@[7:7]
            *1* %ZF := %ah@[6:6]
            *1* %PF := %ah@[2:2]
            *1* %CF := %ah@[0:0];

SETB.B   modrm8 
            *8* modrm8 := [%CF = 1?1:0];

SETB.NB   modrm8 
            *8* modrm8 := [%CF = 0?1:0];

SETB.BE   modrm8 
            *8* modrm8 := [%CF | %ZF = 1?1:0];

SETB.NBE   modrm8 
            *8* modrm8 := [%CF | %ZF = 0?1:0];

SETB.L   modrm8 
            *8* modrm8 := [%NF ~= %OF?1:0];

SETB.NL   modrm8 
            *8* modrm8 := [%NF = %OF?1:0];

SETB.O   modrm8 
            *8* modrm8 := zfill(1,8,%OF);

SETB.NO   modrm8
            *8* modrm8 := zfill(1,8,~%OF);

SETB.P   modrm8
            *8* modrm8 := zfill(1,8,%PF);

SETB.NP   modrm8
            *8* modrm8 := zfill(1,8,~%PF);

SETB.S   modrm8
            *8* modrm8 := zfill(1,8,%NF);

SETB.NS   modrm8
            *8* modrm8 := zfill(1,8,~%NF);

SETB.Z   modrm8 
            *8* modrm8 := zfill(1,8,%ZF);

SETB.NZ   modrm8 
            *8* modrm8 := zfill(1,8,~%ZF);

SETB.LE   modrm8 
            *8* modrm8 := [%ZF & (%NF ^ %OF) = 1?1:0];

SETB.NLE   modrm8 
            *8* modrm8 := [%ZF & (%NF ^ %OF) = 0?1:0];

OP5 := { "<<", ">>A", ">>" };
SHT := { "SHLSAL", "SAR", "SHR" };

SHT[IDX].B.EB.1 modrm8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := modrm8 OP5[IDX] 1;
SHLSAL.B.EB.1   modrm8  SALFLAGS8(modrm8, r[tmpb], 1);
SAR.B.EB.1   modrm8  SARFLAGS8(modrm8, r[tmpb], 1);
SHR.B.EB.1   modrm8  SHRFLAGS8(modrm8, r[tmpb], 1);

SHT[IDX].B.EV.1OW modrm16 
            *16* r[tmph] := modrm16
            *16* modrm16 := modrm16 OP5[IDX] 1;
SHLSAL.B.EV.1OW   modrm16  SALFLAGS16(modrm16, r[tmph], 1);
SAR.B.EV.1OW   modrm16  SARFLAGS16(modrm16, r[tmph], 1);
SHR.B.EV.1OW   modrm16  SHRFLAGS16(modrm16, r[tmph], 1);

SHT[IDX].B.EV.1OD modrm32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := modrm32 OP5[IDX] 1;
SHLSAL.B.EV.1OD   modrm32  SALFLAGS32(modrm32, r[tmp1], 1);
SAR.B.EV.1OD   modrm32  SARFLAGS32(modrm32, r[tmp1], 1);
SHR.B.EV.1OD   modrm32  SHRFLAGS32(modrm32, r[tmp1], 1);

SHT[IDX].B.EB.CL modrm8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := modrm8 OP5[IDX] %cl;
SHLSAL.B.EB.CL   modrm8  SALFLAGS8(modrm8, r[tmpb], %cl);
SAR.B.EB.CL   modrm8  SARFLAGS8(modrm8, r[tmpb], %cl);
SHR.B.EB.CL   modrm8  SHRFLAGS8(modrm8, r[tmpb], %cl);

SHT[IDX].B.EV.CLOW modrm16 
            *16* r[tmph] := modrm16
            *16* modrm16 := modrm16 OP5[IDX] %cl;
SHLSAL.B.EV.CLOW   modrm16   SALFLAGS16(modrm16, r[tmph], %cl);
SAR.B.EV.CLOW   modrm16   SARFLAGS16(modrm16, r[tmph], %cl);
SHR.B.EV.CLOW   modrm16   SHRFLAGS16(modrm16, r[tmph], %cl);

SHT[IDX].B.EV.CLOD modrm32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := modrm32 OP5[IDX] %cl;
SHLSAL.B.EV.CLOD   modrm32   SALFLAGS32(modrm32, r[tmp1], %cl);
SAR.B.EV.CLOD   modrm32   SARFLAGS32(modrm32, r[tmp1], %cl);
SHR.B.EV.CLOD   modrm32   SHRFLAGS32(modrm32, r[tmp1], %cl);

SHT[IDX].B.EB.IB modrm8, i8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := modrm8 OP5[IDX] i8;
SHLSAL.B.EB.IB   modrm8, i8   SALFLAGS8(modrm8, r[tmpb], i8);
SAR.B.EB.IB   modrm8, i8   SARFLAGS8(modrm8, r[tmpb], i8);
SHR.B.EB.IB   modrm8, i8   SHRFLAGS8(modrm8, r[tmpb], i8);

SHT[IDX].B.EV.IBOW modrm16, i8 
            *16* r[tmph] := modrm16
            *16* modrm16 := modrm16 OP5[IDX] i8;
SHLSAL.B.EV.IBOW   modrm16, i8   SALFLAGS16(modrm16, r[tmph], i8);
SAR.B.EV.IBOW   modrm16, i8   SARFLAGS16(modrm16, r[tmph], i8);
SHR.B.EV.IBOW   modrm16, i8   SHRFLAGS16(modrm16, r[tmph], i8);

SHT[IDX].B.EV.IBOD modrm32, i8 
            *32* r[tmp1] := modrm32
            *32* modrm32 := modrm32 OP5[IDX] i8;
SHLSAL.B.EV.IBOD   modrm32, i8   SALFLAGS32(modrm32, r[tmp1], i8);
SAR.B.EV.IBOD   modrm32, i8   SARFLAGS32(modrm32, r[tmp1], i8);
SHR.B.EV.IBOD   modrm32, i8   SHRFLAGS32(modrm32, r[tmp1], i8);

OP6 := { "<<", ">>" };
SHTD := { "SHLD", "SHRD" };

SHTD[IDX].CLOW modrm16, r16 
            *8* r[tmpb] := %cl %32
            *32* r[tmp3] := zfill(16,32,r[r16]) << 16 | zfill(16,32,modrm16)
            *32* r[tmp5] := r[tmp3] OP6[IDX] r[tmpb]
            *16* modrm16 := truncu(32,16,r[tmp5]);
SHLD.CLOW   modrm16, r16  SHLDFLAGS32(r[tmp5], r[tmp3], r[tmpb]);
SHRD.CLOW   modrm16, r16  SHRDFLAGS32(r[tmp5], r[tmp3], r[tmpb]);

SHTD[IDX].CLOD modrm32, r32 
            *8* r[tmpb] := %cl % 32
            *64* r[tmpl] := zfill(32,64,r[r32]) << 32 | zfill(32,64,modrm32)
            *64* r[tmpl2] := r[tmpl] OP6[IDX] r[tmpb]
            *32* modrm32 := truncu(64,32,r[tmpl2]);
SHLD.CLOD   modrm32, r32  SHLDFLAGS64(r[tmpl2], r[tmpl], r[tmpb]);
SHRD.CLOD   modrm32, r32  SHRDFLAGS64(r[tmpl2], r[tmpl], r[tmpb]);

SHTD[IDX].IBOW modrm16, r16, i8 
            *8* r[tmpb] := i8 % 32
            *32* r[tmp3] := zfill(16,32,r[r16]) << 16 | zfill(16,32,modrm16)
            *32* r[tmp5] := r[tmp3] OP6[IDX] r[tmpb]
            *16* modrm16 := truncu(32,16,r[tmp5]);
SHLD.IBOW   modrm16, r16, i8   SHLDFLAGS32(r[tmp5], r[tmp3], r[tmpb]);
SHRD.IBOW   modrm16, r16, i8   SHRDFLAGS32(r[tmp5], r[tmp3], r[tmpb]);

SHTD[IDX].IBOD modrm32, r32, i8 
            *8* r[tmpb] := i8 % 32
            *64* r[tmpl] := zfill(32,64,r[r32]) << 32 | zfill(32,64,modrm32)
            *64* r[tmpl2] := r[tmpl] OP6[IDX] r[tmpb]
            *32* modrm32 := truncu(64,32,r[tmpl2]);
SHLD.IBOD   modrm32, r32, i8  SHLDFLAGS64(r[tmpl2], r[tmpl], r[tmpb]);
SHRD.IBOD   modrm32, r32, i8  SHRDFLAGS64(r[tmpl2], r[tmpl], r[tmpb]);

STC    *1* %CF := 1;

STD    *1* %DF := 1;

STI    *1* %IF := 1;

# The string instructions
REPS := {"REP", "REPNE"};                   # Repeat prefixes
OREPS := { REPS, ""};                       # Optional repeat prefixes
ALLSZ := {"B", "VOW", "VOD"};               # All size suffixes

# String instructions, not repeated
STRS := { "CMPS", "LODS", "MOVS", "SCAS", "STOS" };

# String instructions, repeated
STRS_R := REPS STRS;

# String instructions, optionally repeated
STRS_OR := OREPS STRS;

STRFL :=       { "CMPS", "SCAS"};                   # Update flags
STRNF :=       { "LODS", "MOVS", "STOS"};           # No update flags
STRSI := OREPS { "CMPS", "LODS", "MOVS" };          # Update esi
STRDI := OREPS { "CMPS", "MOVS", "SCAS", "STOS" };  # Update edi
STRFL_OR := OREPS STRFL;                            # Optionally repeated; flags

CMPS_OR := OREPS CMPS;      # Compare with optional repeat
LODS_OR := OREPS LODS;      # Load with optional repeat
MOVS_OR := OREPS MOVS;      # Move with optional repeat
SCAS_OR := OREPS SCAS;      # Scan with optional repeat
STOS_OR := OREPS STOS;      # Store with optional repeat

# All repeated string instructions
STRS_R[X]ALLSZ[Y]
            *1* %SKIP := [ %ecx = 0 ? 1 : 0 ];

CMPS_OR[X].B
            *8* r[tmpb] := m[%esi]{8} - m[%edi]{8};
LODS_OR[X].B   
            *8* %al := m[%esi]{8};
MOVS_OR[X].B   
            *8* m[%edi] := m[%esi]{8};
SCAS_OR[X].B   
            *8* r[tmpb] := %al - m[%edi]{8};
STOS_OR[X].B   
            *8* m[%edi] := %al;
STRFL_OR[X].B   
            SUBFLAGS8(m[%esi]{8}, m[%edi]{8}, r[tmpb]);
STRSI[IDX].B   
            *32* %esi := %esi + [%DF = 0?1:-1];
STRDI[IDX].B   
            *32* %edi := %edi + [%DF = 0?1:-1];

CMPS_OR[X].VOW   
            *16* r[tmph] := m[%esi]{16} - m[%edi]{16};
LODS_OR[X].VOW   
            *16* %ax := m[%esi]{16};
MOVS_OR[X].VOW   
            *16* m[%edi] := m[%esi]{16};
SCAS_OR[X].VOW   
            *16* r[tmph] := %ax - m[%edi]{16};
STOS_OR[X].VOW   
            *16* m[%edi] := %ax;
STRFL_OR[X].VOW   
            SUBFLAGS16(m[%esi]{16}, m[%edi]{16}, r[tmph]);
STRSI[IDX].VOW   
            *32* %esi := %esi + [%DF = 0?2:-2];
STRDI[IDX].VOW   
            *32* %edi := %edi + [%DF = 0?2:-2];

CMPS_OR[X].VOD   
            *32* r[tmp1] := m[%esi]{32} - m[%edi]{32};
LODS_OR[X].VOD   
            *32* %eax := m[%esi]{32};
MOVS_OR[X].VOD   
            *32* m[%edi] := m[%esi]{32};
SCAS_OR[X].VOD   
            *32* r[tmp1] := %eax - m[%edi];
STOS_OR[X].VOD   
            *32* m[%edi] := %eax;
STRFL_OR[X].VOD   
            SUBFLAGS32(m[%esi]{32}, m[%edi]{32}, r[tmp1]);
STRSI[IDX].VOD   
            *32* %esi := %esi + [%DF = 0?4:-4];
STRDI[IDX].VOD   
            *32* %edi := %edi + [%DF = 0?4:-4];

# All repeated instructions decrement %ecx
STRS_R[X]ALLSZ[Y]
            *32* %ecx := %ecx - 1;

# Do the repeat logic
REPIFZ := REP STRFL;
REPIFZ[X]ALLSZ[Y]
            *1* %CTI := %ZF;

REPIFNZ := REPNE STRFL;
REPIFNZ[X]ALLSZ[Y]
            *1* %CTI := ~%ZF;

REPALL := REPS STRNF;
REPALL[X]ALLSZ[Y]
            *1* %CTI := 1;

# End string instructions


TEST.AL.IB   i8 
            *8* r[tmpb] := %al & i8
            LOGICALFLAGS8(r[tmpb]);

TEST.EAX.IVOW   i16 
            *16* r[tmph] := %ax & i16
            LOGICALFLAGS16(r[tmph]);

TEST.EAX.IVOD   i32 
            *32* r[tmp1] := %eax & i32
            LOGICALFLAGS32(r[tmp1]);

TEST.EB.IB   modrm8, i8 
            *8* r[tmpb] := modrm8 & i8
            LOGICALFLAGS8(r[tmpb]);

TEST.EW.IW   modrm16, i16 
            *16* r[tmph] := modrm16 & i16
            LOGICALFLAGS16(r[tmph]);

TEST.ED.ID   modrm32, i32 
            *32* r[tmp1] := modrm32 & i32
            LOGICALFLAGS32(r[tmp1]);

TEST.EB.GB   modrm8, r8 
            *8* r[tmpb] := modrm8 & r[r8]
            LOGICALFLAGS8(r[tmpb]);

TEST.EV.GVOW   modrm16, r16 
            *16* r[tmph] := modrm16 & r[r16]
            LOGICALFLAGS16(r[tmph]);

TEST.EV.GVOD   modrm32, r32 
            *32* r[tmp1] := modrm32 & r[r32]
            LOGICALFLAGS32(r[tmp1]);

WAIT    _ ;

XADD.EB.GB   modrm8, r8 
            *8* r[tmpb1] := modrm8
            *8* r[tmpb2] := r[r8]
            *8* modrm8 := r[tmpb1] + r[r8]
            *8* r[r8] := r[tmpb1]
            ADDFLAGS8(r[tmpb1], r[tmpb2], modrm8);

XADD.EV.GVOW   modrm16, r16 
            *16* r[tmph1] := modrm16
            *16* r[tmph2] := r[r16]
            *16* modrm16 := r[tmph1] + r[r16]
            *16* r[r16] := r[tmph1]
            ADDFLAGS16(r[tmph1], r[tmph2], modrm16);

XADD.EV.GVOD   modrm32, r32 
            *32* r[tmp1] := modrm32
            *32* r[tmp2] := r[r32]
            *32* modrm32 := r[tmp1] + r[r32]
            *32* r[r32] := r[tmp1]
            ADDFLAGS32(r[tmp1], r[tmp2], modrm32);

XCHG.EAXOD   r32 
            *32* r[tmp1] := r[r32]
            *32* r[r32] := %eax
            *32* %eax := r[tmp1];

XCHG.EAXOW   r16 
            *16* r[tmph] := r[r16]
            *16* r[r16] := %ax
            *16* %ax := r[tmph];

XCHG.EB.GB   modrm8, r8 
            *8* r[tmpb] := modrm8
            *8* modrm8 := r[r8]
            *8* r[r8] := r[tmpb];

XCHG.EV.GVOW   modrm16, r16 
            *16* r[tmph] := modrm16
            *16* modrm16 := r[r16]
            *16* r[r16] := r[tmph];

XCHG.EV.GVOD   modrm32, r32 
            *32* r[tmp1] := modrm32
            *32* modrm32 := r[r32]
            *32* r[r32] := r[tmp1];

# Start of Floating point operators
FABS    
            *80* r[39 - %fstp] := 
                        [ 0.0 -f r[39 - %fstp] <= 0.0 ? r[39 - %fstp] 
                                                     : 0.0 -f r[39 - %fstp ] ];

OP3 := { "+f", "-f" };
FARIT := { "FADD", "FSUB" };

FARIT[IDX].r32 mem
            *80* r[39 - %fstp] := r[39 - %fstp] OP3[IDX] fsize(32,80,m[mem]);

FARIT[IDX].r64 mem
            *80* r[39 - %fstp] := r[39 - %fstp] OP3[IDX] fsize(64,80,m[mem]{64});

FARIT[IDX].ST.STi fsi
            *80* r[39 - %fstp] := r[39 - %fstp] OP3[IDX] r[(fsi + (7 - %fstp))&0x27];

FARIT[IDX].STi.ST fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[(fsi + (7 - %fstp))&0x27] OP3[IDX] r[39 - %fstp];

FARITP := { "FADDP", "FSUBP" };

FARITP[IDX].r32 mem
            *80* r[39 - %fstp] := r[39 - %fstp] OP3[IDX] fsize(32,80,m[mem])
            *3* %fstp := %fstp - 1;

FARITP[IDX].r64 mem 
            *80* r[39 - %fstp] := r[39 - %fstp] OP3[IDX] fsize(64,80,m[mem]{64})
            *3* %fstp := %fstp - 1;

FARITP[IDX].ST.STi fsi 
            *80* r[39 - %fstp] := r[39 - %fstp] OP3[IDX] r[(fsi + (7 - %fstp))&0x27]
            *3* %fstp := %fstp - 1;

FARITP[IDX].STi.ST fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[(fsi + (7 - %fstp))&0x27] OP3[IDX] r[39 - %fstp]
            *3* %fstp := %fstp - 1;

FIADD.i32   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] +f itof(32,80,m[mem]);

FIADD.i16   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] +f itof(16,80,m[mem]{16});

FCHS    
            *80* r[39 - %fstp] := 0.0 -f r[39 - %fstp];

FCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FNCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FCOM.r32    mem
            *80* r[tmpF] := r[39 - %fstp] -f fsize(32,80,m[mem])
            SETFFLAGS(r[39 - %fstp], fsize(32,80,m[mem]));

FCOM.r64    mem
            *80* r[tmpF] := r[39 - %fstp] -f fsize(64,80,m[mem]{64})
            SETFFLAGS(r[39 - %fstp], fsize(64,80,m[mem]{64}));

FCOM.ST.STi fsi 
            *80* r[tmpF] := r[39 - %fstp] -f r[(fsi + (7 - %fstp))&0x27]
            SETFFLAGS(r[39 - %fstp], r[(fsi + (7 - %fstp))&0x27]);

FCOMP.r32   mem 
            *80* r[tmpF1] := r[39 - %fstp]
            *80* r[tmpF2] := fsize(32, 80, m[mem])
            *80* r[tmpF] := r[39 - %fstp] -f fsize(32,80,m[mem])
            *3* %fstp := %fstp - 1
            SETFFLAGS(r[tmpF1], r[tmpF2]);

FCOMP.r64   mem
            *80* r[tmpF1] := r[39 - %fstp]
            *80* r[tmpF2] := fsize(64, 80, m[mem]{64})
            *80* r[tmpF] := r[39 - %fstp] -f fsize(64,80,m[mem]{64})
            *3* %fstp := %fstp - 1
            SETFFLAGS(r[tmpF1], r[tmpF2]);

FCOMP.ST.STi   fsi 
            *80* r[tmpF1] := r[39 - %fstp]
            *80* r[tmpF2] := r[(fsi + (7 - %fstp))&0x27]
            *80* r[tmpF] := r[39 - %fstp] -f r[(fsi + (7 - %fstp))&0x27]
            *3* %fstp := %fstp - 1
            SETFFLAGS(r[tmpF1], r[tmpF2]);
FCOMPP    
            *80* r[tmpF1] := r[39 - %fstp]
            *80* r[tmpF2] := r[39 - ((%fstp - 1) & 7)]
            *80* r[tmpF] := r[39 - %fstp] -f r[39 - ((%fstp - 1) & 7)]
            *3* %fstp := %fstp - 2
            SETFFLAGS(r[tmpF1], r[tmpF2]);

FCOS    
            *80* r[39 - %fstp] := cos(r[39 - %fstp]);

# Huh? (no such instruction) -nk
# FPUSH_
#             FPUSH;

FDIV.r32   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] /f fsize(32,80,m[mem]);

FDIV.r64   mem
            *80* r[39 - %fstp] := r[39 - %fstp] /f fsize(64,80,m[mem]{64});

FDIV.ST.STi   fsi 
            *80* r[39 - %fstp] := r[39 - %fstp] /f r[(fsi + (7 - %fstp))&0x27];

# At this point, it should be noted that Intel have a really silly way of
# defining what is and isn't an "R" instruction. There is an "R" bit in the
# opcode (bit 2 of the second byte), which is NOT the same as the "R" in the
# instruction name (according to the Intel book, and according to debug
# and ida pro). Unix disassemblers like dis and objdump get it wrong, as
# the .spec file does.
# Looking at the bits in the instruction, the "R" (reverse) bit implies
# reversing the operands such that ST is now the second operand, and the
# "d" (direction) bit implies that ST(i) is the destination instead of ST.
# Intel's crazy idea is that when "d" is in force, the operands have to be
# swapped as well, so to get them the normal way around, you need an "R"
# instruction to reverse the reversal. Clear?
# Getting the R correct is difficult, so we tolerate the error and correct
# for it. Basically, it means reversing the operands for instructions with
# and R in the name (according to the spec, not Intel) AND with .STi.ST
# (effectively, this form already implies a "reversal"). Note that the NO
# argument forms (e.g. FDIVP) are effectively .STi.ST verions (with i=1).

FDIV.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[39 - %fstp] /f r[(fsi + (7 - %fstp))&0x27];

FDIVP.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[39 - %fstp] /f r[(fsi + (7 - %fstp))&0x27];

FIDIV.i32   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] /f itof(32,80,m[mem]);

FIDIV.i16   mem
            *80* r[39 - %fstp] := r[39 - %fstp] /f itof(16,80,m[mem]{16});

FDIVR.r32   mem
            *80* r[39 - %fstp] := fsize(32,80,m[mem]) /f r[39 - %fstp];

FDIVR.r64   mem 
            *80* r[39 - %fstp] := fsize(64,80,m[mem]{64}) /f r[39 - %fstp];

FDIVR.ST.STi   fsi 
            *80* r[39 - %fstp] := r[(fsi + (7 - %fstp))&0x27] /f r[39 - %fstp];

FDIVR.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[(fsi + (7 - %fstp))&0x27] /f r[39 - %fstp];

FDIVRP.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[(fsi + (7 - %fstp))&0x27] /f r[39 - %fstp]
            *3* %fstp := %fstp - 1;

FIDIVR.i32   mem
            *80* r[39 - %fstp] := itof(32,80,m[mem]) /f r[39 - %fstp];

FIDIVR.i16   mem
            *80* r[39 - %fstp] := itof(16,80,m[mem]{16}) /f r[39 - %fstp];

FICOM.i16   mem
            *80* r[tmpF] := r[39 - %fstp] -f itof(16,80,m[mem]{16})
            SETFFLAGS(r[39 - %fstp], itof(16,80,m[mem]{16}));

FICOM.i32   mem
            *80* r[tmpF] := r[39 - %fstp] -f itof(32,80,m[mem])
            SETFFLAGS(r[39 - %fstp], itof(32,80,m[mem]));

FICOMP.i16  mem
            *80* r[tmpF] := r[39 - %fstp] -f itof(16,80,m[mem]{16})
            *3* %fstp := %fstp - 1
            SETFFLAGS(r[39 - %fstp], itof(16,80,m[mem]{16}));

FICOMP.i32  mem
            *80* r[tmpF] := r[39 - %fstp] -f itof(32,80,m[mem])
            *3* %fstp := %fstp - 1
            SETFFLAGS(r[39 - %fstp], itof(32,80,m[mem]));

FILD.lsI16  mem
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := itof(16,80,m[mem]{16});

FILD.lsI32  mem
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := itof(32,80,m[mem]);

FILD.lsI64  mem
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := itof(64,80,m[mem]{64});

FINCSTP    
            *3* %fstp := %fstp + 1;

FIST.lsI16  mem
            *16* m[mem] := ftoi(80,16,r[39 - %fstp]);

FIST.lsI32  mem
            *32* m[mem] := ftoi(80,32,r[39 - %fstp]);

FISTP.lsI16 mem
            *16* m[mem] := ftoi(80,16,r[39 - %fstp])
            *3* %fstp := %fstp - 1;

FISTP.lsI32 mem
            *32* m[mem] := ftoi(80,32,r[39 - %fstp])
            *3* %fstp := %fstp - 1;

FISTP.lsI64 mem
            *64* m[mem] := ftoi(80,64,r[39 - %fstp])
            *3* %fstp := %fstp - 1;

FLD.lsR32   mem
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := fsize(32,80,m[mem]);

FLD.lsR64   mem
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := fsize(64,80,m[mem]{64});

FLD80       mem 
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := m[mem]{80};

# This is a bit tricky. The FPUSH logically comes between the read of STi and
# the write to ST0. In particular, FLD ST0 is supposed to duplicate the TOS.
# This problem only happens with this load instruction, so there is a work
# around in the decoder that gives us a value of i that is one more than in
# the instruction

FLD.STi   fsi 
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := r[(fsi + (8 - %fstp))&0x27];

FLD1    
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := 1.0;

FLDL2T    
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := log2(10.0);

FLDL2E    
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := log2(2.7182818);

FLDPI    
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := 3.1415926;

FLDLG2    
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := log10(2.0);

FLDLN2    
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := loge(2.0);

FLDZ    
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := 0.0;

FLDCW   mem 
            *3* %fstp := %fstp + 1
            *16* %fcw := m[mem]{16};

FMUL.r32   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] *f fsize(32,80,m[mem]);

FMUL.r64   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] *f fsize(64,80,m[mem]{64});

FMUL.ST.STi   fsi 
            *80* r[39 - %fstp] := r[39 - %fstp] *f r[(fsi + (7 - %fstp))&0x27];

FMUL.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[39 - %fstp] *f r[(fsi + (7 - %fstp))&0x27];

FMULP.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[39 - %fstp] *f r[(fsi + (7 - %fstp))&0x27]
            *3* %fstp := %fstp - 1;

FIMUL.r32   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] *f itof(32,80,m[mem]);

FIMUL.r64   mem 
            *80* r[39 - %fstp] := r[39 - %fstp] *f itof(64,80,m[mem]{64});

FNOP    _ ;

FPATAN    
            *80* r[39 - ((%fstp - 1) & 7)] := arctan(r[39 - ((%fstp - 1) & 7)] /f r[39 - %fstp]);

FPTAN    
            *80* r[39 - %fstp] := tan(r[39 - %fstp])
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := 1.0;

FRNDINT    
            *80* r[39 - %fstp] := fround(80,80,r[39 - %fstp]);

FSIN    
            *80* r[39 - %fstp] := sin(r[39 - %fstp]);

FSINCOS    
            *80* r[tmpF] := r[39 - %fstp]
            *80* r[39 - %fstp] := sin(r[tmpF])
            *3* %fstp := %fstp + 1
            *80* r[39 - %fstp] := cos(r[tmpF]);

FSQRT    
            *80* r[39 - %fstp] := sqrt(r[39 - %fstp]);

FST.lsR32   mem 
            *32* m[mem] := fsize(80,32,r[39 - %fstp]);

FST.lsR64   mem 
            *64* m[mem] := fsize(80,64,r[39 - %fstp]);

FST.ST.STi   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[39 - %fstp];

FSTP.lsR32   mem 
            *32* m[mem] := fsize(80,32,r[39 - %fstp])
            *3* %fstp := %fstp - 1;

FSTP.lsR64   mem 
            *64* m[mem] := fsize(80,64,r[39 - %fstp])
            *3* %fstp := %fstp - 1;

FSTP80   mem 
            *80* m[mem] := r[39 - %fstp]
            *3* %fstp := %fstp - 1;

FSTP.ST.STi   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[39 - %fstp]
            *3* %fstp := %fstp - 1;

FSTCW   mem 
            *16* m[mem] := %fcw;

FNSTCW   mem 
            *16* m[mem] := %fcw;

FSTSW   mem 
            *16* m[mem] := %fsw;

FSTSW.AX    
            *16* %ax := %fsw;

FNSTSW   mem 
            *16* m[mem] := %fsw;

FNSTSW.AX    
            *16* %ax := %fsw;

FSUBR.r32   mem 
            *80* r[39 - %fstp] := fsize(32,80,m[mem]) -f r[39 - %fstp];

FSUBR.r64   mem 
            *80* r[39 - %fstp] := fsize(64,80,m[mem]{64}) -f r[39 - %fstp];

FSUBR.ST.STi   fsi 
            *80* r[39 - %fstp] := r[(fsi + (7 - %fstp))&0x27] -f r[39 - %fstp];

# Please see large comment above FDIV
FSUBR.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[(fsi + (7 - %fstp))&0x27] -f r[39 - %fstp];

FSUBRP.STi.ST   fsi 
            *80* r[(fsi + (7 - %fstp))&0x27] := r[(fsi + (7 - %fstp))&0x27] -f r[39 - %fstp]
            *3* %fstp := %fstp - 1;

FISUBR.r32   mem 
            *80* r[39 - %fstp] := itof(32,80,m[mem]) -f r[39 - %fstp];

FISUBR.r64   mem 
            *80* r[39 - %fstp] := itof(64,80,m[mem]{64}) -f r[39 - %fstp];

FTST    
            SETFFLAGS(r[39 - %fstp], 0.0);

FUCOM       fsi 
            *80* r[tmpF] := r[39 - %fstp] -f r[fsi]
            SETFFLAGS(r[39 - %fstp], r[(fsi + (7 - %fstp))&0x27]);

FUCOMP      fsi 
            *80* r[tmpF1] := r[39 - %fstp]
            *80* r[tmpF2] := r[(fsi + (7 - %fstp))&0x27]
            *80* r[tmpF] := r[39 - %fstp] -f r[(fsi + (7 - %fstp))&0x27]
            *3* %fstp := %fstp - 1
            SETFFLAGS(r[tmpF1], r[tmpF2]);

FUCOMPP    
            *80* r[tmpF1] := r[39 - %fstp]
            *80* r[tmpF2] := r[39 - ((%fstp - 1) & 7)]
            *80* r[tmpF] := r[39 - %fstp] -f r[39 - ((%fstp - 1) & 7)]
            *3* %fstp := %fstp - 2
            SETFFLAGS(r[tmpF1], r[tmpF2]);

FWAIT    _ ;

FXCH        fsi 
            *80* r[tmpF] := r[39 - %fstp]
            *80* r[39 - %fstp] := r[(fsi + (7 - %fstp))&0x27]
            *80* r[(fsi + (7 - %fstp))&0x27] := r[tmpF];

FYL2X    
            *80* r[39 - ((%fstp - 1) & 7)] := r[39 - ((%fstp - 1) & 7)] *f log2(r[39 - %fstp]);

FYL2XP1    
            *80* r[39 - ((%fstp - 1) & 7)] := r[39 - ((%fstp - 1) & 7)] *f log2(r[39 - %fstp] +f 1.0);

#####################################################################
# These are the semantics for certain prologues and epilogues that we
# need to see for CSR analysis. We need the semantics for a logue to
# be specified when it uses and/or defines locations that relevant for
# CSR analysis involving the logue. For example, the caller prologue
# "clear_stack" on x86 directly manipulates the stack pointer which is
# something the abstract frame pointer needs to see.
#####################################################################
CLEAR_STACK   n 
            *32* %esp := %esp + n;
