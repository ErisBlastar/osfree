#
# Copyright (C) 1998-2001, The University of Queensland
# Copyright (C) 2001, Sun Microsystems, Inc
#
# See the file "LICENSE.TERMS" for information on usage and
# redistribution of this file, and for a DISCLAIMER OF ALL
# WARRANTIES.
#

# File: 80386.ssl
# Desc: This file contains a semantic description of the 80386 and 387
#       processors. 
#
# Copyright (C) 1998-2001, The University of Queensland, BT group
# Copyright (C) 2001, Sun Microsystems, Inc
#

# $Revision: 1.5 $
# 16 Oct 98 - Mike: lower case register names to be consistent with sparc
# 27 Oct 98 - Mike: added many missing relative branch instructions
# 28 Oct 98 - Mike: fixed many CALL etc instructions
# 30 Oct 98 - Mike: fixed some IEAXs that were EAXs
# 30 Oct 98 - Mike: added a missing set of CMP instructions
# 04 Nov 98 - Mike: removed sign extend from relative branches and calls
# 05 Nov 98 - Mike: removed sign extend from immediate constants also; the
#               sign extension is already done by the toolkit
# 05 Nov 98 - Mike: corrected many of the bit number errors
# 27 Jan 99 - Ian:  Modified registers for detailed information, 
#                   (indexing remains the same)
# 27 Nov 98 - Mike: simplified CWDE
# 28 Jan 99 - Mike: Added BT series instructions
# 16 Feb 99 - Mike: Fixed J*LE series instruction semantics
# 04 Mar 99 - Mike: Many fixes to make it parse
# 09 Mar 99 - Mike: More fixes to make it parse: underscores on instruction
#                       names, sin(), FPOP, etc
# 11 Mar 99 - Mike: Removed the last few reg80's. Much reformatting. Fixed
#               inconsistency with STi.ST (thanks, Intel!)
# 16 Mar 99 - Mike: Fixed LOGICALFLAGS() (wasn't done at all!)
# 25 Mar 99 - Mike: Simplified SETNE etc to be ~ZF inst of (ZF = 0)
# 25 Mar 99 - Mike: Fixed instr like CMPib to use modrm ins of r[reg8]
# 28 May 99 - Mike: fixed order of mov to/from eax and memory
# 30 Jun 99 - Mike: simplified shifts (only 1 temp, instead of 2)
# 14 Jul 99 - Mike: fixed PUSH.Ib; added ENDIANNESS
# 09 Sep 99 - Mike: Added FADDP and FSUBP instructions
# 20 Apr 00 - Mike: Fixed a compare that was 64 bits (should be 32).
#                   Also many reg32 -> r[reg32]... these are important now!
# 05 Jul 00 - Mike: Fixed ARITHid and ARITHiw: had r[reg32] inst of modrm
# 12 Jul 00 - Mike: Changed order of operands to fsize() etc (operand now last)
# 28 Aug 00 - Mike: Cleaned up IMUL instructions; added 2 missing forms
# 29 Aug 00 - Mike: Fixed several LOG instructions; had r[tmp1] inst of modrm:
#                   Example "andb %cl,%cl"
# 05 Sep 00 - Mike: Result of float comparison is tmpd now
# 21 Sep 00 - Mike: Result of integer comparisons is tmpb, tmph if needed
# 25 Sep 00 - Mike: Arg to SETFFLAGS was incorrect; more tempds with fcompares
# 28 Sep 00 - Mike: Some FCOMxx instructions were missing the "%st -f"
# 02 Oct 00 - Mike: Added long comment to justify the way FLD.STi is decoded
# 03 Oct 00 - Mike: Fixed SHR, SAR (had erroneous assignment to r[tmp2]
# 09 Oct 00 - Mike: Fixed CWD, CDQ semantics (had 0 and -1 swapped)
# 30 Nov 00 - Mike: Removed most {size} except where applying to memory;
#               trunc->truncu or truncs as appropriate
# 11 Feb 01 - Nathan: Add register sizes for special registers
# 06 Mar 01 - Mike: Changed TEST instructions to use appropriately sized temps
# 08 Mar 01 - Mike: Fixed sizes of operands of MOV.RMB and MOV.RMOD
# 12 Mar 01 - Simon: Retabbed, reformatted, rewrote, really I did.
# 13 Mar 01 - Simon: Fixed sizes of operands in MOV.EB.IVOW and MOV.EB.IVOD
# 19 Mar 01 - Mike: SETFFLAGS takes two operands now, as required by
#               processSubFlags; changed FXCH to use tempD
# 20 Mar 01 - Mike: Removed superfluous entries for FXCH, FUCOM, FUCOMP, etc
#              (had separate versions for i=1, i.e. implied operand of %st1;
#              these are not different instructions, just assembler shortcuts)
# 22 Mar 01 - Mike: Use correct temp names (e.g. tmpb for byte temporaries)
#              Also cast memory operands to flags functions (e.g. modrm{8},...)
# 23 Mar 01 - Mike: Restored some important comments
# 24 Mar 01 - Mike: Repaired some 1OW, 1OD from IOW, IOD (shift/rotate)
# 26 Mar 01 - Mike: F[U]COMP[P] instructions have added temporaries to avoid
#              the side effect of FPOP changing register numbers
# 30 Mar 01 - Mike: Fixed semantics of MOV[ZS]X; was relying on the difference
#               between the assignment size and size cast of the RHS
# 19 Apr 01 - Mike: Fixed semantics of MOVS.VOD
# 24 Apr 01 - Mike: Major overhaul of the string instructions; loops are now
#               implicit (defined by %SKIP and %RPT)
# 17 Oct 01 - Mike: Added PUSH.IXOW (8 bit immediate operand, 16 bit push)
# 19 Oct 01 - Mike: Fixed semantics for LOG[IDX]^"IODB" (was r[r[n]])
# 25 Oct 01 - Mike: Fixed FISTP64 (Floating to 64 bit integer store)
# 05 Nov 01 - Mike: Use tmpD where needed for floatmax

# Constants defined in hexadecimal (modelling manual) 
MAX8BITS  := 0xFF;
MAX16BITS := 0xFFFF;
MAX32BITS := 0xFFFFFFFF;
MAX64BITS := 0xFFFFFFFFFFFFFFFF;
MAX8POS   := 0x7F;
MAX8NEG   := 0x80;
MAX16POS  := 0x7FFF;
MAX16NEG  := 0x8000;
MAX32POS  := 0x7FFFFFFF;
MAX32NEG  := 0x80000000;

INTEGER
[ %eax, %ecx, %edx, %ebx,
  %esp, %ebp, %esi, %edi ][32] -> 24..31,
%ax[16] -> 0 SHARES %eax@[0..15],
%cx[16] -> 1 SHARES %ecx@[0..15],
%dx[16] -> 2 SHARES %edx@[0..15],
%bx[16] -> 3 SHARES %ebx@[0..15],
%sp[16] -> 4 SHARES %esp@[0..15],
%bp[16] -> 5 SHARES %ebp@[0..15],
%si[16] -> 6 SHARES %esi@[0..15],
%di[16] -> 7 SHARES %edi@[0..15],
%al[8]  -> 8 SHARES %ax@[0..7],
%cl[8]  -> 9 SHARES %cx@[0..7],
%dl[8]  -> 10 SHARES %dx@[0..7],
%bl[8]  -> 11 SHARES %bx@[0..7],
%ah[8]  -> 12 SHARES %ax@[8..15],
%ch[8]  -> 13 SHARES %cx@[8..15],
%dh[8]  -> 14 SHARES %dx@[8..15],
%bh[8]  -> 15 SHARES %bx@[8..15],
%es[8]  -> 16,
%cs[8]  -> 17,
%ss[8]  -> 18,
%ds[8]  -> 19,
%pc[32] -> -1,
[ %NF, %ZF, %AF, %PF,
  %CF, %OF, %DF, %IF,
  %FP, %SKIP, %RPT, %FLF,
  %C2, %FZF ][1] -> -1;

FLOAT
[ %st, %st1,        # stack head, stack neck
  %st2, %st3, %st4, %st5, %st6, %st7 ][80] -> 32..39;

INTEGER
%fsw[16] -> 40, #Float status word(16 Bit register Containing information about
                #The state of the FPU.  stores the top of stack pointer
                #information aswell as the exception flags and stack fault
                #information)

%fstp[8] -> 41, #Floating point stack pointer.  Holds the top of stack pointer.
                #NB is bits 11->13 inclusive of the fsw(defined above).

%fcw[16] -> 42; #Floating point Control Word (16 bit register holding
                #information such as the infinity control, rounding control,
                #precision control and exception masks.


ADDFLAGS8(op1, op2, result)  {
            *1* %CF := ((op1@[7:7]) and (op2@[7:7]))
                        or (~(result@[7:7]) and ((op1@[7:7]) or (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) and (op2@[7:7]) and ~(result@[7:7]))
                        or (~(op1@[7:7]) and ~(op2@[7:7]) and (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS16(op1, op2, result)  {
            *1* %CF := ((op1@[15:15]) and (op2@[15:15]))
                        or (~(result@[15:15]) and ((op1@[15:15]) or (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) and (op2@[15:15]) and ~(result@[15:15]))
                        or (~(op1@[15:15]) and ~(op2@[15:15]) and (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

ADDFLAGS32(op1, op2, result)  {
            *1* %CF := ((op1@[31:31]) and (op2@[31:31]))
                        or (~(result@[31:31]) and ((op1@[31:31]) or (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) and (op2@[31:31]) and ~(result@[31:31]))
                        or (~(op1@[31:31]) and ~(op2@[31:31]) and (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS8(op1, op2, result)  {
            *1* %CF := (~(op1@[7:7]) and (op2@[7:7]))
                        or ((result@[7:7]) and (~(op1@[7:7]) or (op2@[7:7])))
            *1* %OF := ((op1@[7:7]) and ~(op2@[7:7]) and ~(result@[7:7]))
                        or (~(op1@[7:7]) and (op2@[7:7]) and (result@[7:7]))
            *1* %NF := result@[7:7]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS16(op1, op2, result)  {
            *1* %CF := (~(op1@[15:15]) and (op2@[15:15]))
                        or ((result@[15:15]) and (~(op1@[15:15]) or (op2@[15:15])))
            *1* %OF := ((op1@[15:15]) and ~(op2@[15:15]) and ~(result@[15:15]))
                        or (~(op1@[15:15]) and (op2@[15:15]) and (result@[15:15]))
            *1* %NF := result@[15:15]
            *1* %ZF := [result = 0?1:0]
#       *1*  %PF := ??
#       *1*  %AF := ??                  # unpacked BCD
};

SUBFLAGS32(op1, op2, result)  {
            *1* %CF := (~(op1@[31:31]) and (op2@[31:31]))
                        or ((result@[31:31]) and (~(op1@[31:31]) or (op2@[31:31])))
            *1* %OF := ((op1@[31:31]) and ~(op2@[31:31]) and ~(result@[31:31]))
                        or (~(op1@[31:31]) and (op2@[31:31]) and (result@[31:31]))
            *1* %NF := result@[31:31]
            *1* %ZF := [result = 0?1:0]
#           *1*  %PF := ??
#           *1*  %AF := ??                  # unpacked BCD
};

LOGICALFLAGS8(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[7:7]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS16(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[15:15]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

LOGICALFLAGS32(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := [result = 0?1:0]
            *1* %NF := result@[31:31]
#           *1*  %PF := ??
#           *1*  %AF := ??
};

IMULTFLAGS8(result)  {
            *1* %CF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
            *1* %OF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
};

IMULTFLAGS16(result)  {
            *1* %CF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
            *1* %OF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
};

IMULTFLAGS32(result)  {
            *1* %CF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
            *1* %OF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
};

MULTFLAGS8(result)  {
            *1* %CF := [result@[8:15]?1:0]
            *1* %OF := [result@[8:15]?1:0]
};

MULTFLAGS16(result)  {
            *1* %CF := [result@[16:31]?1:0]
            *1* %OF := [result@[16:31]?1:0]
};

MULTFLAGS32(result)  {
            *1* %CF := [result@[32:63]?1:0]
            *1* %OF := [result@[32:63]?1:0]
};

ROLFLAGS8(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[7:7])! = %CF:-1]
            *1* %CF := result@[7:7]
};

ROLFLAGS16(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[15:15])! = %CF:-1]
            *1* %CF := result@[15:15]
};

ROLFLAGS32(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[31:31])! = %CF:-1]
            *1* %CF := result@[31:31]
};

RORFLAGS8(result, op1, count)  {
            *1* %CF := result@[7:7]
            *1* %OF := [count = 1?(op1@[7:7])! = (op1@[6:6]):-1]
};

RORFLAGS16(result, op1, count)  {
            *1* %CF := result@[15:15]
            *1* %OF := [count = 1?(op1@[15:15])! = (op1@[14:14]):-1]
};

RORFLAGS32(result, op1, count)  {
            *1* %CF := result@[31:31]
            *1* %OF := [count = 1?(op1@[31:31])! = (op1@[30:30]):-1]
};

SALFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(8 - count):(9 - count)]
            *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SALFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(16 - count):(17 - count)]
            *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SALFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(32 - count):(33 - count)]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SARFLAGS(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?0:-1]
};

SHRFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[7:7])! = %CF:-1]
};

SHRFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[15:15])! = %CF:-1]
};

SHRFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(count - 1):count]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(32 - count):(33 - count)]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHLDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(64 - count):(65 - count)]
            *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SHRDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(count - 1):count]
            *1* %OF := [count = 1?(result@[31:31])! = %CF:-1]
};

SHRDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(count - 1):count]
            *1* %OF := [count = 1?(result@[63:64])! = %CF:-1]
};

SETFFLAGS(op1, op2)  {
            *1* %FZF := [(op1 = op2) ? 1 : 0]
            *1* %FLF := [(op1 < op2) ? 1 : 0]
            *1* %C2 := 0 # [ (op1 > op2) ? 1 : 0]
};

OP1 := { "+", "-" };
ARIT := { "ADD", "SUB" };

ARIT[IDX]^"IAL" i8 
            *8* r[tmpb] := %al
            *8* %al := %al OP1[IDX] i8;
ADD.IAL   i8 ADDFLAGS8(r[tmpb], i8, %al);
SUB.IAL   i8 SUBFLAGS8(r[tmpb], i8, %al);

ARIT[IDX]^"IAX" i16 
            *16* r[tmph] := %ax
            *16* %ax := %ax OP1[IDX] i16;
ADD.IAX   i16 ADDFLAGS16(r[tmph], i16, %ax);
SUB.IAX   i16 SUBFLAGS16(r[tmph], i16, %ax);

ARIT[IDX]^"IEAX" i32 
            *32* r[tmp1] := %eax
            *32* %eax := %eax OP1[IDX] i32;
ADD.IEAX   i32 ADDFLAGS32(r[tmp1], i32, %eax);
SUB.IEAX   i32 SUBFLAGS32(r[tmp1], i32, %eax);

ARIT[IDX]^"ID" modrm, i32 
            *32* r[tmp1] := modrm
            *32* modrm := modrm OP1[IDX] i32;
ADD.ID   modrm, i32 ADDFLAGS32(r[tmp1], i32, modrm);
SUB.ID   modrm, i32 SUBFLAGS32(r[tmp1], i32, modrm);

ARIT[IDX]^"IW" modrm, i16 
            *16* r[tmph] := modrm
            *16* modrm := modrm OP1[IDX] i16;
ADD.IW   modrm, i16 ADDFLAGS16(r[tmph], i16, modrm);
SUB.IW   modrm, i16 SUBFLAGS16(r[tmph], i16, modrm);

ARIT[IDX]^"IB" modrm, i8 
            *8* r[tmpb] := modrm
            *8* modrm := modrm OP1[IDX] i8;
ADD.IB   modrm, i8 ADDFLAGS8(r[tmpb], i8, modrm);
SUB.IB   modrm, i8 SUBFLAGS8(r[tmpb], i8, modrm);

ARIT[IDX]^"IOWB" modrm, i8 
            *16* r[tmph] := modrm
            *16* modrm := modrm OP1[IDX] i8;
ADD.IOWB   modrm, i8 ADDFLAGS16(r[tmph], i8, modrm);
SUB.IOWB   modrm, i8 SUBFLAGS16(r[tmph], i8, modrm);

ARIT[IDX]^"IODB" modrm, i8 
            *32* r[tmp1] := modrm
            *32* modrm := modrm OP1[IDX] i8;
ADD.IODB   modrm, i8 ADDFLAGS32(r[tmp1], i8, modrm);
SUB.IODB   modrm, i8 SUBFLAGS32(r[tmp1], i8, modrm);

ARIT[IDX]^"MRB" modrm, reg8 
            *8* r[tmpb] := modrm
            *8* modrm := r[tmp1] OP1[IDX] r[reg8];
ADD.MRB   modrm, reg8 ADDFLAGS8(r[tmpb], r[reg8], modrm);
SUB.MRB   modrm, reg8 SUBFLAGS8(r[tmpb], r[reg8], modrm);

ARIT[IDX]^"MROW" modrm, reg16 
            *16* r[tmph] := modrm
            *16* modrm := r[tmp1] OP1[IDX] r[reg16];
ADD.MROW   modrm, reg16 ADDFLAGS16(r[tmph], r[reg16], modrm);
SUB.MROW   modrm, reg16 SUBFLAGS16(r[tmph], r[reg16], modrm);

ARIT[IDX]^"MROD" modrm, reg32 
            *32* r[tmp1] := modrm
            *32* modrm := modrm OP1[IDX] r[reg32];
ADD.MROD   modrm, reg32 ADDFLAGS32(r[tmp1], r[reg32], modrm);
SUB.MROD   modrm, reg32 SUBFLAGS32(r[tmp1], r[reg32], modrm);

ARIT[IDX]^"RMB" reg8, modrm 
            *8* r[tmpb] := r[reg8]
            *8* r[reg8] := r[reg8] OP1[IDX] modrm{8};
ADD.RMB   reg8, modrm ADDFLAGS8(r[tmpb], modrm{8}, r[reg8]);
SUB.RMB   reg8, modrm SUBFLAGS8(r[tmpb], modrm{8}, r[reg8]);

ARIT[IDX]^"RMOW" reg16, modrm 
            *16* r[tmph] := r[reg16]
            *16* r[reg16] := r[reg16] OP1[IDX] modrm{16};
ADD.RMOW   reg16, modrm ADDFLAGS16(r[tmph], modrm{16}, r[reg16]);
SUB.RMOW   reg16, modrm SUBFLAGS16(r[tmph], modrm{16}, r[reg16]);

ARIT[IDX]^"RMOD" reg32, modrm 
            *32* r[tmp1] := r[reg32]
            *32* r[reg32] := r[reg32] OP1[IDX] modrm;
ADD.RMOD   reg32, modrm ADDFLAGS32(r[tmp1], modrm, r[reg32]);
SUB.RMOD   reg32, modrm SUBFLAGS32(r[tmp1], modrm, r[reg32]);

CMP.IAL   i8 
            *8* r[tmpb] := %al - i8
            SUBFLAGS8(%al, i8, r[tmpb]);

CMP.IAX   i16 
            *16* r[tmph] := %ax - i16
            SUBFLAGS16(%ax, i16, r[tmph]);

CMP.IEAX   i32 
            *32* r[tmp1] := %eax - i32
            SUBFLAGS32(%eax, i32, r[tmp1]);

CMP.ID   modrm, i32 
            *32* r[tmp1] := modrm{32} - i32
            SUBFLAGS32(modrm, i32, r[tmp1]);

CMP.IW   modrm, i16 
            *16* r[tmph] := modrm{16} - i16
            SUBFLAGS16(modrm{16}, i16, r[tmph]);

CMP.IB   modrm, i8 
            *8* r[tmpb] := modrm{8} - i8
            SUBFLAGS8(modrm{8}, i8, r[tmpb]);

CMP.MRB   modrm, reg8 
            *8* r[tmpb] := modrm{8} - r[reg8]
            SUBFLAGS8(modrm{8}, r[reg8], r[tmpb]);

CMP.RMB   reg8, modrm 
            *8* r[tmpb] := r[reg8] - modrm{8}
            SUBFLAGS8(r[reg8], modrm{8}, r[tmpb]);

CMP.IODB   modrm, i8 
            *32* r[tmp1] := modrm{32} - i8
            SUBFLAGS32(modrm{32}, i8, r[tmp1]);

CMP.IOWB   modrm, i8 
            *16* r[tmph] := modrm{16} - i8
            SUBFLAGS16(modrm{16}, i8, r[tmph]);

CMP.MROW   modrm, reg16 
            *16* r[tmph] := modrm{16} - r[reg16]
            SUBFLAGS16(modrm{16}, r[reg16], r[tmph]);

CMP.MROD   modrm, reg32 
            *32* r[tmp1] := modrm{32} - r[reg32]
            SUBFLAGS32(modrm{32}, r[reg32], r[tmp1]);

CMP.RMOW   reg16, modrm 
            *16* r[tmph] := r[reg16] - modrm{16}
            SUBFLAGS16(r[reg16], modrm{16}, r[tmph]);

CMP.RMOD   reg32, modrm 
            *32* r[tmp1] := r[reg32] - modrm{32}
            SUBFLAGS32(r[reg32], modrm{32}, r[tmp1]);

OP1 := { "&", "|", "^" };
LOG := { "AND", "OR", "XOR" };

LOG[IDX]^"IAL" i8 
            *8* %al := %al OP1[IDX] i8
            LOGICALFLAGS8(%al);

LOG[IDX]^"IAX" i16 
            *16* %ax := %ax OP1[IDX] i16
            LOGICALFLAGS16(%ax);

LOG[IDX]^"IEAX" i32 
            *32* %eax := %eax OP1[IDX] i32
            LOGICALFLAGS32(%eax);

LOG[IDX]^"ID" modrm, i32 
            *32* modrm := modrm{32} OP1[IDX] i32
            LOGICALFLAGS32(modrm);

LOG[IDX]^"IW" modrm, i16 
            *16* modrm := modrm{16} OP1[IDX] i16
            LOGICALFLAGS16(modrm);

LOG[IDX]^"IB" modrm, i8 
            *8* modrm := modrm{8} OP1[IDX] i8
            LOGICALFLAGS8(modrm);

LOG[IDX]^"IODB" modrm, i8 
            *32* modrm := modrm OP1[IDX] i8!
            LOGICALFLAGS32(modrm);

LOG[IDX]^"MRB" modrm, reg8 
            *8* modrm := modrm{8} OP1[IDX] r[reg8]
            LOGICALFLAGS8(modrm);

LOG[IDX]^"MROW" modrm, reg16 
            *16* modrm := modrm{16} OP1[IDX] r[reg16]
            LOGICALFLAGS16(modrm);

LOG[IDX]^"MROD" modrm, reg32 
            *32* modrm := modrm{32} OP1[IDX] r[reg32]
            LOGICALFLAGS32(modrm);

LOG[IDX]^"RMB" reg8, modrm 
            *8* r[reg8] := r[reg8] OP1[IDX] modrm{8}
            LOGICALFLAGS8(r[reg8]);

LOG[IDX]^"RMOW" reg16, modrm 
            *16* r[reg16] := r[reg16] OP1[IDX] modrm{16}
            LOGICALFLAGS16(r[reg16]);

LOG[IDX]^"RMOD" reg32, modrm 
            *32* r[reg32] := r[reg32] OP1[IDX] modrm{32}
            LOGICALFLAGS32(r[reg32]);

OP2 := { "+", "-" };
ARITH_C := { "ADC", "SBB" };

ARITH_C[IDX]^"IAL" i8 
            *8* r[tmp1] := %al
            *8* %al := %al OP2[IDX] i8 OP2[IDX] %CF;
ADC.IAL   i8 ADDFLAGS8(r[tmp1], i8, %al);
SBB.IAL   i8 SUBFLAGS8(r[tmp1], i8, %al);
ARITH_C[IDX]^"IAL"   i8 _;

ARITH_C[IDX]^"IAX" i16 
            *16* r[tmp1] := %ax
            *16* %ax := %ax OP2[IDX] i16 OP2[IDX] %CF;
ADCIAX   i16 ADDFLAGS16(r[tmp1], i16, %ax);
SBBIAX   i16 SUBFLAGS16(r[tmp1], i16, %ax);

ARITH_C[IDX]^"IEAX" i32 
            *32* r[tmp1] := %eax
            *32* %eax := %eax OP2[IDX] i32 OP2[IDX] %CF;
ADC.IEAX   i32 ADDFLAGS32(r[tmp1], i32, %eax);
SBB.IEAX   i32 SUBFLAGS32(r[tmp1], i32, %eax);

ARITH_C[IDX]^"ID" reg32, i32 
            *32* r[tmp1] := r[reg32]
            *32* r[reg32] := r[reg32] OP2[IDX] i32 OP2[IDX] %CF;
ADC.ID   reg32, i32 ADDFLAGS32(r[tmp1], i32, r[reg32]);
SBB.ID   reg32, i32 SUBFLAGS32(r[tmp1], i32, r[reg32]);

ARITH_C[IDX]^"IW" reg16, i16 
            *16* r[tmp1] := r[reg16]
            *16* r[reg16] := r[reg16] OP2[IDX] i16 OP2[IDX] %CF;
ADC.IW   reg16, i16 ADDFLAGS16(r[tmp1], i16, r[reg16]);
SBB.IW   reg16, i16 SUBFLAGS16(r[tmp1], i16, r[reg16]);

ARITH_C[IDX]^"IB" reg8, i8 
            *8* r[tmp1] := r[reg8]
            *8* r[reg8] := r[reg8] OP2[IDX] i8 OP2[IDX] %CF;
ADC.IB   reg8, i8 ADDFLAGS8(r[tmp1], i8, r[reg8]);
SBB.IB   reg8, i8 SUBFLAGS8(r[tmp1], i8, r[reg8]);

ARITH_C[IDX]^"IODB" reg32, i8 
            *32* r[tmp1] := r[reg32]
            *32* r[reg32] := r[reg32] OP2[IDX] i8 OP2[IDX] %CF;
ADC.IODB   reg32, i8 ADDFLAGS32(r[tmp1], i8, r[reg32]);
SBB.IODB   reg32, i8 SUBFLAGS32(r[tmp1], i8, r[reg32]);

ARITH_C[IDX]^"MRB" modrm, reg8 
            *8* r[tmp1] := modrm
            *8* modrm := r[tmp1] OP2[IDX] r[reg8] OP2[IDX] %CF;
ADC.MRB   modrm, reg8 ADDFLAGS8(r[tmp1], r[reg8], modrm);
SBB.MRB   modrm, reg8 SUBFLAGS8(r[tmp1], r[reg8], modrm);

ARITH_C[IDX]^"MROW" modrm, reg16 
            *16* r[tmp1] := modrm{16}
            *16* modrm := r[tmp1] OP2[IDX] r[reg16] OP2[IDX] %CF;
ADC.MROW   modrm, reg16 ADDFLAGS16(r[tmp1], r[reg16], modrm{16});
SBB.MROW   modrm, reg16 SUBFLAGS16(r[tmp1], r[reg16], modrm{16});

ARITH_C[IDX]^"MROD" modrm, reg32 
            *32* r[tmp1] := modrm
            *32* modrm := modrm OP2[IDX] r[reg32] OP2[IDX] %CF;
ADC.MROD   modrm, reg32 ADDFLAGS32(r[tmp1], r[reg32], modrm);
SBB.MROD   modrm, reg32 SUBFLAGS32(r[tmp1], r[reg32], modrm);

ARITH_C[IDX]^"RMB" reg8, modrm 
            *8* r[tmpb] := r[reg8]
            *8* r[reg8] := r[reg8] OP2[IDX] modrm{8} OP2[IDX] %CF;
ADC.RMB   reg8, modrm ADDFLAGS8(r[tmpb], modrm{8}, r[reg8]);
SBB.RMB   reg8, modrm SUBFLAGS8(r[tmpb], modrm{8}, r[reg8]);

ARITH_C[IDX]^"RMOW" reg16, modrm 
            *16* r[tmph] := r[reg16]
            *16* r[reg16] := r[reg16] OP2[IDX] modrm{16} OP2[IDX] %CF;
ADC.RMOW   reg16, modrm ADDFLAGS16(r[tmph], modrm{16}, r[reg16]);
SBB.RMOW   reg16, modrm SUBFLAGS16(r[tmph], modrm{16}, r[reg16]);

ARITH_C[IDX]^"RMOD" reg32, modrm 
            *32* r[tmp1] := r[reg32]
            *32* r[reg32] := r[reg32] OP2[IDX] modrm OP2[IDX] %CF;
ADC.RMOD   reg32, modrm ADDFLAGS32(r[tmp1], modrm, r[reg32]);
SBB.RMOD   reg32, modrm SUBFLAGS32(r[tmp1], modrm, r[reg32]);

BT.od   modrm, reg32 
            *1* %CF := modrm@[r[reg32]:r[reg32]];

BTR.od   modrm, reg32 
            *32* r[tmp1] := 1 << r[reg32]
            *1* %CF := modrm@[r[reg32]:r[reg32]]
            *32* modrm := modrm & ~(r[tmp1]);

BTC.od   modrm, reg32 
            *32* r[tmp1] := 1 << r[reg32]
            *1* %CF := modrm@[r[reg32]:r[reg32]]
            *32* modrm := modrm ^ r[tmp1];

BTS.od   modrm, reg32 
            *32* r[tmp1] := 1 << r[reg32]
            *1* %CF := modrm@[r[reg32]:r[reg32]]
            *32* modrm := modrm | r[tmp1];

CALL.JVOW   reloc16 
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%pc)
            *32* %pc := %pc + 3 + reloc16;

CALL.JVOD   reloc32 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
            *32* %pc := %pc + 5 + reloc32;

CALL.APOD   seg, off 
            *32* %esp := %esp - 2
            *32* m[%esp] := %cs
            *32* %cs := seg
            *32* %esp := %esp - 4
            *16* m[%esp] := %pc
            *16* %pc := off;

CALL.EVOW   modrm 
            *32* %esp := %esp - 2
            *16* m[%esp] := truncs(32,16,%pc)
            *32* %pc := modrm{16};

CALL.EVOD   modrm 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
            *32* %pc := modrm;

CBW    
            *16* %ax := %al!;

CWDE    
            *32* %eax := sgnex(16,32,%eax);

CLC    
            *1* %CF := 0;

CLD    
            *1* %DF := 0;

CLI    
            *1* %IF := 0;

CMC    
            *1* %CF := ~(%CF);

CMPXCHG.EV.GB   modrm, reg8 
            *8* r[tmpb] := modrm{8}
            *8* modrm := [%al = r[tmpb]?r[reg8]:r[tmpb]]
            *8* %al := [%al = r[tmpb]?%al:r[tmpb]]
            *1* %ZF := [%al = r[tmpb]?1:0];

CMPXCHG.EV.GVOW   modrm, reg16 
            *16* r[tmph] := modrm{16}
            *16* modrm := [%ax = r[tmph]?r[reg16]:r[tmph]]
            *16* %ax := [%ax = r[tmph]?%ax:r[tmph]]
            *1* %ZF := [%ax = r[tmph]?1:0];

CMPXCHG.EV.GVOD   modrm, reg32 
            *32* r[tmp1] := modrm
            *32* modrm := [%eax = r[tmp1]?r[reg32]:r[tmp1]]
            *32* %eax := [%eax = r[tmp1]?%eax:r[tmp1]]
            *1* %ZF := [%eax = r[tmp1]?1:0];

CWD    
            *16* %dx := [%ax < 0?-1:0];

CDQ    
            *32* %edx := [%eax < 0?-1:0];

OP4 := { "-", "+" };
DEC_INC := { "DEC", "INC" };

DEC_INC[IDX].EB modrm 
            *8* r[tmpb] := modrm{8}
            *8* modrm := modrm{8} OP4[IDX] 1;
DEC.EB   modrm SUBFLAGS8(r[tmpb], 1, modrm{8});
INC.EB   modrm ADDFLAGS8(r[tmpb], 1, modrm{8});

DEC_INC[IDX].EVOW modrm 
            *16* r[tmph] := modrm{16}
            *16* modrm := modrm{16} OP4[IDX] 1;
DEC.EVOW   modrm SUBFLAGS16(r[tmph], 1, modrm{16});
INC.EVOW   modrm ADDFLAGS16(r[tmph], 1, modrm{16});

DEC_INC[IDX].EVOD modrm 
            *32* r[tmp1] := modrm
            *32* modrm := modrm OP4[IDX] 1;
DEC.EVOD   modrm SUBFLAGS32(r[tmp1], 1, modrm);
INC.EVOD   modrm ADDFLAGS32(r[tmp1], 1, modrm);

DEC_INC[IDX].OW reg16 
            *16* r[tmph] := r[reg16]
            *16* r[reg16] := r[reg16] OP4[IDX] 1;
DEC.OW   reg16 SUBFLAGS16(r[tmph], 1, r[reg16]);
INC.OW   reg16 ADDFLAGS16(r[tmph], 1, r[reg16]);

DEC_INC[IDX].OD reg32 
            *32* r[tmp1] := r[reg32]
            *32* r[reg32] := r[reg32] OP4[IDX] 1;
DEC.OD   reg32 SUBFLAGS32(r[tmp1], 1, r[reg32]);
INC.OD   reg32 ADDFLAGS32(r[tmp1], 1, r[reg32]);

DIV.AL   modrm 
            *16* r[tmph] := %ax
            *8* %al := r[tmph] / modrm{8}
            *8* %ah := r[tmph] % modrm{8}
            undefineflags( );

DIV.AX   modrm 
            *32* r[tmp1] := (zfill(16,32,%dx) << 16) | zfill(16,32,%ax)
            *16* r[tmph] := modrm{16}
            *16* %ax := r[tmp1] / r[tmph]
            *16* %dx := r[tmp1] % r[tmph]
            undefineflags( );

DIV.EAX   modrm 
            *64* r[tmpl] := (zfill(32,64,%edx) << 32) | zfill(32,64,%eax)
            *32* r[tmp2] := modrm
            *32* %eax := r[tmpl] / r[tmp2]
            *32* %edx := r[tmpl] % r[tmp2]
            undefineflags( );

ENTER   i16, i8 
            *32* r[tmpb] := i8
            *32* %esp := %esp - 4
            *32* m[%esp] := %ebp
            *32* %FP := %esp
            *32* %ebp := %FP
            *32* %esp := %esp - i16;

IDIV   modrm 
            *16* r[tmph] := %ax
            *8* %al := r[tmph] /! modrm{8}
            *8* %ah := r[tmph] %! modrm{8}
            undefineflags( );

IDIV.AX   modrm 
            *32* r[tmp1] := (%dx << 16)! | %ax
            *16* r[tmph] := modrm{16}
            *16* %ax := r[tmp1] /! r[tmph]
            *16* %dx := r[tmp1] %! r[tmph]
            undefineflags( );

IDIV.EAX   modrm 
            *64* r[tmpl] := (%edx << 32)! | %eax
            *32* r[tmp2] := modrm
            *32* %eax := r[tmpl] /! r[tmp2]
            *32* %edx := r[tmpl] %! r[tmp2]
            undefineflags( );

IMUL.B   modrm 
            *16* r[tmph] := %al *! modrm{8}
            *16* %ax := r[tmph]
            IMULTFLAGS8(r[tmph]);

IMUL.OW   modrm 
            *32* r[tmp2] := %ax *! modrm
            *16* %ax := truncu(32,16,r[tmp2])
            *16* %dx := truncu(32,16,r[tmp2] >> 16)
            IMULTFLAGS16(r[tmp2]);

IMUL.OD   modrm 
            *64* r[tmpl] := %eax *! modrm
            *32* %eax := truncu(64,32,r[tmpl])
            *32* %edx := truncu(64,32,r[tmpl] >> 32)
            IMULTFLAGS32(r[tmpl]);

IMUL.RMOW   reg16, modrm 
            *16* r[reg16] := modrm{16} *! r[reg16]
            IMULTFLAGS16(r[reg16]);

IMUL.RMOD   reg32, modrm 
            *32* r[reg32] := modrm{32} *! r[reg32]
            IMULTFLAGS32(r[reg32]);

IMUL.IVW   reg16, modrm, i16 
            *16* r[reg16] := modrm{16} *! i16
            IMULTFLAGS16(r[reg16]);

IMUL.IVD   reg32, modrm, i32 
            *32* r[reg32] := modrm{32} *! i32
            IMULTFLAGS32(r[reg32]);

IMUL.Ibow   reg16, modrm, i8 
            *16* r[reg16] := modrm{8} *! sgnex(8,16,i8)
            IMULTFLAGS32(r[reg16]);

IMUL.Ibod   reg32, modrm, i8 
            *32* r[reg32] := modrm{32} *! sgnex(8,32,i8)
            IMULTFLAGS32(r[reg32]);

COND1 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
            "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
            "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF",
            "~(%NF ^ %OF)", "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF",
            "(%NF ^ %OF) | %ZF", "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF",
            "~%ZF", "~%OF", "~%PF", "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP32S := { "JVA", "JVNBE", "JVAE", "JVNB", "JVB", "JVNAE", "JVBE",
            "JVNA", "JVC", "JVCXZ", "JVE", "JVZ", "JVG", "JVNLE", "JVGE",
            "JVNL", "JVL", "JVNGE", "JVLE", "JVNG", "JVNC", "JVNE", "JVNZ",
            "JVNO", "JVNP", "JVPO", "JVNS", "JVO", "JVP", "JVPE", "JVS" };

JMP32S[IDX]   reloc32 
            *32* %pc := [(COND1[IDX] = 1)?%pc + 6 + reloc32:%pc];

COND2 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
           "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
           "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF)",
           "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF", "(%NF ^ %OF) | %ZF",
           "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF", "~%ZF", "~%OF", "~%PF",
           "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP16S := { "JWA", "JWNBE", "JWAE", "JWNB", "JWB", "JWNAE", "JWBE",
            "JWNA", "JWC", "JWCXZ", "JWE", "JWZ", "JWG", "JWNLE", "JWGE",
            "JWNL", "JWL", "JWNGE", "JWLE", "JWNG", "JWNC", "JWNE", "JWNZ",
            "JWNO", "JWNP", "JWPO", "JWNS", "JWO", "JWP", "JWPE", "JWS" };

JMP16S[IDX]   reloc16 
            *32* %pc := [(COND2[IDX] = 1)?%pc + 4 + reloc16:%pc];

COND3 := { "~%CF & ~%ZF", "~%CF & ~%ZF", "~%CF", "~%CF", "%CF",
           "%CF", "%CF | %ZF", "%CF | %ZF", "%CF", "~%cx", "%ZF",
           "%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF) & ~%ZF", "~(%NF ^ %OF)",
           "~(%NF ^ %OF)", "%NF ^ %OF", "%NF ^ %OF", "(%NF ^ %OF) | %ZF",
           "(%NF ^ %ZF) | %ZF", "~%CF", "~%ZF", "~%ZF", "~%OF", "~%PF",
           "~%PF", "~%NF", "%OF", "%PF", "%PF", "%NF" };
JMP8S := { "JBA", "JBNBE", "JBAE", "JBNB", "JBB", "JBNAE", "JBBE", "JBNA",
           "JBC", "JBCXZ", "JBE", "JBZ", "JBG", "JBNLE", "JBGE", "JBNL",
           "JBL", "JBNGE", "JBLE", "JBNG", "JBNC", "JBNE", "JBNZ", "JBNO",
           "JBNP", "JBPO", "JBNS", "JBO", "JBP", "JBPE", "JBS" };

JMP8S[IDX]   reloc8 
            *32* %pc := [(COND3[IDX] = 1)?%pc + 2 + reloc8:%pc];

JMP.JB   reloc8 
            *32* %pc := %pc + 2 + reloc8;

JMP.JVOW   reloc16 
            *32* %pc := %pc + 3 + reloc16;

JMP.JVOD   reloc32 
            *32* %pc := %pc + 5 + reloc32;

JMP.EVOW   modrm 
            *16* %pc := modrm;

JMP.EVOD   modrm 
            *32* %pc := modrm;

LEA.OD   reg32, mem 
            *32* r[reg32] := addr(mem);

LEA.OW   reg16, mem 
            *16* r[reg16] := addr(mem);

LEAVE    
            *32* %esp := %ebp
            *32* %ebp := m[%esp]
            *32* %esp := %esp + 4;

COND4 := { "%ecx ~= 0", "%ecx ~= 0 & %ZF", "%ecx ~= 0 & %ZF",
           "%ecx ~= 0 & ~%ZF", "%ecx ~= 0 & ~%ZF" };
LOOPS := { "LOOP", "LOOPE", "LOOPZ", "LOOPNE", "LOOPNZ" };

LOOPS[IDX]   reloc 
            *32* %ecx := %ecx - 1
            *32* %pc := [COND4[IDX]?%pc + reloc:%pc];

MOV.EB.IB   modrm, i8 
            *8* modrm := i8;

MOV.EB.IVOW   modrm, i8 
            *16* modrm := i8!;

MOV.EB.IVOD   modrm, i8 
            *32* modrm := i8!;

MOV.IB   reg8, i8 
            *8* r[reg8] := i8;

MOV.IW   reg16, i16 
            *16* r[reg16] := i16;

MOV.ID   reg32, i32 
            *32* r[reg32] := i32;

MOV.MRB   modrm, reg8 
            *8* modrm := r[reg8];

MOV.MROW   modrm, reg16 
            *16* modrm := r[reg16];

MOV.MROD   modrm, reg32 
            *32* modrm := r[reg32];

MOV.OB.AL   off 
            *8* m[off] := %al;

MOV.OV.EAXOW   off 
            *16* m[off] := %ax;

MOV.OV.EAXOD   off 
            *32* m[off] := %eax;

MOV.AL.OB   off 
            *8* %al := m[off]{8};

MOV.EAX.OVOW   off 
            *16* %ax := m[off]{16};

MOV.EAX.OVOD   off 
            *32* %eax := m[off]{32};

MOV.RMB   reg8, modrm 
            *8* r[reg8] := modrm{8};

MOV.RMOW   reg16, modrm 
            *16* r[reg16] := modrm{16};

MOV.RMOD   reg32, modrm 
            *32* r[reg32] := modrm{32};

MOVSX.GV.EBOW   reg16, modrm 
            *16* r[reg16] := sgnex(8, 16, modrm{8});

MOVSX.GV.EBOD   reg32, modrm 
            *32* r[reg32] := sgnex(8, 32, modrm{8});

MOVSX.GV.EW   reg32, modrm 
            *32* r[reg32] := sgnex(16, 32, modrm{16});

MOVZX.GV.EBOW   reg16, modrm 
            *16* r[reg16] := zfill(8, 16, modrm{8});

MOVZX.GV.EBOD   reg32, modrm 
            *32* r[reg32] := zfill(8, 32, modrm{8});

MOVZX.GV.EW   reg32, modrm 
            *32* r[reg32] := zfill(16, 32, modrm{16});

MUL^"AL"   modrm 
            *8* r[tmpb] := modrm{8}
            *16* %ax := %al * r[tmpb]
            MULTFLAGS8(%ax);

MUL.AXOW   modrm 
            *32* r[tmp2] := %eax * modrm{16}
            *16* %ax := r[tmp2]
            *16* %dx := r[tmp2] >> 16
            MULTFLAGS16(r[tmp2]);

MUL.AXOD   modrm 
            *32* r[tmp1] := modrm{32}
            *64* r[tmpl] := zfill(32,64,%eax) * zfill(32,64,r[tmp1])
            *32* %eax := r[tmpl]
            *32* %edx := r[tmpl] >> 32
            MULTFLAGS32(r[tmpl]);

NEG.B   modrm 
            *8* r[tmpb] := modrm{8}
            *8* modrm := 0 - modrm{8}
            SUBFLAGS8(0, r[tmpb], modrm{8});

NEG.OW   modrm 
            *16* r[tmph] := modrm{16}
            *16* modrm := 0 - modrm{16}
            SUBFLAGS16(0, r[tmph], modrm);

NEG.OD   modrm 
            *32* r[tmp1] := modrm{32}
            *32* modrm := 0 - modrm{32}
            SUBFLAGS32(0, r[tmp1], modrm);

NOP    
            _ ;

NOT.B   modrm 
            *8* modrm := ~modrm{8};

NOT.OW   modrm 
            *16* modrm := ~modrm{16};

NOT.OD   modrm 
            *32* modrm := ~modrm{32};

POP.EVOW   modrm 
            *16* modrm := m[%esp]
            *32* %esp := %esp + 2;

POP.EVOD   modrm 
            *32* modrm := m[%esp]
            *32* %esp := %esp + 4;

POP.OW   reg16 
            *16* r[reg16] := m[%esp]{16}
            *32* %esp := %esp + 2;

POP.OD   reg32 
            *32* r[reg32] := m[%esp]{32}
            *32* %esp := %esp + 4;

PUSH.EVOW   modrm 
            *32* %esp := %esp - 2
            *16* m[%esp] := modrm{16};

PUSH.EVOD   modrm 
            *32* %esp := %esp - 4
            *32* m[%esp] := modrm{32};

PUSH.IXOB   i8 
            *32* %esp := %esp - 4
            *32* m[%esp] := i8;

# Note: 66 6A nn: 8 bit immediate operand (nn), but 16 bit push!
PUSH.IXOW   i8
            *16* %esp := %esp - 2
            *16* m[%esp] := i8;

PUSH.IVOW   i16 
            *32* %esp := %esp - 2
            *16* m[%esp] := i16;

PUSH.IVOD   i32 
            *32* %esp := %esp - 4
            *32* m[%esp] := i32;

PUSH.OW   reg16 
            *32* %esp := %esp - 2
            *16* m[%esp] := r[reg16];

PUSH.OD   reg32 
            *32* %esp := %esp - 4
            *32* m[%esp] := r[reg32];

OP4 := { "rlc", "rrc", "rl", "rr" };
ROT := { "RCL", "RCR", "ROL", "ROR" };

ROLS := { "RCL","ROL" };
RORS := { "RCR","ROR" };
ROT[IDX].B.EV.1 modrm 
            *8* r[tmpb1] := modrm{8}
            *8* r[tmpb2] := r[tmpb] OP4[IDX] 1
            *8* modrm := r[tmpb2];
ROLS[IDX].B.EV.1 modrm   ROLFLAGS8(r[tmpb2], r[tmpb1], 1);
RORS[IDX].B.EV.1 modrm   RORFLAGS8(r[tmpb2], r[tmpb1], 1);

ROT[IDX].B.EV.1OW modrm 
            *16* r[tmph1] := modrm{16}
            *16* r[tmph2] := r[tmph1] OP4[IDX] 1
            *16* modrm := r[tmph2];
ROLS[IDX].B.EV.1OW modrm   ROLFLAGS16(r[tmph2], r[tmph1], 1);
RORS[IDX].B.EV.1OW modrm   RORFLAGS16(r[tmph2], r[tmph1], 1);

ROT[IDX].B.EV.1OD modrm 
            *32* r[tmp1] := modrm{32}
            *32* r[tmp2] := r[tmp1] OP4[IDX] 1
            *32* modrm := r[tmp2];
ROLS[IDX].B.EV.1OD modrm   ROLFLAGS32(r[tmp2], r[tmp1], 1);
RORS[IDX].B.EV.1OD modrm   RORFLAGS32(r[tmp2], r[tmp1], 1);

ROT[IDX].B.EV.CL modrm 
            *8* r[tmpb1] := modrm{8}
            *8* r[tmpb2] := r[tmpb1] OP4[IDX] %ecx
            *8* modrm := r[tmpb2];
ROLS[IDX].B.EV.CL   modrm  ROLFLAGS8(r[tmpb2], r[tmpb1], %ecx);
RORS[IDX].B.EV.CL   modrm  RORFLAGS8(r[tmpb2], r[tmpb1], %ecx);

ROT[IDX].B.EV.CLOW modrm 
            *16* r[tmph1] := modrm{16}
            *16* r[tmph2] := r[tmph1] OP4[IDX] %ecx
            *16* modrm := r[tmph2];
ROLS[IDX].B.EV.CLOW   modrm  ROLFLAGS16(r[tmph2], r[tmph1], %ecx);
RORS[IDX].B.EV.CLOW   modrm  RORFLAGS16(r[tmph2], r[tmph1], %ecx);

ROT[IDX].B.EV.CLOD modrm 
            *32* r[tmp1] := modrm{32}
            *32* r[tmp2] := r[tmp1] OP4[IDX] %ecx
            *32* modrm := r[tmp2];
ROLS[IDX].B.EV.CLOD   modrm  ROLFLAGS32(r[tmp2], r[tmp1], %ecx);
RORS[IDX].B.EV.CLOD   modrm  RORFLAGS32(r[tmp2], r[tmp1], %ecx);

ROT[IDX].B.EB.IB modrm, i8 
            *8* r[tmpb1] := modrm{8}
            *8* r[tmpb2] := r[tmpb1] OP4[IDX] i8
            *8* modrm := r[tmpb2];
ROLS[IDX].B.EB.IB   modrm, i8  ROLFLAGS8(r[tmpb2], r[tmpb1], i8);
RORS[IDX].B.EB.IB   modrm, i8  RORFLAGS8(r[tmpb2], r[tmpb1], i8);

ROT[IDX].B.EV.IBOW modrm, i8 
            *16* r[tmph1] := modrm{16}
            *16* r[tmph2] := r[tmph1] OP4[IDX] i8!
            *16* modrm := r[tmph2];
ROLS[IDX].B.EV.IBOW   modrm, i8  
            ROLFLAGS16(r[tmph2], r[tmph1], i8);
RORS[IDX].B.EV.IBOW   modrm, i8  
            RORFLAGS16(r[tmph2], r[tmph1], i8);

ROT[IDX].B.EV.IBOD modrm, i8 
            *32* r[tmp1] := modrm{8}
            *32* r[tmp2] := r[tmp1] OP4[IDX] i8
            *32* modrm := r[tmp2];
ROLS[IDX].B.EV.IBOD   modrm, i8  ROLFLAGS32(r[tmp2], r[tmp1], i8);
RORS[IDX].B.EV.IBOD   modrm, i8  RORFLAGS32(r[tmp2], r[tmp1], i8);

# These were wrong anyway; they combine with the opcode as well. For example,
# opcode F2 (REP/REPZ) means "repeat regardless of Z flag" for MOV/LOD/STO,
# but it means "repeat while Z=1" for CMP/SCA.
#REPT := { "REP", "REPNE", "REPNZ" };

#REPT[IDX]    
#            *1* %SKIP := [(%ecx = 0)?1:%SKIP]
#            *1* %RPT := [(%ecx = 0)?0:1]
#            *32* %ecx := [(%ecx > 0)?%ecx - 1:%ecx];

#REPTZF := { "REPE", "REPZ" };

#REPTZF[IDX]    
#            *1* %SKIP := [(%ecx = 0)?1:%SKIP]
#            *1* %RPT := [(%ecx = 0)?0:1]
#            *32* %ecx := [(%ecx > 0 and %ZF = 0)?%ecx - 1:%ecx];

RET    
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4;

RET.IW   i16 
            *32* %pc := m[%esp]{32}
            *32* %esp := %esp + 4 + i16;

SAHF    
            *1* %NF := %ah@[7:7]
            *1* %ZF := %ah@[6:6]
            *1* %PF := %ah@[2:2]
            *1* %CF := %ah@[0:0];

SETB.B   modrm 
            *8* modrm := [%CF?1:0];

SETB.NB   modrm 
            *8* modrm := [~%CF?1:0];

SETB.BE   modrm 
            *8* modrm := [%CF | %ZF?1:0];

SETB.NBE   modrm 
            *8* modrm := [~%CF & ~%ZF?1:0];

SETB.L   modrm 
            *8* modrm := [%NF! = %OF?1:0];

SETB.NL   modrm 
            *8* modrm := [%NF = %OF?1:0];

SETB.O   modrm 
            *8* modrm := [%OF?1:0];

SETB.NO   modrm 
            *8* modrm := [~%OF?1:0];

SETB.P   modrm 
            *8* modrm := [%PF?1:0];

SETB.NP   modrm 
            *8* modrm := [~%PF = 0?1:0];

SETB.S   modrm 
            *8* modrm := [%NF?1:0];

SETB.NS   modrm 
            *8* modrm := [~%NF?1:0];

SETB.Z   modrm 
            *8* modrm := [%ZF?1:0];

SETB.NZ   modrm 
            *8* modrm := [~%ZF?1:0];

SETB.LE   modrm 
            *8* modrm := [%ZF | %NF! = %OF?1:0];

SETB.NLE   modrm 
            *8* modrm := [~%ZF & %NF = %OF?1:0];

OP5 := { "<<", ">>A", ">>" };
SHT := { "SHLSAL", "SAR", "SHR" };

SHT[IDX].B.EB.1 modrm 
            *8* r[tmpb] := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] 1;
SHLSAL.B.EB.1   modrm  SALFLAGS8(modrm{8}, r[tmpb], 1);
SAR.B.EB.1   modrm  SARFLAGS(modrm{8}, r[tmpb], 1);
SHR.B.EB.1   modrm  SHRFLAGS8(modrm{8}, r[tmpb], 1);

SHT[IDX].B.EV.1OW modrm 
            *16* r[tmph] := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] 1;
SHLSAL.B.EV.1OW   modrm  SALFLAGS16(modrm{16}, modrm{16}, 1);
SAR.B.EV.1OW   modrm  SARFLAGS(modrm{16}, r[tmph], 1);
SHR.B.EV.1OW   modrm  SHRFLAGS16(modrm{16}, r[tmph], 1);

SHT[IDX].B.EV.1OD modrm 
            *32* r[tmp1] := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] 1;
SHLSAL.B.EV.1OD   modrm  SALFLAGS32(modrm, r[tmp1], 1);
SAR.B.EV.1OD   modrm  SARFLAGS(modrm, r[tmp1], 1);
SHR.B.EV.1OD   modrm  SHRFLAGS32(modrm, r[tmp1], 1);

SHT[IDX].B.EB.CL modrm 
            *8* r[tmpb] := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] %ecx;
SHLSAL.B.EB.CL   modrm  SALFLAGS8(modrm{8}, r[tmpb], %ecx);
SAR.B.EB.CL   modrm  SARFLAGS(modrm{8}, r[tmpb], %ecx);
SHR.B.EB.CL   modrm  SHRFLAGS8(modrm{8}, r[tmpb], %ecx);

SHT[IDX].B.EV.CLOW modrm 
            *16* r[tmph] := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] %ecx;
SHLSAL.B.EV.CLOW   modrm   SALFLAGS16(modrm{16}, r[tmph], %ecx);
SAR.B.EV.CLOW   modrm   SARFLAGS(modrm{16}, r[tmph], %ecx);
SHR.B.EV.CLOW   modrm   SHRFLAGS16(modrm{16}, r[tmph], %ecx);

SHT[IDX].B.EV.CLOD modrm 
            *32* r[tmp1] := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] %ecx;
SHLSAL.B.EV.CLOD   modrm   SALFLAGS32(modrm, r[tmp1], %ecx);
SAR.B.EV.CLOD   modrm   SARFLAGS(modrm, r[tmp1], %ecx);
SHR.B.EV.CLOD   modrm   SHRFLAGS32(modrm, r[tmp1], %ecx);

SHT[IDX].B.EB.IB modrm, i8 
            *8* r[tmpb] := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] i8;
SHLSAL.B.EB.IB   modrm, i8   SALFLAGS8(modrm{8}, r[tmpb], i8);
SAR.B.EB.IB   modrm, i8   SARFLAGS(modrm{8}, r[tmpb], i8);
SHR.B.EB.IB   modrm, i8   SHRFLAGS8(modrm{8}, r[tmpb], i8);

SHT[IDX].B.EV.IBOW modrm, i8 
            *16* r[tmph] := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] i8;
SHLSAL.B.EV.IBOW   modrm, i8   SALFLAGS16(modrm{16}, r[tmph], i8);
SAR.B.EV.IBOW   modrm, i8   SARFLAGS(modrm{16}, r[tmph], i8);
SHR.B.EV.IBOW   modrm, i8   SHRFLAGS16(modrm{16}, r[tmph], i8);

SHT[IDX].B.EV.IBOD modrm, i8 
            *32* r[tmp1] := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] i8;
SHLSAL.B.EV.IBOD   modrm, i8   SALFLAGS32(modrm, r[tmp1], i8);
SAR.B.EV.IBOD   modrm, i8   SARFLAGS(modrm, r[tmp1], i8);
SHR.B.EV.IBOD   modrm, i8   SHRFLAGS32(modrm, r[tmp1], i8);

OP6 := { "<<", ">>" };
SHTD := { "SHLD", "SHRD" };

SHTD[IDX].CLOW modrm, reg16 
            *32* r[tmp1] := [%cl > 31?%cl:31]
            *32* r[tmp2] := r[reg16] << 16
            *32* r[tmp3] := r[tmp2] + modrm{16}
            *32* r[tmp5] := r[tmp3] OP6[IDX] r[tmp1]
            *16* modrm := r[tmp5];
SHLD.CLOW   modrm, reg16  SHLDFLAGS32(r[tmp5], r[tmp3], r[tmp1]);
SHRD.CLOW   modrm, reg16  SHRDFLAGS32(r[tmp5], r[tmp3], r[tmp1]);

SHTD[IDX].CLOD modrm, reg32 
            *32* r[tmp1] := [%cl > 31?%cl:31]
            *64* r[tmp2] := r[reg32] << 32
            *64* r[tmp3] := r[tmp2] + modrm
            *64* r[tmp5] := r[tmp3] OP6[IDX] r[tmp1]
            *32* modrm := r[tmp5];
SHLD.CLOD   modrm, reg32  SHLDFLAGS64(r[tmp5], r[tmp3], r[tmp1]);
SHRD.CLOD   modrm, reg32  SHRDFLAGS64(r[tmp5], r[tmp3], r[tmp1]);

SHTD[IDX].IBOW modrm, reg16, cnt 
            *32* r[tmp1] := [cnt > 31?cnt:31]
            *32* r[tmp2] := r[reg16] << 16
            *32* r[tmp3] := r[tmp2] + modrm{16}
            *32* r[tmp5] := r[tmp3] OP6[IDX] r[tmp1]
            *16* modrm := r[tmp5];
SHLD.IBOW   modrm, reg16, cnt   SHLDFLAGS32(r[tmp5], r[tmp3], r[tmp1]);
SHRD.IBOW   modrm, reg16, cnt   SHRDFLAGS32(r[tmp5], r[tmp3], r[tmp1]);

SHTD[IDX].IBOD modrm, reg32, cnt 
            *32* r[tmp1] := [cnt > 31?cnt:31]
            *64* r[tmp2] := r[reg32] << 32
            *64* r[tmp3] := r[tmp2] + modrm{32}
            *64* r[tmp5] := r[tmp3] OP6[IDX] r[tmp1]
            *32* modrm := r[tmp5];
SHLD.IBOD   modrm, reg32, cnt  SHLDFLAGS64(r[tmp5], r[tmp3], r[tmp1]);
SHRD.IBOD   modrm, reg32, cnt  SHRDFLAGS64(r[tmp5], r[tmp3], r[tmp1]);

STC    *1* %CF := 1;

STD    *1* %DF := 1;

STI    *1* %IF := 1;

# The string instructions
REPS := {"REP", "REPNE"};                   # Repeat prefixes
OREPS := { REPS, ""};                       # Optional repeat prefixes
ALLSZ := {"B", "VOW", "VOD"};               # All size suffixes

# String instructions, not repeated
STRS := { "CMPS", "LODS", "MOVS", "SCAS", "STOS" };

# String instructions, repeated
STRS_R := REPS STRS;

# String instructions, optionally repeated
STRS_OR := OREPS STRS;

STRFL :=       { "CMPS", "SCAS"};                   # Update flags
STRNF :=       { "LODS", "MOVS", "STOS"};           # No update flags
STRSI := OREPS { "CMPS", "LODS", "MOVS" };          # Update esi
STRDI := OREPS { "CMPS", "MOVS", "SCAS", "STOS" };  # Update edi
STRFL_OR := OREPS STRFL;                            # Optionally repeated; flags

CMPS_OR := OREPS CMPS;      # Compare with optional repeat
LODS_OR := OREPS LODS;      # Load with optional repeat
MOVS_OR := OREPS MOVS;      # Move with optional repeat
SCAS_OR := OREPS SCAS;      # Scan with optional repeat
STOS_OR := OREPS STOS;      # Store with optional repeat

# All repeated string instructions
STRS_R[X]ALLSZ[Y]
            *1* %SKIP := (%ecx = 0);

CMPS_OR[X].B
            *8* r[tmpb] := m[%esi]{8} - m[%edi]{8};
LODS_OR[X].B   
            *8* %al := m[%esi]{8};
MOVS_OR[X].B   
            *8* m[%edi] := m[%esi]{8};
SCAS_OR[X].B   
            *8* r[tmpb] := %al - m[%edi]{8};
STOS_OR[X].B   
            *8* m[%edi] := %al;
STRFL_OR[X].B   
            SUBFLAGS8(m[%esi]{8}, m[%edi]{8}, r[tmpb]);
STRSI[IDX].B   
            *32* %esi := %esi + [%DF = 0?1:-1];
STRDI[IDX].B   
            *32* %edi := %edi + [%DF = 0?1:-1];

CMPS_OR[X].VOW   
            *16* r[tmph] := m[%esi]{16} - m[%edi]{16};
LODS_OR[X].VOW   
            *16* %eax := m[%esi]{16};
MOVS_OR[X].VOW   
            *16* m[%edi] := m[%esi]{8};
SCAS_OR[X].VOW   
            *16* r[tmph] := %eax - m[%edi];
STOS_OR[X].VOW   
            *16* m[%edi] := %eax;
STRFL_OR[X].VOW   
            SUBFLAGS16(m[%esi]{16}, m[%edi]{16}, r[tmph]);
STRSI[IDX].VOW   
            *16* %esi := %esi + [%DF = 0?2:-2];
STRDI[IDX].VOW   
            *16* %edi := %edi + [%DF = 0?2:-2];

CMPS_OR[X].VOD   
            *32* r[tmp1] := m[%esi]{32} - m[%edi]{32};
LODS_OR[X].VOD   
            *32* %eax := m[%esi]{32};
MOVS_OR[X].VOD   
            *32* m[%edi] := m[%esi]{32};
SCAS_OR[X].VOD   
            *32* r[tmp1] := %eax - m[%edi];
STOS_OR[X].VOD   
            *32* m[%edi] := %eax;
STRFL_OR[X].VOD   
            SUBFLAGS32(m[%esi]{32}, m[%edi]{32}, r[tmp1]);
STRSI[IDX].VOD   
            *32* %esi := %esi + [%DF = 0?4:-4];
STRDI[IDX].VOD   
            *32* %edi := %edi + [%DF = 0?4:-4];

# All repeated instructions decrement %ecx
STRS_R[X]ALLSZ[Y]
            *32* %ecx := %ecx - 1;

# Do the repeat logic
REPIFZ := REP STRFL;
REPIFZ[X]ALLSZ[Y]
            *1* %RPT := %ZF;

REPIFNZ := REPNE STRFL;
REPIFNZ[X]ALLSZ[Y]
            *1* %RPT := ~%ZF;

REPALL := REPS STRNF;
REPALL[X]ALLSZ[Y]
            *1* %RPT := 1;

# End string instructions


TEST.AL.IB   i8 
            *8* r[tmpb] := %al & i8
            LOGICALFLAGS8(r[tmpb]);

TEST.EAX.IVOW   i16 
            *16* r[tmph] := %eax & i16
            LOGICALFLAGS16(r[tmph]);

TEST.EAX.IVOD   i32 
            *32* r[tmp1] := %eax & i32
            LOGICALFLAGS32(r[tmp1]);

TEST.EB.IB   modrm, i8 
            *8* r[tmpb] := modrm{8} & i8
            LOGICALFLAGS8(r[tmpb]);

TEST.EW.IW   modrm, i16 
            *16* r[tmph] := modrm{16} & i16
            LOGICALFLAGS16(r[tmph]);

TEST.ED.ID   modrm, i32 
            *32* r[tmp1] := modrm{32} & i32
            LOGICALFLAGS32(r[tmp1]);

TEST.EV.GB   modrm, reg8 
            *8* r[tmpb] := modrm{8} & r[reg8]
            LOGICALFLAGS8(r[tmpb]);

TEST.EB.GB   modrm, reg8 
            *8* r[tmpb] := modrm{8} & r[reg8]
            LOGICALFLAGS8(r[tmpb]);

TEST.EV.GVOW   modrm, reg16 
            *16* r[tmph] := modrm{16} & r[reg16]
            LOGICALFLAGS16(r[tmph]);

TEST.EV.GVOD   modrm, reg32 
            *32* r[tmp1] := modrm{32} & r[reg32]
            LOGICALFLAGS32(r[tmp1]);

WAIT    _ ;

XADD.EV.GB   modrm, reg8 
            *8* r[tmp1] := modrm{8}
            *8* r[tmp2] := r[reg8]
            *8* modrm := r[tmp1] + r[reg8]
            *8* r[reg8] := r[tmp1]
            ADDFLAGS8(r[tmp1], r[tmp2], modrm);

XADD.EV.GVOW   modrm, reg16 
            *16* r[tmp1] := modrm{16}
            *16* r[tmp2] := r[reg16]
            *16* modrm := r[tmp1] + r[reg16]
            *16* r[reg16] := r[tmp1]
            ADDFLAGS16(r[tmp1], r[tmp2], modrm);

XADD.EV.GVOD   modrm, reg32 
            *32* r[tmp1] := modrm{32}
            *32* r[tmp2] := r[reg32]
            *32* modrm := r[tmp1] + r[reg32]
            *32* r[reg32] := r[tmp1]
            ADDFLAGS32(r[tmp1], r[tmp2], modrm);

XCHG.EAXOD   reg32 
            *32* r[tmp1] := r[reg32]
            *32* r[reg32] := %eax
            *32* %eax := r[tmp1];

XCHG.EAXOW   reg16 
            *16* r[tmph] := r[reg16]
            *16* r[reg16] := %eax
            *16* %eax := r[tmph];

XCHG.EB.GB   modrm, reg8 
            *8* r[tmpb] := modrm{8}
            *8* modrm := r[reg8]
            *8* r[reg8] := r[tmpb];

XCHG.EV.GVOD   modrm, reg32 
            *32* r[tmp1] := modrm{16}
            *32* modrm := r[reg32]
            *32* r[reg32] := r[tmp1];

XCHG.EV.GVOW   modrm, reg16 
            *16* r[tmph] := modrm{32}
            *16* modrm := r[reg16]
            *16* r[reg16] := r[tmph];

# Start of Floating point operators
FABS    
            *1* %st@[79:79] := 0;

OP3 := { "+f", "-f" };
FARIT := { "FADD", "FSUB" };

FARIT[IDX].r32 modrm 
            *80* %st := %st OP3[IDX] fsize(32,80,modrm);

FARIT[IDX].r64 modrm 
            *80* %st := %st OP3[IDX] fsize(64,80,modrm);

FARIT[IDX].ST.STi i
            *80* %st := %st OP3[IDX] r[i];

FARIT[IDX].STi.ST i 
            *80* r[i] := r[i] OP3[IDX] %st;

FARITP := { "FADDP", "FSUBP" };

FARITP[IDX].r32 modrm 
            *80* %st := %st OP3[IDX] fsize(32,80,modrm)
            FPOP;

FARITP[IDX].r64 modrm 
            *80* %st := %st OP3[IDX] fsize(64,80,modrm)
            FPOP;

FARITP[IDX].ST.STi i 
            *80* %st := %st OP3[IDX] r[i]
            FPOP;

FARITP[IDX].STi.ST i 
            *80* r[i] := r[i] OP3[IDX] %st
            FPOP;

FIADD.i32   modrm 
            *80* %st := %st +f itof(32,80,modrm);

FIADD.i64   modrm 
            *80* %st := %st +f itof(64,80,modrm);

FCHS    
            *1* %st@[79:79] := ~%st@[79:79];

FCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FNCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FCOM.r32    modrm 
            *80* r[tmpD] := %st -f fsize(32,80,modrm)
            SETFFLAGS(%st, fsize(32,80,modrm));

FCOM.r64    modrm 
            *80* r[tmpD] := %st -f fsize(64,80,modrm)
            SETFFLAGS(%st, fsize(64,80,modrm));

FCOM.ST.STi i 
            *80* r[tmpD] := %st -f r[i]
            SETFFLAGS(%st, r[i]);

FCOMP.r32   modrm 
            # Note that the FPOP will actually change the register numbers!
            *80* r[tmpD1] := %st
            *80* r[tmpD2] := fsize(32, 80, modrm)
            *80* r[tmpD] := %st -f fsize(32,80,modrm)
            FPOP
            SETFFLAGS(r[tmpD1], r[tmpD2]);

FCOMP.r64   modrm 
            *80* r[tmpD1] := %st
            *80* r[tmpD2] := fsize(64, 80, modrm)
            *80* r[tmpD] := %st -f fsize(64,80,modrm)
            FPOP
            SETFFLAGS(r[tmpD1], r[tmpD2]);

FCOMP.ST.STi   i 
            *80* r[tmpD1] := %st
            *80* r[tmpD2] := r[i]
            *80* r[tmpD] := %st -f r[i]
            FPOP
            SETFFLAGS(r[tmpD1], r[tmpD2]);
FCOMPP    
            *80* r[tmpD1] := %st
            *80* r[tmpD2] := %st1
            *80* r[tmpD] := %st -f %st1
            FPOP
            FPOP
            SETFFLAGS(r[tmpD1], r[tmpD2]);

FCOS    
            *80* %st := cos(%st);

FPUSH_
            FPUSH;

FDIV.r32   modrm 
            *80* %st := %st /f fsize(32,80,modrm);

FDIV.r64   modrm 
            *80* %st := %st /f fsize(64,80,modrm);

FDIV.ST.STi   i 
            *80* %st := %st /f r[i];

# At this point, it should be noted that Intel have a really silly way of
# defining what is and isn't an "R" instruction. There is an "R" bit in the
# opcode (bit 2 of the second byte), which is NOT the same as the "R" in the
# instruction name (according to the Intel book, and according to debug
# and ida pro). Unix disassemblers like dis and objdump get it wrong, as
# the .spec file does.
# Looking at the bits in the instruction, the "R" (reverse) bit implies
# reversing the operands such that ST is now the second operand, and the
# "d" (direction) bit implies that ST(i) is the destination instead of ST.
# Intel's crazy idea is that when "d" is in force, the operands have to be
# swapped as well, so to get them the normal way around, you need an "R"
# instruction to reverse the reversal. Clear?
# Getting the R correct is difficult, so we tolerate the error and correct
# for it. Basically, it means reversing the operands for instructions with
# and R in the name (according to the spec, not Intel) AND with .STi.ST
# (effectively, this form already implies a "reversal"). Note that the NO
# argument forms (e.g. FDIVP) are effectively .STi.ST verions (with i=1).

FDIV.STi.ST   i 
            *80* r[i] := %st /f r[i];

FDIVP.STi.ST   i 
            *80* r[i] := %st /f r[i];

FIDIV.i32   modrm 
            *80* %st := %st /f itof(32,80,modrm);

FIDIV.i16   modrm 
            *80* %st := %st /f itof(16,80,modrm);

FDIVR.r32   modrm 
            *80* %st := fsize(32,80,modrm) /f %st;

FDIVR.r64   modrm 
            *80* %st := fsize(64,80,modrm) /f %st;

FDIVR.ST.STi   i 
            *80* %st := r[i] /f %st;

FDIVR.STi.ST   i 
            *80* r[i] := r[i] /f %st;

FDIVRP.STi.ST   i 
            *80* r[i] := r[i] /f %st
            FPOP;

FIDIVR.i32   modrm 
            *80* %st := itof(32,80,modrm) /f %st;

FIDIVR.i16   modrm 
            *80* %st := itof(16,80,modrm) /f %st;

FICOM.i16   modrm 
            *80* r[tmpD] := %st -f itof(16,80,modrm)
            SETFFLAGS(%st, itof(16,80,modrm));

FICOM.i32   modrm 
            *80* r[tmpD] := %st -f itof(32,80,modrm)
            SETFFLAGS(%st, itof(32,80,modrm));

FICOMP.i16   modrm 
            *80* r[tmpD] := %st -f itof(16,80,modrm)
            FPOP
            SETFFLAGS(%st, itof(16,80,modrm));

FICOMP.i32   modrm 
            *80* r[tmpD] := %st -f itof(32,80,modrm)
            FPOP
            SETFFLAGS(%st, itof(32,80,modrm));

FILD.lsI16   modrm 
            FPUSH
            *80* %st := itof(16,80,modrm);

FILD.lsI32   modrm 
            FPUSH
            *80* %st := itof(32,80,modrm);

FILD.lsI64   modrm 
            FPUSH
            *80* %st := itof(64,80,modrm);

FINCSTP    
            FPUSH;

FIST.lsI16   modrm 
            *16* modrm := ftoi(80,16,%st);

FIST.lsI32   modrm 
            *32* modrm := ftoi(80,32,%st);

FISTP.lsI16   modrm 
            *16* modrm := ftoi(80,16,%st)
            FPOP;

FISTP.lsI32   modrm 
            *32* modrm := ftoi(80,32,%st)
            FPOP;

FISTP64     modrm 
            *64* modrm := ftoi(80,64,%st)
            FPOP;

FLD.lsR32   modrm 
            FPUSH
            *80* %st := fsize(32,80,modrm);

FLD.lsR64   modrm 
            FPUSH
            *80* %st := fsize(64,80,modrm);

FLD80   modrm 
            FPUSH
            *80* %st := modrm;

# This is a bit tricky. The FPUSH logically comes between the read of STi and
# the write to ST0. In particular, FLD ST0 is supposed to duplicate the TOS.
# This problem only happens with this load instruction, so there is a work
# around in the decoder that gives us a value of i that is one more than in
# the instruction

FLD.STi   i 
            FPUSH
            *80* %st := r[i];

FLD1    
            FPUSH
            *80* %st := 1.0;

FLDL2T    
            FPUSH
            *80* %st := log2(10.0);

FLDL2E    
            FPUSH
            *80* %st := log2(2.7182818);

FLDPI    
            FPUSH
            *80* %st := 3.1415926;

FLDLG2    
            FPUSH
            *80* %st := log10(2.0);

FLDLN2    
            FPUSH
            *80* %st := loge(2.0);

FLDZ    
            FPUSH
            *80* %st := 0.0;

FLDCW   modrm 
            FPUSH
            *16* %fcw := modrm;

FMUL.r32   modrm 
            *80* %st := %st *f fsize(32,80,modrm);

FMUL.r64   modrm 
            *80* %st := %st *f fsize(64,80,modrm);

FMUL.ST.STi   i 
            *80* %st := %st *f r[i];

FMUL.STi.ST   i 
            *80* r[i] := %st *f r[i];

FMULP.STi.ST   i 
            *80* r[i] := %st *f r[i]
            FPOP;

FIMUL.r32   modrm 
            *80* %st := %st *f itof(32,80,modrm);

FIMUL.r64   modrm 
            *80* %st := %st *f itof(64,80,modrm);

FNOP    _ ;

FPATAN    
            *80* %st1 := arctan(%st1 /f %st);

FPTAN    
            *80* %st := tan(%st)
            FPUSH
            *80* %st := 1.0;

FRNDINT    
            *80* %st := fround(80,80,%st);

FSIN    
            *80* %st := sin(%st);

FSINCOS    
            *80* r[tmp] := %st
            *80* %st := sin(r[tmp])
            FPUSH
            *80* %st := cos(r[tmp]);

FSQRT    
            *80* %st := sqrt(%st);

FST.lsR32   modrm 
            *32* modrm := fsize(80,32,%st);

FST.lsR64   modrm 
            *64* modrm := fsize(80,64,%st);

FST.ST.STi   i 
            *80* r[i] := %st;

FSTP.lsR32   modrm 
            *32* modrm := fsize(80,32,%st)
            FPOP;

FSTP.lsR64   modrm 
            *64* modrm := fsize(80,64,%st)
            FPOP;

FSTP80   modrm 
            *80* modrm := %st
            FPOP;

FSTP.ST.STi   i 
            *80* r[i] := %st
            FPOP;

FSTCW   modrm 
            *16* modrm := %fcw;

FNSTCW   modrm 
            *16* modrm := %fcw;

FSTSW   modrm 
            *16* modrm := %fsw;

FSTSW.AX    
            *16* %ax := %fsw;

FNSTSW   modrm 
            *16* modrm := %fsw;

FNSTSW.AX    
            *16* %ax := %fsw;

FSUBR.r32   modrm 
            *80* %st := fsize(32,80,modrm) -f %st;

FSUBR.r64   modrm 
            *80* %st := fsize(64,80,modrm) -f %st;

FSUBR.ST.STi   i 
            *80* %st := r[i] -f %st;

# Please see large comment above FDIV
FSUBR.STi.ST   i 
            *80* r[i] := r[i] -f %st;

FSUBRP.STi.ST   i 
            *80* r[i] := r[i] -f %st
            FPOP;

FISUBR.r32   modrm 
            *80* %st := itof(32,80,modrm) -f %st;

FISUBR.r64   modrm 
            *80* %st := itof(64,80,modrm) -f %st;

FTST    
            SETFFLAGS(%st, 0.0);

FUCOM       i 
            *80* r[tmpD] := %st -f r[i]
            SETFFLAGS(%st, r[i]);

FUCOMP      i 
            *80* r[tmpD1] := %st
            *80* r[tmpD2] := r[i]
            *80* r[tmpD] := %st -f r[i]
            FPOP
            SETFFLAGS(r[tmpD1], r[tmpD2]);

FUCOMPP    
            *80* r[tmpD1] := %st
            *80* r[tmpD2] := %st1
            *80* r[tmpD] := %st -f %st1
            FPOP
            FPOP
            SETFFLAGS(r[tmpD1], r[tmpD2]);

FWAIT    _ ;

FXCH        i 
            *80* r[tmpD] := %st
            *80* %st := r[i]
            *80* r[i] := r[tmpD];

FYL2X    
            *80* %st1 := %st1 *f log2(%st);

FYL2XP1    
            *80* %st1 := %st1 *f log2(%st +f 1.0);

#####################################################################
# These are the semantics for certain prologues and epilogues that we
# need to see for CSR analysis. We need the semantics for a logue to
# be specified when it uses and/or defines locations that relevant for
# CSR analysis involving the logue. For example, the caller prologue
# "clear_stack" on x86 directly manipulates the stack pointer which is
# something the abstract frame pointer needs to see.
#####################################################################
CLEAR_STACK   n 
            *32* %esp := %esp + n;
