=======
 소 개
=======

ECOMSTATION 및 OS/2 용 FAT32 IFS 드라이버 
------------------------------------------- 

이 프로젝트는, OS/2 를 더 이상 사용하지 않아서, 2002 년 1 월에 소스를 
Netlabs(netlabs.org) 에 제공했던 Henk Kelder 씨의 FAT32 소스 코드에 기반하고 
있습니다. 결과적으로, 지금은 전체 소스 코드를 언제라도 사용할 수 있는 Netlabs
프로젝트가 되었습니다.

FAT32 홈페이지에서 간단한 zip 파일과 사용자가 큰 노력없이 FAT32 를 설치할 수 
있도록 해주는 WarpIn 패키지 모두를 얻을 수 있습니다.

만든이들:
Henk Kelder: 처음 만든이
Brian Smith: 도우미
고명훈: FAT32 IFS 드라이버 중심 개발자
Alfredo Fernandez Diaz: WarpIN 스크립트를 만든이
David Graser: FAT32.INF 를 만든이

패치는 언제나 환영입니다. 도움을 주고 싶으신 분들은 언제라도 Netlabs 에 
연락하십시오.

============
면 책 조 항
============

만든이, 도우미, 그리고 내 자신은 당신이 겪을 수 있는 모든 피해 혹은 손실에 
대해 어떤 방식으로도 책임지지 않는다는 조건 하에서, 당신이 이 패키지 안에 
있는 모든 소프트웨어들을 사용하는 것을 허락한다.

당신은 FAT32.IFS 가 당신의 하드 디스크에 저장되어 있는 자료를 손상시킬 수 
있다는 사실을 알아야 한다.

만일 당신이 이 조건들에 동의할 수 없다면, 당신은 FAT32.IFS 를 사용하지 말아야
한다!

Adrian Gschwend @ netlabs.org 


=======================================
ECS 와 OS/2 에서 FAT32 파티션 인식하기
======================================= 

EComStation 과 OS/2 는 알아서 FAT32 파티션을 인식하지 않습니다. 이것은 만일 
eCS 와 OS/2 가 FAT32 파티션을 인식하게 하지 않는다면, FAT32 IFS (installable 
file system) 을 설치하는 것이 쓸모 없다는 것을 뜻합니다. FAT32 파티션을 
인식하게 하는 방법이 몇 가지 있습니다.

논리 볼륨 관리자 (LVM)
non-LVM 시스템을 위한 파티션 지원 패키지

주의: 파티션을 FAT32 로 포맷하기 위해서는 Win95 OSR2 또는 그 이후의 Windows 
가 필요합니다.

논리 볼륨 관리자 (LVM):
----------------------------- 

EComstation, Warp Server for e-business 와 Convenience Packages 는 FAT32 
파티션을 인식하기 위한 논리 볼륨 관리자(LVM)를 포함하고 있습니다.

디스크 관리 도구인 논리 볼륨 관리자 (LVM)는 FDISK 를 대체합니다. LVM 은 
볼륨과 파티션을 만들고, 드라이브 문자를 할당하고, 물리적 하드 드라이브들을 
연결하고(spanning), 여러개의 하드 드라이브를 포함하는 볼륨을 정의하는데 
쓰입니다.

LVM 은 반드시 당신의 FAT32 파티션을 "bootable volume" 또는 "compatibility 
volume" 으로 만드는데 쓰여야 합니다. 만일 FAT32 파티션이 Windows 운영 체제를 
포함하고 있고, 당신이 Windows 운영체제를 부팅시키고 싶다면, 당신은 반드시 LVM 
을 사용하여 "bootable volume" 을 만들어야 합니다. 아울러, 당신의 Win9X 
파티션을 부팅시키기 위해 IBM 부트 관리자(Boot Manger)가 필요합니다. 만일 
FAT32 파티션이 당신이 관리하고자 하는 자료를 담고 있다면, LVM 을 사용하여 
"compatibility volume" 을 만드십시오. ODIN 을 사용하여 부팅가능한(bootable) 
또는 호환(compatibility) 볼륨에서 Windows 프로그램들을 실행시키는 것또한 
가능합니다. 볼륨을 만들고 나서, 드라이브 문자를 할당하십시오.

경고: LVM 시스템에서 DANIDASD.DMD 와 PARTFILT.FLT 또는 수정된 OS2DASD.DMD 는 
사용하지 마십시오!


NON-LVM 시스템을 위한 파티션 지원 패키지:
------------------------------------------

이 IFS 가 FAT32 매체를 접근하기 위해, 우선 eCS/OS2 는 FAT32 매체에 드라이브 
문자를 할당할 수 있어야만 합니다. 당신은 이미 LVM 시스템에서 이것을 할 수 
있습니다. non-LVM 시스템에서 당신은 "파티션 지원" 패키지가 필요합니다. 현재, 
세 가지의 사용가능한 패키지가 있습니다.

Daniela Engert 씨의 개선된 DANIDASD.DMD(OS/2 3 과 4 에 있는 OS2DASD.DMD 의 
대체 드라이버). 이것이 non-LVM 시스템에서 선호됩니다.

Deon van der Westhuysen 씨의 PARTFILT.FLT(OS/2 가 정상적으로 지원하지 않는 
파티션들을 속이기 위한 BASEDEV 필터). 이것은 DANIDASD.DMD 가 훨씬 더 많이 
쓰이기때문에, 지금은 쓰이지 않습니다.

Henk Kelder 씨의 OS2DASD.DMD 수정판(OS/2 3 과 4 에 있는 OS2DASD.DMD 의 또다른 
대체 드라이버). 이것 역시 거의 사용되지 않습니다.

=======================================
Daniela Engert 씨의 개선된 DASD 관리자
=======================================

개요:  
------

WinXY 시스템과 쉽게 공존하기 위한 OS/2 DASD 관리자 OS2DASD.DMD 의 개선판. 
제한적으로나마 LVM 의 몇 몇 형식을 지원합니다.

설명: 
----- 

이 배포판에 있는 Daniela 씨의 DASD 관리자 드라이버는 IBM DDK 사이트에서 IBM 
이 제공하는 OS2DASD.DMD 소스에 기반하고 있습니다. 이 배포판은 현재 픽스팩에서 
찾을 수 있는 최신의 기능들을 가지고 있습니다.

드라이버 얻기: 
---------------

Daniela 씨의 드라이버는 Hoobes 에서 찾을 수 있습니다.

http://hobbes.nmsu.edu/pub/os2/system/drivers/storage/danidasd144.zip 

Hobbes 의 zip 파일과 같은 위치에서, 사용가능한 WarpIN(wpi) 판이 있을 수 
있습니다.

주의:
--------
  
DaniDASD.DMD 는 non-LVM 시스템만을 위해 만들어졌습니다.
DaniDASD.DMD 는 OS2LVM.DMD 와 작동하지 않습니다.
DaniDASD.DMD 는 FDISK 또는 OS/2 부트관리자의 한계를 극복할 수 없습니다.

DANIELA 씨가 개선한 것들
-------------------------

- 보통의 확장 파티션들(유형 05) 와 정확히 같은, ExtendedX 파티션(유형 0F) 와 
리눅스 확장 파티션(유형 8F, Microsoft 가 개발한 유형 0F 보다 훨씬 우둔하고 
쓸모없는 파티션) 을 지원합니다. 요즘에는 디스크 크기가 8 기가 이상이게 때문에 
ExtendedX 파티션들이 일반적입니다. 

- 정확히 IFS 파티션(유형 07, HPFS 와 NTFS 가 사용)으로서 FAT32 파티션(유형 0B 
와 0C) 를 지원합니다. 이렇게 해서 FAT32 파티션은 "올바른" 순서로 보여지고,  
"예상된 대로" 드라이브 문자들을 할당 받습니다.

- FAT32 파티션을 접근하기 위해 PARTFILT.FLT 는 더 이상 필요하지 않습니다. 
하지만 Henk Kelder 씨의 FAT32.IFS 는 여전히 필요합니다.

- 정확히 대형 FAT16(유형 06)으로서 FAT16X 파티션(유형 0E)을 지원합니다.

- 사용자가 지정하는 대로 최대 8 개의 추가 파티션 유형을 지원합니다. 이것은 
숨겨진 파티션들(유형 1x) 또는 리눅스의 ext2(유형 83) 같은 외부 파일 
시스템들을 DASD 관리자가 볼 수 있도록 하는데 쓰입니다. 옵션을 통해서 추가 
파티션 유형을 DaniDASD.DMD 에 알려주어야만 합니다.

/AT:<type>{,<type>{,<type>...}} (<type> 은 두 개의 16 진수 숫자이어야 합니다!)

받아들일 수 있는 파티션 유형을 정리하기 위해, 이 표를 보십시오.

DASD 관리자
지원되는 파티션 유형들

OS2DASD (LVM 이전) 
(확장)05 (일반)01, 04, 06, 07 

OS2DASD (LVM) 
(확장)05, 0F (일반)01, 04, 06, 07, 35, [+ other] 

DaniDASD 
(확장)05, 0F, 8F (일반)01, 04, 06, 07, 0B, 0C, 0E, [+ other] 

만일 추가 파티션 유형이 "숨겨진" 파티션(1x) 라면, 해당 파티션은 
"숨겨지지-않은" (0x) 파티션으로 전환되고, 위의 수용 규칙이 적용됩니다.


개선된 옵션들: 
---------------
 
- "can't operate hard disk" 메세지를 유발하는 부트 문제를 해결할 수 있습니다. 
이것은, 만일 OS/2 가 *올바른* 부트 드라이브 문자를 OS/2 에게 알려주기 위해 
요구되는 OS/2 부트 관리자의 적절한 도움없이 OS/2 가 부팅된다면 일반적으로 
일어납니다. 만일 이런 능력이 있는 부트 관리자가 없거나(예를 들면, 이동식 
매체으로부터 부팅할 때) 또는 부트 관리자가 부트 드라이브 문자를 알 수 없다면, 
당신은 DaniDASD.DMD 에 옵션을 통하여 올바른 드라이브 문자를 알려 줄 수 
있습니다.

/BD:<드라이브 문자> 

첫번째 부트 단계로부터 할당받은 드라이브 문자를 재지정합니다.

예: 두 개의 SCSI 어댑터와 두 개의 다른 EIDE 컨트롤러를 가지고 있는, SCSI 와 
EIDE 가 혼재된 환경(현재 Daniela 씨의 설정)에서, ATAPI ZIP250 드라이브는 
드라이브 문자 M: 을 할당 받습니다.
이 장치로부터 부트하기위해, Daniela 씨는 ZIP 부트 플로피의 CONFIG.SYS 에 
다음과 같은 줄을 넣어두었습니다.

BASEDEV=DaniDASD.DMD /BD:M 

주의:
WPS 는 이러한 설정을 좋아하는 것 같지 않습니다. 그래서 이것은 콘솔 세션으로만 
엄격하게 제한됩니다.

- 물리적 볼륨(파티션)과 독립된 논리적 볼륨 지도를 만들 수 있습니다.

주의:
이 옵션이 효과를 가지면, DaniDASD 는 일차 파티션 테이블에서 첫번째 받아들일 
수 있는 파티션만을 받아들이는 오래된 OS2DASD 규칙을 더 이상 따르지 않습니다. 
대신에, 모든 수용가능한 일차 파티션들을 받아들이는 LVM 규칙이 적용됩니다.

위의 규칙을 따르는 받아들일 수 있는 파티션들을 위한 *고정된* 디스크들을 
조사한 후에, 논리적 볼륨 맵핑이 이 파티션들로부터 만들어집니다. 이것은 맵핑 
테이블을 통하여 이루어집니다. 이 테이블은 드라이브 문자 C: 로부터 
오름차순으로 연속적으로 드라이브 문자를 받게 될 파티션들을 나열합니다. 특정 
물리적 파티션은 두개의 문자 코드 <물리적 디스크 번호><물리적 파티션 번호> 로 
지시됩니다. 코드 "Aa" 는 첫번째 디스크에 있는 첫번째 파티션을 가리키고, "Ab" 
는 같은 디스크에 있는 두번째 파티션을, "Bc" 는 두번째 디스크에 있는 세번째 
파티션을 가리킵니다. 디스크와 파티션의 번호는 DaniDASD 의 정상적인 조사 
순서로 주어집니다.

맵핑 테이블에 있는 각각의 요소들은 유일해야 하며, 존재하는 파티션이 없는 
요소들은 무시됩니다.

예: 

BASEDEV=DaniDASD.DMD /MT:Aa,Ad,Ba,Bb 

지시된 물리적 파티션으로부터 논리적 볼륨 C:...F: 를 만듭니다.

주의:
이것은 이동식 매체에는 적용되지 *않습니다*! 이동식 매체의 드라이브 문자들은 
*언제나* 하드 디스크 이후가 됩니다.

주의:
보이는 FAT 와 HPFS 일차 파티션을 재맵핑하는 것은 실패할 수 있습니다!
OS2PCARD.DMD 를 대체할 수 있다. 만일 당신이 PCM2ATA.ADD 를 사용하고 있다면, 
/!DM 옵션을 제거하든가 또는 /PC 옵션을 DaniDASD.DMD 명령행에 추가하십시오. 
PCCard ATA 장치들을 처리하는 DaniS506.ADD 의 경우, 어떤 옵션도 필요하지 
않습니다.

명령행 옵션들:

이 드라이버는 OS2DASD.DMD 가 지원하는 모든 스위치와 옵션을 지원합니다. 이들의 
설명에 대해서는 OS/2 온라인 도움말을 보십시오('이름별 OS/2 명령'/ 
'BASEDEV...' / 'OS2DASD...' 을 고르십시오). 그리고 새로운 정보는 픽스팩 
문서에 있습니다.

완벽하게 하기 위해, 다음이 OS2DASD 옵션입니다.

옵션
설명

/of 
광학적 장치를 디스크 장치처럼 다룹니다(곧, MO 드라이브를 추가적 이동식 
디스크로서 다룹니다)

/lf 
이동식 디스크를 대용량 플로피처럼 다룹니다( 곧, 파티션 되지 않는 디스크로 )

/mp 
이동식 매체 장치를 위한 파티션 개수를 예약합니다( 자세한 것은 OS2DASD 문서를 
보십시오)

DDINSTAL 설치:
---------------  

세 개의 외부 파티션 지원 패키지 중에, 이것이 선호되는 설치 방법입니다.

이미 설치되어 있는 OS2DASD.DMD 드라이버를 업그레이드하기 위해서는, 단지 
DaniDASD.DMD 를 부트드라이브:\OS2\BOOT 에 복사하고, CONFIG.SYS 에서 
OS2DASD.DMD 를 DaniDASD.DMD 로 이름을 바꾸기만 하면 됩니다.

BASEDEV=DaniDASD.DMD 

만일 당신이 추적하는 것을 선호한다면, 당신은 DDINSTAL("OS/2 시스템"/"시스템 
설정"/"설치/제거"/"디바이스 드라이버 설치") 를 사용하여 복사와 수정을 할 수 
있습니다. DDINSTAL 의 한계때문에, 해당 줄을 지우거나, 그 앞에 'rem' 문을 
넣어서, 이미 설치된 OS2DASD.DMD 드라이버가 작동하지 않도록 CONFIG.SYS 를 
수동으로 고쳐야 합니다.

파일들:

파일
설명

DaniDASD.DMD 
드라이버 자체

DaniDASD.DDP 
DDINSTAL 용 디바이스 설치정보

DaniDASD.DOC 
DaniDASD 에 대한 정보를 담고 있는 문서

cmprssd\DaniDASD.DMD 
위와 같지만, LXlite 로 압축되었습니다. 이것은 모든 시스템에서 작동한다고 
보장되지 *않습니다*.

DANIELA ENGERT 씨의 면책조항:
------------------------------

당신은 당신 자신의 책임하에 이 프로그램을 쓰고 있다! 나는 이 프로그램을 
사용해서, 사용할 수 없어서, 잘못 사용해서, 직간접으로 이 프로그램을 소유 또는 
비소유함으로써 일어날 수 있는 손상, 문제, 보관, 부부싸움 등등에 대해 어떤 
책임도 지지 않는다. 나는 또한 버그없는 작동, 특수 목적에 대한 적합성 또는 
동물과 프로그래머 및 꼬마 어린이들의 적절한 행동에 대한 어떤 보장도 하지 
않는다.

이 소프트웨어는 ``있는 그대로//, 어떤 표현 또는 암시적인 보장없이, 제한이 
없다면 암시적인 상업성의 보장과 특수 목적에 대한 적합성을 포함하여 제공된다. 
프로그램의 질과 성능에 대한 모든 부담은 당신에게 있다. 만일 프로그램에 결점이 
있다면, 필요한 모든 서비스와 수리 및 정정에 대한 비용을 당신이 부담한다.

또는, 몇 마디로:
좋으면, 내 책임.
나쁘면, 모든 것이 당신의 잘못이다. ;)

내용이 수정되지 않은 전체 파일더미로 그리고 배포되는 매체의 가격이외의 이익이 
만들어지지 않는다면, 이 프로그램을 무료로 재배포하는 것이 허락된다. 마지막 
규정에 관한 예외 : 잡지 CD-ROM 뿐만 아니라 프리웨어/쉐어웨어 모음 CD-ROM 에 
포함될 수 있다.

이 문서에서 언급된 모든 상표들은 그들 소유자의 재산이다.


Daniela Engert <dani@ngrt 


저작권:
----------- 

     DaniDASD - Copyright (c) 2001 Daniela Engert. All rights reserved. 

프로그램의 상태(STATUS)
------------------------ 

     DaniDASD 은 프리웨어입니다.


만든이: 
-------- 

     Daniela Engert 

     인터넷: "Daniela Engert" <dani@ngrt.de>     (선호됨) 
     Fidonet: 2:2490/2575 (여기에서는 디버그 지원이 없음) 


벌레들: 
------- 

다행히 없지만, 누군가는 압니다...
지금까지, 하나의 문제도 보고되지 않았습니다. :

많은 사람들이 파일 날짜에 따른 드라이버 개정판에 대해 말합니다. 이런 이유 
때문에 그렇게 하지 않습니다.
 
- Daniela 씨는 파일 날짜들을 기억하지 않습니다. 
- Daniela 씨는 거의 매일 여러 개의 드라이버들을 만듭니다.
- 파일 날짜는 쉽게 바뀔 수 있습니다.
- 이 세상에는 다른 종류의 많은 달력들이 있습니다.

유일하게 올바른 참고 사항은 드라이버의 판 번호입니다. 판 번호는 다음과 같은 
어떤 것을 출력할 "BLDLEVEL DaniDASD.DMD" 를 실행할 때 나타납니다.

Signature:     @#DANI:1.0#@##1## 17.2.2001 19:46:21
Vendor:        DANI
Revision:      1.00
Date/Time:     17.2.2001 19:46:21
Build Machine: Nachtigall
File Version:  1.0.0 <-------------------+
Description:   OS/2 DASD Device Manager  |
                                         |
이것이 완전한 판 번호입니다.     --------+

Daniela 씨는 이 드라이버 외부('Disk DD' 와 다른 또는 존재하지 않는 모듈 이름) 
에서 발생하는 트랩을 확인할 수 있는 방법이 없습니다. 만일 이 드라이버 
내부에서 트랩이 발생한다면, Daniela 씨는 다음 정보를 필요로 합니다: CS:EIP, 
EAX-EDI, DS 와 ES. 그녀의 집에 있는 시험용 시스템(VIA 와 ALi) 그리고 직장에 
있는 다른 컴퓨터들 (다른 INTEL 칩들) 은 이 드라이버와 완벽하게 작동합니다. 
그래서 그녀는 실질적으로 오류를 재현할 수가 없습니다.

벌레 보고 :
-------------  

제안과 벌레-보고는 언제나 환영입니다. 음... 벌레-보고들은 아마도 *그렇게* 
환영하지는 않습니다 ...

=============
PARTFILT.FLT: 
=============

PARTFILT 는 Deon van der Westhuysen 의 훌륭한 작업에 기초하고 있습니다. Henk 
Kelder 는 그것을 약간 수정했을 뿐입니다. 소스 코드는 GPL 조건 아래 
사용가능하고, 지금은 Netlabs 에서 내려받을 수 있습니다.

또한, 일단 PARTFILT 가 설치된다면, FDISK, 파티션 매직과 다른 파티션 도구들은 
더 이상 신뢰될 수 없습니다. 일단 PARTFILT 가 설치되면 이런 도구들을 사용하지 
마십시오.

CONFIG.SYS 에서 가장 좋은 위치는 당신의 구성에 따라 다른 것 같습니다. 어떤 
이는 PARTFILT 가 첫번째 BASEDEV 일 때만 FAT32.IFS 가 작동할 것이라고 말하는 
반면, 다른 이는 PARTFILT 가 마지막 BASEDEV 일 때만 작동한다고 주장합니다.

SCSI 전원 절약 BASEDEV를 사용할 때, PARTFILT 가 마지막 BASEDEV 일 때만 
작동하는 것 같다는 특정 문제가 보고되었습니다.

드라이버 얻기: 
--------------

PARTFILT.FLT 드라이버는 더 이상 FAT32 IFS 드라이버와 함께 배포되지 않을
것입니다. 필요하다면, Henk 씨의 최신 바이너리 배포판에서 추출될 수 있고, 
전적으로 사용자의 책임하에 수동으로 설치될 수 있습니다. Henk Kelder 씨의 최신 
배포판은 Hobbes 에서 찾을 수 있습니다.

http://hobbes.nmsu.edu/pub/os2/system/drivers/filesys/os2fat32.zip 


설치:
------------- 

주의: Daniela 씨의 DaniDASD.DMD 가 더 나은 선택이기 때문에, 이 드라이버는 
쓰이지 않습니다. 하지만, 이 드라이버를 더 좋아한다면, 다음처럼 하여 설치할 수 
있습니다. 

PARTFILT.FLT 드라이버를 \OS2\BOOT 디렉토리에 복사합니다.

CONFIG.SYS 에 다음 줄을 추가합니다.

BASEDEV=PARTFILT.FLT /P 0B [/W] 

(쓰기를 원하지 않는다면, /W 를 추가해서는 안됩니다) (가장 좋은 위치는 당신의 
구성에 따라 다른 것 같습니다. 어떤 이는 PARTFILT 가 첫번째 BASEDEV 일 때만, 
FAT32.IFS 가 작동한다고하고, 다른 이는 가장 마지막 BASEDEV 일 때만 작동한다고 
주장합니다) 만일 당신이 기존의 FAT16 파티션을 FAT32 파티션으로 변환하였거나 
또는 드라이브 순서를 바꾸고 싶다면 PARTFILT.FLT 에 다른 옵션을 적을 필요가 
있습니다! 이와같은 수동 설치로, FAT32 파티션은 기존의 모든 드라이브 다음에 
추가될 것입니다.

재부팅


지원되는 파일 시스템:
-----------------------

현재, 필터는 오직 두 개의 IFS 에만 쓰일 수 있습니다: FAT32.IFS 와 Linux IFS

또한, PARTFILT.FLT 는 보이지 않는 파티션을 보이도록 한다든가 또는 여러 개의 
일차 파티션을 사용한 것같은 다른 목적을 위해 쓰일 수 있습니다.


PARTFILT 옵션:
-----------------

옵션
설명

/Q 
조용히 로드합니다

/W 
인식시킨 파티션에 쓰기를 허가합니다. 이 옵션이 없다면, 인식시킨 파티션은 읽기 
전용이 됩니다.

/A  
이 옵션은 두 가지 일을 합니다.
OS/2 가 모든 파티션에 접근하지 못하도록 합니다, 하지만:
알려진 모든 파티션을 인식시킵니다. 알려진 파티션들은 보통의 FAT 파티션들, IFS 
(=주로 HPFS) 파티션들과 /P 옵션으로 지정된 파티션들입니다. 알려진 유형의 모든 
일차 파티션들은 인식되고, OS/2 에서 접근할 수 있습니다. 이 옵션은 /M 옵션과 
함께 쓰여야 합니다. 이 옵션이 쓰일 때, /W 옵션은 자동적으로 설정됩니다. 
왜냐하면 그렇지 않으면 OS/2 가 부팅되지 않기 때문입니다.

/M <마운트할 목록> 
파티션이 마운트될 순서를 지정합니다. /A 옵션과 함께 쓰여야만 합니다.

경고: /A 와 /M 옵션을 잘못 사용하면, 시스템을 부팅시키지 못할 수도 있습니다.

=> /A 와 /M 옵션을 사용하는 것을 권하지 않습니다! <=

만일 이 옵션에 대해 더 많은 정보가 필요하다면, 직접 깨달으십시오.

/P <인식시킬 파티션 유형>
이것은 어떤 파티션 유형이 인식될지를 PARTFILT 에 알리기 위해 쓰이는 
옵션입니다. 당신은 이미 OS/2 가 지원하는 파티션 유형을 사용해서는 안됩니다. 
왜냐하면 그렇게 할 경우, 하나의 파티션이 두 번 마운트되기 때문입니다. 목록은 
쉼표(,)로 구분되는 파티션 유형 번호(16진수)로 이루어져야 합니다.

파티션 유형 번호:
-----------------------------

파티션 유형 번호는 다음과 같습니다.:
 
     01   FAT12       (OS/2 에서 지원됨) 
     02   XENIX_1 
     03   XENIX_2 
     04   FAT16       (OS/2 에서 지원됨) 
     05   EXTENDED 
     06   HUGE        (OS/2 에서 지원됨) 
     07   IFS         (OS/2 에서 지원됨) 
     0A   BOOTMANAGER 
     0B   FAT32 
     0C   FAT32_XINT13 or FAT32X 
     0E   XINT13 
     0F   XINT13_EXTENDED 
     41   PREP 
     63   UNIX 
     83   LINUX 

     10   숨겨진 파티션 ( 파티션 유형과 비트합(OR)됨 )

PARTFILT.FLT 로 FAT32 파티션을 인식하기 위해서는 /P 옵션은 /P 0B 가 되어야 
합니다.
PARTFILT.FLT 로 FAT32X 파티션을 인식하기 위해서는 /P 옵션은 0C 가 되어야 
합니다.
PARTFILT.FLT 로 리눅스 파티션을 인식하기 위해서는 /P 옵션은 /P 83 이 되어야 
합니다.
또는 유형을 섞어서 쓸 수 있습니다. 예) /P 0B,0C


OS/2 가 파티션을 검색(SCAN)하는 방법:
-------------------------------------

OS/2 가 부팅되는 동안, 파티션들은 두 번에 걸쳐 검색됩니다. 각각은 파티션을 
찾기 위해 같은 알고리즘을 사용합니다. 만일 OS/2 가 발견된 파티션 유형을 
지원한다면, 드라이브 문자들을 그 파티션들에 할당이 됩니다.

첫번째 검색은 초기 부팅 동안 이루어집니다.(PARTFILT 는 이 검색에 영향을 
미치지 않습니다!) OS/2 부트 드라이브를 찾고, 드라이브 문자를 그 파티션에 
할당하는 것이 이 검색의 주요 목적인 것 같습니다. OS/2 가 부팅되기 위해서, 이 
드라이브 문자는 두번째 검색 동안 바뀌지 말아야 합니다.

두번째 검색은 파일 시스템을 초기화하는 동안에 이루어집니다. OS2DASD.DMD 을 
호출하여, 파티션은 검색되고 드라이브 문자들이 할당됩니다. 오직 이 두번째 
검색만이 PARTFILT 의 영향을 받습니다.

그래서 당신이 무엇을 하든지, 당신은 두번의 검색 모두에서 OS/2 부트 드라이브가 
같은 드라이브 문자를 할당받도록 해야 합니다.

만일 당신의 FAT32 파티션이 일차 파티션이 아니고, FAT32 파티션이 할당받는 
드라이브 문자에 대해 신경을 쓰지 않는다면, 더 이상 읽지 않아도 됩니다. 단순히 
/A 또는 /M 옵션을 사용하지 마십시오. 그렇게 하면 FAT32 파티션은 OS/2 가 
정상적으로 인식하는 모든 파티션보다 나중의 드라이브 문자를 얻을 것입니다.

하지만 만일 당신의 FAT32 파티션이 일차 파티션이라면, 또는 당신이 FAT32 
파티션에 OS/2 부트 드라이브보다 앞서는 드라이버 문자를 할당하고자 한다면, 
당신은 몇 가지 추가적인 작업을 해야 할 필요가 있습니다.

OS/2 의 정상적인 할당 순서 :
첫번째 하드의 (현재 활성화된) 일차 파티션
두번째 하드의 (현재 활성화된) 일차 파티션
계속...
첫번째 하드의 모든 확장 파티션들
두번째 하드의 모든 확장 파티션들
계속...
이동식 드라이브들

PARTFILT 에 /M 파라미터를 사용할 필요가 있다면, 인자로 사용되는 순서 번호와 
OS/2 가 사용하는 정상적인 순서와 다르다는 것을 알아야 합니다. 여기 F32PARTS 
가 있습니다. F32PARTS 는 PARTFILT 가 사용하는 순서 번호를 보여줍니다. 아래를 
보시시오.

이제 당신이 다음과 같은 상황이라고 가정해 봅시다.

C: FAT16 (일차) 
D: HPFS  (확장)

그리고 당신은 FAT16 파티션을 FAT32 파티션으로 변환(파티션 매직을 
이용하여)하려고 생각하고 있습니다.
다음과 같은 일이 변환 후에 일어날 것입니다.

첫번째 검색 동안에 FAT32 파티션은 인식되지 않고, OS/2 부트 드라이브는 C: 를 
할당받을 것입니다. 두번째 검색 동안에 FAT32 는 인식됩니다. 왜냐하면 PARTFILT 
가 로드되었기 때문입니다. 그래서 C: 를 할당 받습니다. 당신의 HPFS 파티션은 D: 
를 할당받게 되고, OS/2 는 부팅되지 않을 것입니다. 왜냐하면 OS/2 는 이미 C: 를 
부트 드라이브로 결정했고, C: 에서 해당 내용을 찾을 수 없기 때문입니다.

두 가지 해결책이 있습니다:
PARTFILT 를 설치하지 않고, HPFS 파티션에 OS/2 를 다시 설치하십시오. OS/2 는 
C: (HPFS) 에 모든 것을 설치할 것입니다. 나중에 당신은 /A 와 /M 옵션 없이 
PARTFILT 와 FAT32.IFS 를 추가할 수 있고, FAT32 파티션은 D: 가 될 것입니다.

FAT32 와 HPFS 파티션 사이에 위장용 파티션(HPFS 가 선호됨)을 추가하십시오. 
첫번째 검색 동안에, 이 파티션은 C: 가 될 것이고, 당신의 부트 파티션을 D: 가 
될 것입니다.
PARTFILT 를 /A 와 /M 옵션을 주어 로드하십시오. 예에서 마운트 목록은 /M 0,2 가 
되어야 합니다.

설명:
위장 파티션이 설치되어 있다면, 다음과 같은 파티션들은 존재합니다:
0 - FAT32
1 - 위장용 HPFS
2 - HPFS(부트)

마운트 목록에 1 번을 명시하지 않음으로써, PARTFILT 는 이 파티션을 
사용가능하게 하지 않을 것이고, OS/2 는 그 파티션에 드라이브를 할당하지 않을 
것입니다. HPFS 파티션을 사용함으로써, Windows 95 는 위장용 파티션을 인식하지 
않을 것이고, 그 파티션에 드라이브 문자를 할당하지 않을 것입니다.

숨겨진 파티션들에 대하여:
-------------------------

PARTFILT 는 숨겨진 파티션을 OS/2 에 보이도록 하는데 쓰일 수 있습니다. 다음 
원리가 사용됩니다.

/A 가 사용되지 않는다면, /P 뒤에 지정된 유형들만 보입니다.( /A 스위치는 모든 
파티션들을 인식할 것인지, 아닌지를 결정합니다. )

PARTFILT 는 항상 인식시키는 파티션을 보이도록 합니다.

PARTFILT 가 인식시키는 파티션 유형에 있어, 다음 규칙이 적용됩니다 :

보통의 파티션 유형들( 유형 1, 4, 6, 7 뿐만 아니라 11, 14, 16, 17 )은 실제 
-보이는- 파티션 유형으로 OS/2 에 보고 됩니다.

/P 뒤에 명시된 다른 파티션 유형들은 숨겨지지-않은 IFS 파티션으로 보고됩니다.

/P 뒤에 명시되지 않은 다른 파티션 유형들은 실제 -숨겨지지 않은- 유형으로 
보고됩니다. 이것은 /A 인자를 쓸 때만 일어난다는 것을 주의하십시오.

/A 를 지정한다면, 또한 마운트하기를 원하는 파티션들을 /M 인자를 사용하여 
PARTFILT 에 알려주어야 한다는 것을 명심하십시오.


F32PARTS.EXE (이전의 DISKINFO.EXE): 
-----------------------------------

옵션 없이 실행할 때, F32PARTS 는 모든 파티션을 검색하고 보여줄 것입니다. 다음 
옵션들을 쓸 수 있습니다:

옵션
설명

/V 
자세한 설명 모드. FAT32 파티션들에 대한 더 많은 정보를 보여줍니다.

/W 
FAT32 파티션들의 부트 섹터를 보여줍니다. 오직 /V 가 사용될 때만.

/P 
파티션 순서 번호를 얻는 파티션 유형들의 목록을 지정합니다.

 더 많은 정보를 위해서는 PARTFILT 를 보십시오.

PARTFILT 출력의 두 가지 예:
---------------------------------

옵션이 없을 때 PARTFILT 출력 예:

There are 2 disks 
=== Scanning physical disk 1.=== 
0:P   06 HUGE           Strt:H:     1 C:   0 S:   1 End:H:   127 C: 258 S: 63 
-:PA  0A BOOTMANAGER    Strt:H:     0 C: 524 S:   1 End:H:   127 C: 524 S: 63 
1:LB  06 HUGE           Strt:H:     1 C: 259 S:   1 End:H:   127 C: 387 S: 63 
2:LB  07 IFS            Strt:H:     1 C: 388 S:   1 End:H:   127 C: 523 S: 63 
=== Scanning physical disk 2.=== 
-:L   0B FAT32          Strt:H:     1 C:   1 S:   1 End:H:   127 C: 381 S: 63 
-:L   0B FAT32          Strt:H:     1 C: 382 S:   1 End:H:   127 C: 524 S: 63 

쓩씹쓩쓩
쓩씹쓩찧Partition type (the number the specify after /P to get this
쓩씹쓩                  partition type handled by PARTFILT)
쓩씹처카H = Hidden partition
쓩씽컁카A = Active / B = Bootable via bootmanager
쓩처컁카P = Primary / L = Logical (extended)
처컁컁카Seq # to be used in the OPTIONAL /M argument for PARTFILT


2 FAT32 partitions found! 
WARNING: /P not specified. 
         Only 'normal' partitions are assigned a partition sequence number! 

인자로 /P 0B 를 주었을 때 PARTFILT 출력 예:

Also including partition types 0B. 
There are 2 disks 
=== Scanning physical disk 1.=== 
0:P   06 HUGE           Strt:H:     1 C:   0 S:   1 End:H:   127 C: 258 S: 63 
-:PA  0A BOOTMANAGER    Strt:H:     0 C: 524 S:   1 End:H:   127 C: 524 S: 63 
1:LB  06 HUGE           Strt:H:     1 C: 259 S:   1 End:H:   127 C: 387 S: 63 
2:LB  07 IFS            Strt:H:     1 C: 388 S:   1 End:H:   127 C: 523 S: 63 
=== Scanning physical disk 2.=== 
3:L   0B FAT32          Strt:H:     1 C:   1 S:   1 End:H:   127 C: 381 S: 63 
4:L   0B FAT32          Strt:H:     1 C: 382 S:   1 End:H:   127 C: 524 S: 63 

쓩씹쓩쓩
쓩씹쓩찧Partition type (the number the specify after /P to get this
쓩씹쓩                  partition type handled by PARTFILT)
쓩씹처카H = Hidden partition
쓩씽컁카A = Active / B = Bootable via bootmanager
쓩처컁카P = Primary / L = Logical (extended)
처컁컁카Seq # to be used in the OPTIONAL /M argument for PARTFILT


2 FAT32 partitions found! 


============
OS2DASD.F32: 
============

이것은 OS/2 에 있는 OS2DASD.DMD 의 수정판이고, PARTFILT.FLT 를 대체합니다. 이 
수정된 드라이버는 또한 OS/2 가 FAT32 파티션을 인식하도록 합니다.

주의: 이 드라이버는 최신판이 아니고, 이동식 디스크같은 최신의 기능을 지원하지 
않을 것입니다.


드라이버 얻기:
--------------

OS2DASD.F3 드라이버는 더 이상 FAT32 IFS 드라이버와 함께 배포되지 않을 
것입니다. 필요하다면, Henk 씨의 최신 바이너리 배포본에서 얻어서, 전적으로 
사용자의 부담하에 수동으로 설치할 수 있습니다. Henk Kelder 씨의 최신 배포본은 
Hobbes 에서 찾을 수 있습니다.

http://hobbes.nmsu.edu/pub/os2/system/drivers/filesys/os2fat32.zip 


설치:
----- 

주의: 이 드라이버는 Daniela 씨의 DaniDASD.DMD 가 더 나은 선택이기 때문에, 
쓰이지 않습니다. 하지만, 이 드라이버를 원한다면, 다음처럼 하여 설치될 수 
있습니다.

설치하기 위해, OS2DASD.DMD 를 OLD_OS2DASD.DMD 같은, 다른 어떤 것으로 이름을 
바꿉니다.

OS2DASD.F32 를 \OS2\BOOT 디렉토리에 복사합니다.

이름을 OS2DASD.DMD 로 바꿉니다.

다시 부팅합니다.

========================
설치/제거: 
WARPIN 설치\제거 
========================

FAT32 드리어바의 WARPIN 설치:
------------------------------------ 

WarpIN 의 최신판이 필요합니다. 이것은 다음에서 내려받을 수 있습니다.:

http://www.xworkplace.org

아직 설치가 되어있지 않다면, WarpIN 을 설치합니다.
LVM 시스템을 사용한다면, COMPATIBILITY VOLUME 을 만들고 드라이브 문자를 
할당합니다.
*.WPI 파일을 내려받은 곳으로 갑니다.
설치를 시작하기 위해 더블 클릭합니다.
설치가 끝났을 때, 설치기는 다음 파일들을 당신의 eCS/OS2 파티션에 복사할 
것입니다.

주의: 파일들의 위치는 관련성이 없습니다. .WPI 파일이 그것을 처리할 것입니다.
기본 디렉토리들은 만일 기본 ESE 가 설치되어 있다면, <ESES_dir> 아래의 BIN, 
BOOK, DLL 그리고 BOOT 가 될 것이고, 그렇지 않으면 기본 디렉토리는 \OS2, 
\OS2\BOOK, \OS2\DLL, \OS2\BOOT 가 될 것입니다. 당신이 다른 경로를 고른다면, 
WarpIN 은 그 경로를 당신의 PATH/LIBPATH 따위에 추가할 것입니다.

파일을 설치할 수 있는 디렉토리들:

파일들
목적지

CACHEF32.EXE 
\TOOLS\SYSTEM\BIN 

F32STAT.EXE 
\TOOLS\SYSTEM\BIN 

F32MON.EXE 
\TOOLS\SYSTEM\BIN 

F32PARTS.EXE 
\TOOLS\SYSTEM\BIN 

FAT32.IFS 
\TOOLS\SYSTEM\BOOT 

UFAT32.DLL 
\TOOLS\SYSTEM\DLL 

FAT32.INF 
\TOOLS\SYSTEM\BOOK 

FAT32.TXT 
\TOOLS\SYSTEM\BOOK 

FAT32.KOR 
\TOOLS\SYSTEM\BOOK (오직 한국어 지원 기능 설치를 선택했을 때만)

COUNTRY.KOR 
\OS2\SYSTEM  (오직 한국어 지원 기능 설치를 선택했을 때만)

CACHEF32.CMD 
\TOOLS\SYSTEM\BIN (오직 한국어 지원 기능 설치를 선택했을 때만)

WarpIN 은 또한 다음과 같은 줄을 CONFIG.SYS 파일에 추가합니다:
IFS=X:\TOOLS\SYSTEM\BIN\FAT32.IFS /Q 
CALL=X:\TOOLS\SYSTEM\BIN\CACHEF32.EXE 

X: 는 IFS 가 설치될 파티션입니다.

주의: WarpIN 은 루트 디렉토리에 CONFIG.SYS 의 백업을 만듭니다. 만일 설치후에 
시스템에 문제가 생긴다면, 언제나 부팅 복원 메뉴를 사용하여 명령행으로 부팅할 
수 있습니다. 복원하여 다시 작동하게 하려면, 수정된 CONFIG.SYS 를 FAT32 설치 
동안에 만들었던 백업 파일로 대체하십시오.
재부팅

비-한국어 시스템을 위한 한국어 지원:
--------------------------------------

한국어를 설치하면 여러가지 추가적 일들을 합니다.

기본적인 FAT32 파일들을 선택된 위치에 복사하고, 기본적인 CONFIG.SYS 항목들( 
FAT32 드라이버의 WARPIN 설치를 보십시오 )을 만드는 것외에, COUNTRY.KOR 을 
설치하고, CONFIG.SYS 가 COUNTRY.KOR 을 사용하게 합니다. 문제가 있을 경우, 
Alt+F1, F2 를 이용한 복원 기능은 여전히 원래의 COUNTRY.SYS 를 가리키고, 
따라서 안전합니다. "이 판에 있는 파일들" 을 보십시오.
FAT32 정보를 담고 있는 한국어 텍스트 파일을 추가합니다.
다음의 스크립트를 담고 있는 CACHEF32.CMD 파일을 하드 드라이브에 복사합니다:
chcp 949 
CACHEF32.EXE /y 

루트 디렉토리에 있는 STARTUP.CMD 파일에 다음 항목을 추가합니다.
cmd /C CACHEF32.CMD 

주의: cmd /C 가 사용되는 이유는 4OS2 가 CHCP 를 제대로 지원하지 않기 
때문입니다.

주의: 파일 이름은 CP949 에서만 한국어로 제대로 보이지만, 파일이름은 현재 코드 
페이지에 상관없이 올바르게 처리됩니다.

WARPIN 을 사용하여 제거하기:
---------------------------- 
WarpIN 을 사용하여 FAT32 IFS 가 설치되었다면, FAT32 IFS 와 관련 파일들을 
제거하기 위해 WarpIN 을 사용하십시오.

제거하기:
WarpIN 을 시작합니다.

Application 열에서, IFS 를 찾습니다. Vendor 열을 검사하고 "Netlabs" 인지 
확인합니다.

선택합니다. WarpIN 데이터 베이스는 다음 정보를 보여주어야 합니다.

주의: 제거할 파일들의 수는 설치된 FAT32 판번호와 한국어 지원이 설치되었는지에 
따라 달라질 것입니다.

목록
정보

Author. 
Netlabs. 

Version number: 
0.0.96.0 

Installation date: 
당신이 설치한 날짜

Target directory:   <drive>:\OS2 

Files: 
8 

"IFS" 에서 오른쪽 클릭.
"Deinstall package..." 을 선택. 제거되고 복구되어야 하는 것을 나열하는 메세지 
박스가 나타납니다.
"OK" 를 선택

주의: WarpIN 은 때때로 추가된 CONFIG.SYS 항목을 지우는데 문제가 있습니다. 
이것은 보통 이전판 위에 설치한 후에 나타납니다. 이것이 발생한다면, CONFIG.SYS 
를 수동으로 편집하여, 다음 항목들을 제거해야만 합니다.

IFS=X:\TOOLS\SYSTEM\BOOT\FAT32.IFS /Q 
CALL=X:\TOOLS\SYSTEM\BIN\CACHEF32.EXE 


수동 설치 :
-----------

ZIP 형태로 압축되어 있다면, 임의의 디렉토리에 그 파일들을 UNZIP 을 이용하여 
풉니다. 만일 WarpIN 형식이라면, 다음처럼 합니다:

*.WPI 파일을 임의의 디렉토리에 복사합니다. WarpIN 디렉토리에서 "WIC.EXE" 와 
"WPIRTL.DLL" 파일을, *.WPI 파일들을 복사했던 임의의 디렉토리에 복사합니다. 
FAT32 파일들을 추출하기 위해, 명령 프롬프트를 열고, 임의의 디렉토리로 바꾸고 
나서, 다음 명령을 입력합니다:

wic.exe *.wpi -x (x 는 소문자). 

*.WPI 파일을 FAT32 WPI 파일의 이름으로 대체합니다.

파일들이 추출된 후에, 다음처럼 합니다:

주의: WarpIN 을 이용하여 FAT32 드라이버 0.96 또는 그 이후판을 설치했고, 
수동으로 업데이트하기 바란다면, 각각의 파일이 위치한 곳을 알기 위해 WarpIN 
데이터베이스를 확인하십시오. WarpIN 데이터베이스에 저장되어 있는 위치 
(디렉토리) 로 파일들을 복사합니다.

FAT32 드라이버 0.95 또는 이전판을 수동으로 또는 WarpIN 을 이용하여 
설치했다면, 다음 파일들을 \OS2 디렉토리에 복사하십시오:

FAT32.IFS 
FAT32.TXT 
CACHEF32.EXE 
F32STAT.EXE 
F32MON.EXE 

다음 파일을 \OS2\DLL 디렉토리에 복사하십시오:
UFAT32.DLL 

한국어 문서가 있습니다. 이것은 당신이 한국인이 아니라면 필요하지 않습니다.
FAT32.KOR 

다음 파일은 WSeB 픽스팩 #2 에 있는 "COUNTRY.SYS" 를 패치한 것입니다. 
이상하게도, WSeB 의 "COUNTRY.SYS" 는 한국어, 특히 DBCS 첫바이트에 대한 잘못된 
정보를 담고 있습니다. 이것이 없다면, 한국인은 한국어 문자로 이루어진 파일들을 
사용할 수 없습니다. 한국어 시스템에 있는 대체용 COUNTRY.SYS 파일은 FAT32.IFS 
가 올바르게 작동하기 위해 반드시 필요합니다. 비-한국어 시스템에서, 
COUNTRY.SYS 를 대체하는 것은 반드시 필요한 것은 아닙니다. 하지만 설치기가 
원한다면 시스템에 아무런 해를 주지 않고 처리될 수 있습니다. 사용하기 위해, 
\OS2\SYSTEM 디렉토리에 있는 "COUNTRY.SYS" 파일의 이름을 바꾸고, "COUNTRY.KOR" 
를 복사한 후에, 그 이름을 "COUNTRY.SYS" 로 바꿉니다.

COUNTRY.KOR 

이 스크립트는 비-한국어 시스템에 한국어 코드페이지 지원을 추가합니다. 이 
파일을 CONFIG.SYS 의 PATH 문에 나열된 디렉토리 중의 하나에 복사하십시오. 루트 
디렉토리에 있는 STARTUP.CMD 에 CACHEF32.CMD 의 위치를 추가하십시오. 
STARTUP.CMD 가 없다면 만드십시오.

CACHEF32.CMD 

CONFIG.SYS 를 다음처럼 바꾸십시오:

IFS=x:\OS2\FAT32.IFS [옵션] 
(IFS=HPFS.IFS 이후 아무데나 이 문장을 넣으십시오.)

CALL=x:\OS2\CACHEF32.EXE [옵션] 

주의: RUN 이 아니라 CALL 인지 확인하십시오.

========================
FAT32 IFS 구성과 스위치: 
========================

이 판에 있는 파일들:
-------------------- 

FAT32.INF 
INF 설명 파일

FAT32.TXT 
ASCII txt 형식으로 된 FAT32 정보(오래된 것일 수 있음).

FAT32.IFS 
실제 IFS. 

CACHEF32.EXE 
캐시 도우미 프로그램

UFAT32.DLL 
FAT32 파티션에서 CHKDSK 를 수행하기 위해 필요한 모듈

F32STAT.EXE  
FAT32 파티션의 DIRTY 상태를 바꾸는 프로그램

F32MON.EXE  
(이전의 MONITOR.EXE) FAT32.IFS 가 하는 것을 모니터하는 프로그램

F32PARTS.EXE 
(이전의 DISKINFO.EXE) 파티션들을 검색하고 보여주는 진단 프로그램

* FAT32.KOR  
이 문서

* COUNTRY.KOR  
WSeB 픽스팩 #2 에 있는 "COUNTRY.SYS" 의 패치판. 이상하게도 WSeB 의 
"COUNTRY.SYS" 는 한국어, 특히 DBCS 첫번째 바이트에 대해 잘못된 정보를 담고 
있습니다. 이것이 없다면, 파일이름에 한국어 문자를 쓸 수 없습니다. 사용하려면, 
\OS2\SYSTEM 디렉토리에 있는 "COUNTRY.SYS" 의 이름을 바꾸고, "COUNTRY.KOR" 를 
\OS2\SYSTEM 디렉토리에 복사한 후에, 이름을 "COUNTRY.SYS" 로 바꾸십시오.

* CACHEF32.CMD 
한국어 코드페이지와 CACHEF32.EXE 를 로드하기위한 스크립트

FAT32.IFS: 
----------

FAT32.IFS 가 실질적인 "설치 가능한 파일 시스템(IFS)" 드라이버입니다. 이것은 
CONFIG.SYS 에 다음처럼 파일 시스템 드라이버의 경로와 완전한 이름을 
명시함으로써 설치됩니다.

IFS =  ---+---------+-+--------+- filename -+-------------+---
          +- drive -+ +- path -+            +- arguments -+


예

기본 설정( 곧, 어떤 파라미터도 지정되지 않았을 때 ) 은 1024 KB 의 캐시와 
메세지를 출력하지 않는 것입니다.

IFS=X:\TOOLS\SYSTEM\BIN\FAT32.IFS /Q 

확장 속성을 지원하고, 캐시를 2048KB 로 설정하려면, CONFIG.SYS 에 다음처럼 
입력하십시오. 그리고 시스템을 다시 시작하십시오.

IFS=X:\TOOLS\SYSTEM\BIN\FAT32.IFS  /cache:2048 /EAS 

주의: 시스템이 시작될 때 FAT32 파티션이 발견되지 않는다면, 드라이버는 
로드되지 않을 것입니다.

FAT32 IFS 옵션: 
----------------- 

/Q 
조용히, 아무런 메세지도 출력하지 않습니다.

/CACHE:nnnn 
캐시 크기를 킬로바이트 단위로 지정합니다. 생략된다면, 기본 캐시 크기는 1024KB 
가 됩니다. 최대 캐시 크기는 2048KB 입니다. *

주의: 캐시 크기는 고정(FIXED) 메모리로 할당됩니다. 따라서 실제 메모리가 16MB 
보다 적다면, 크기를 512KB 이하로 지정하십시오.

/MONITOR 
기본적으로 감시 기능(MONITOR) 를 ON 합니다. 생략된다면 MONITOR 는 OFF 가 
됩니다. 더 자세한 정보는 F32MON.EXE 를 보십시오.

/RASECTORS:n 
미리 읽을 섹터 개수. 읽기를 수행할 때마다 한 번에 읽어, 캐시에 저장될 섹터의 
최소 개수를 지정합니다. 생략된다면 기본값은 볼륨에 따라 다른데, 클러스터당 
섹터 개수의 2 배가 됩니다. 최대값은 클러스터당 섹터 개수의 4 배가 됩니다. 
하지만 RASECTORS 의 최대값은 0.96 판부터 클러스터당 섹터 개수의 4 배에서, 128 
로 바뀌었습니다.

주의: 읽기를 수행할 때마다 실제 섹터 IO 는 응용 프로그램이 아니라 IFS 에 의해 
결정됩니다. FAT 에 액세스할 때에는, 섹터 한 개를 읽습니다. 디렉토리와 파일 IO 
에 대해서는, 클러스터 단위로 읽어들입니다. RASECTORS 를 설정함으로써, IFS 가 
디스크로부터 읽어 캐시에 저장할 섹터의 최소 개수를 정의할 수 있습니다.

/EAS 
FAT32.IFS 가 확장 속성을 지원하도록 합니다.

!중요! 0.97 판부터, FAT32 IFS 드라이버가 확장 속성을 지원하도록 하기 전에, 
각각의 FAT32 파티션에 대해 'CHKDSK /F' 를 먼저 수행해야 합니다. 왜냐하면 
WinNT 계열과의 호환성때문에 확장 속성 표시 바이트가 바뀌었기 때문입니다.

F32STAT.EXE 이용하여, 다음에 부팅될 때 CHKDSK 가 자동으로 실행되도록 할 수 
있습니다. 다음처럼 하십시오.

F32STAT.EXE x: /DIRTY

여기서 x: 는 확장 속성이 있는 파일들을 가지고 있는 FAT32 드라이브입니다.

F32STAT.EXE 는 한 번에 하나의 드라이브만을 지원하기 때문에, 드라이브가 여러개 
있다면, 각각에 대해서 F32STAT.EXE 를 실행해야 합니다.

예) C: D: 가 FAT32 드라이브라면

F32STAT.EXE C: /DIRTY
F32STAT.EXE D: /DIRTY

남은 공간: 
------------

대부분의 FAT32 드라이브에, 남은 공간의 크기가 저장됩니다. FAT32.IFS 는 다음의 
경우에만 남은 공간의 크기를 다시 결정할 것입니다.

- 부팅할 때 디스크가 나쁜 상태(DIRTY) 상태였을 때.

- 디스크상에 남은 공간이 -1 로 되어 있을 때.

- 디스크상에 남은 공간이 사용가능하지 않을 때.

FAT32.IFS 는 내부적으로 남은 공간을 기억하고 있다가, 시스템이 종료될 때 
그것을 디스크에 기록할 것입니다.

CACHEF32.EXE 의 목적
----------------------------

CACHEF32.EXE 는 다음 기능을 가지는 도우미 프로그램입니다:

- 부팅할 때 디스크 상태를 검사하고, 필요하다면 CHKDSK 를 수행합니다.

- 쓰기 캐시(LAZY WRITE) 데몬을 시작합니다.

- CACHE 와 미리 읽기(READ-AHEAD) 파라미터를 설정합니다.

- 긴 이름(Longname)에 대한 처리 방법을 설정합니다.

- 긴 이름과 기본 코드페이지에 대한 코드페이지-유니코드 변환 테이블을 
로드합니다.

포그라운드(foreground)로 실행되고, CACHEF32 가 이미 실행중이면, CACHE 
파리미터가 출력되고, 그 값들을 바꿀 수 있도록 합니다. CACHEF32 가 실행되고 
있지 않으면, 백그라운드(background)로 실행이 됩니다.

백그라운드(detached) 로 실행될 때, CACHEF32 는 쓰기 캐시 데몬 역할을 할 
것입니다.

CACHEF32 옵션들: 
----------------- 

/? 
도움말을 보여줍니다.

/Q 
CACHEF32 를 종료합니다. CACHEF32 는 메모리에서 제거되고, 쓰기 캐시는 중지될 
것입니다(성능이 떨어질 것입니다). 

/N 
백그라운드로 데몬을 시작하지 않고 CACHEF32 를 실행합니다.

/D:nn 
DISKIDLE 값을 설정합니다. CACHE 에 대한 OS/2 온라인 도움말을 보십시오.

/B:nn 
BUFFERIDLE 값을 설정합니다. CACHE 에 대한 OS/2 온라인 도움말을 보십시오.

/M:nn 
MAXAGE 값을 설정합니다. CACHE 에 대한 OS/2 온라인 도움말을 보십시오.

/R:d:,n 
드라이브 D 의 RASECTORS 를 n 으로 설정합니다.

/L:ON|OFF 
쓰기 캐시를 ON 또는 OFF 합니다. 기본은 ON 입니다.

/P:1|2|3|4 
쓰기 캐시에 대한 우선권을 설정합니다. 1 은 가장 낮고, 4 은 가장 높습니다. 
기본은 1(=유휴 시간)입니다. 시스템 부하가 커서 쓰기 캐시가 CPU 를 사용하지 
못하는 것 같다면, 이것이 적당합니다.

/Y 
YES 를 가정합니다.

/S 
정상적인 메세지는 출력하지 않습니다.

/CP 
코드 페이지를 지정합니다.

/F
FAT32 파티션이 없더라도, 쓰기 캐시(LAZY WRITE)를 로드합니다.

주의: /T 옵션은 0.83 판에서 제거되었습니다.

주의: /FS 와 /FL 옵션은 0.98 판에서 제거되었습니다.

CHKDSK / UFAT32.DLL  

UFAT32.DLL 은 FAT32 드라이브에 대해 CHKDSK 명령이 실행될 때마다 CHKDSK 에 
의해 호출됩니다. UFAT32.DLL 은 현재 CHKDSK 만을 지원합니다.

CHKDSK 에 대해, 다음 옵션들이 구현되어 있습니다:

옵션 
설명

/F 
문제점을 고칩니다(현재 UFAT32.DLL 은 오직 잃어버린 클러스터(LOST CLUSTERS) 와 
잘못된 남은 공간 크기만을 고칩니다).

/C 
드라이브가 부팅될 때 잘못된 상태라면, 잃어버린 클러스터를 자동으로 파일로 
변환하게 합니다(물어보지 않습니다).

/V:1 
CHKDSK 가 조각난 파일들을 보여주두록 합니다.

/V[:2] 
CHKDSK 가 검사된 모든 파일들을 자세하게 보여줍니다(기본).

CHKDSK 는 다음 검사를 수행합니다:

- FAT 의 모든 사본을 검사합니다;

- 각각의 파일에 대해 파일 할당 문제를 검사합니다;

- 파일 또는 디렉토리마다 VFAT 긴 파일이름을 검사합니다;

- /F 가 지정되었으면, 잃어버린 클러스터를 고칩니다.

- /F 가 지정되었으면, 서로연결된 파일들을 고칩니다.

- 남은 공간을 체크하고, /F 가 지정되었으면, 잘못된 설정을 바로 잡습니다.
잃어버린 확장 속성을 검사합니다.

깨끗한 종료 CHKDSK:
-----------------------

Windows 95(OSR2) 또는 이후에서 올바르게 시스템이 종료되면, 디스크의 깨끗한 
종료 상태는 물리적으로 디스크에 쓰여집니다. 다음 부팅때 이 상태는 검사되고, 
디스크가 올바르게 종료되지 않았다면, SCANDISK 가 실행됩니다.

FAT32.IFS 또한 이 기능을 지원합니다. CACHEF32 가 CONFIG.SYS 에서 호출될 때, 
FAT32 드라이브의 상태를 IFS 의 호출을 통하여 검사합니다.
올바르게 종료되지 않은 드라이브에 대해 CHKDSK 가 실행됩니다. 오류가 발견되지 
않거나 잃어버린 클러스터만이 발견되고 고쳐진다면, 드라이브는 좋은 상태(OK) 로 
표시됩니다.

만일 CHKDSK 가 문제를 해결할 수 없다면, 드라이브 상태는 나쁜 상태(DIRTY) 로 
남게 되고, "어떤 파일들도 열 수 없고, 어떤 디렉토리도 추가하거나 제거할 수 
없습니다". 디스크를 종료하면, 디스크는 올바르게 종료되지 않은 상태로 남게 
됩니다. Windows 로 부팅해서, 남은 문제를 고치기 위해, 그 드라이브에 SCANDISK 
를 수행해야 합니다.

하지만, F32STAT 를 통해 보통의 FAT32.IFS 처리를 피하도록 드라이브 상태를 
설정할 수 있습니다. 더 자세한 것은 F32STAT 의 설명을 보십시오.

F32MON.EXE (이전의 MONITOR.EXE):
--------------------------------  

F32MON 은 (대부분의) FAT32 활동을 화면에 보여줄 것입니다. 이 프로그램은 
문제점을 해결하기위해 고안되었습니다. F32MON 을 사용하면 FAT32 가 감시 정보를 
내부 버퍼에 보내야만 하기 때문에 성능이 떨어집니다. 이 내부 버퍼는 4096 
바이트 크기입니다. 그래서 감시 기능이 켜졌지만, F32MON 이 실행되지 않았다면, 
수집된 정보는 사라집니다. 하지만, 이런 일은 FAT32.IFS 에 대한 IFS= 줄 뒤에 
/MONITOR 가 지정되는 경우에만 발생합니다.

만일 /MONITOR 명령이 CONFIG.SYS 에서 IFS= 문에 뒤에 지정되지 않았다면, 감시 
기능은 기본적으로 OFF 됩니다. 하지만 F32MON 을 일단 시작하면 감시 기능이 
활성화됩니다.

F32MON 이 실행될 때, 정보는 화면상에 보여지고, 뿐만 아니라 현재 디렉토리의 
FAT32.LOG 에 기록됩니다.

F32MON 이 종료될 때, 내부 감시 기능은 꺼집니다. F32MON 의 사용법은:

F32MON [추적마스크] [/S] 

추적마스크(tracemask)가 생략된다면, 1 로 설정됩니다.

추적마스크는 특정 형태의 정보를 보여주기 위한 특정 비트들의 조합니다. 이런 
식으로, 선택적으로 감시를 할 수 있습니다.

추적마스크에는 다음값들이 있습니다:
 1 - FS_xxxxx 진입 지점(ENTRY POINT)에 대한 호출과 되돌림(RETURN)값들을 모두 
보여줍니다.
 2 - 추가적(내부적) 함수 호출들을 보여줍니다.
 4 - 캐시와 관련된(쓰기 캐시) 함수 호출을 보여줍니다.
 8 - 내부적으로 메모리를 처리하는(malloc & free) 메모리 호출을 보여줍니다.
16 - FS_FINDFIRST/FS_FINDNEXT 호출들을 보여줍니다.
32 - 몇몇 다른 호출들을 보여줍니다.
64 - 확장 속성 처리를 보여줍니다.

여러 개를 한꺼번에 감시하기 위해서는 값들을 더해야 합니다:

예)
FS_xxxx 호출과 캐시 관련 정보를 모두 보고자 한다면, 추적마스크의 값으로, 1 + 
4 = 5 를 사용해야 합니다.

옵션
설명

/S   
화면에는 출력하지 않고, FAT32.LOG 에만 기록합니다. 이것은 프로그램이 IFS 를 
따라갈 수 없을 정도로, F32MON 이 많은 메세지를 화면에 보내는 경우에 
유용합니다. /S 를 사용하면 FAT32.LOG 에만 출력하기 때문에, 화면 처리에 
손실되는 시간이 없습니다.

F32STAT.EXE 의 목적:
--------------------

F32STAT 은 FAT32 드라이브의 깨끗한 종료 상태를 알아보기 위해 사용될 수 
있습니다. 또한 이것을 통해 깨끗한 종료 상태를 바꿀 수 있습니다. 부팅될 때 
나쁜 상태(DIRTY)였고 CHKDSK 가 문제를 해결할 수 없었기 때문에, FAT32.IFS 가 
디스크에 액세스하는 것을 차단하는 경우에, 이 기능을 쓸 수 있습니다.

사용법은: 

   F32STAT 드라이브: [옵션] 


F32STAT.EXE 옵션: 
-------------------- 

/CLEAN  - 
부팅될 때 디스크가 좋은 상태였고, 사용될 수 있다고 FAT32.IFS 에 알립니다. 
디스크 자체는 그 때에 좋은 상태(CLEAN)로 표시됩니다. (FAT32.IFS 가 사용하는 
내부 DIRTY 상태는 좋은 상태가 될 것입니다.)

/FCLEAN   - 
부팅될 때 디스크가 좋은 상태였고, 사용될 수 있다고 FAT32.IFS 에 알립니다. 
디스크 자체는 그 때에 좋은 상태로 표시됩니다. (FAT32.IFS 가 사용하는 내부 
DIRTY 상태는 종은 상태가 되고, 디스크 상의 표시또한 좋은 상태(OK)가 될 
것입니다)

/DIRTY    - 
내부 DIRTY 상태를 설정하도록 FAT32.IFS 에 알리고, 디스크의 드라이브를 나쁜 
상태로 표시합니다. 종료될 때, 드라이브는 나쁜 상태로 남을 것이고, Windows 
95(OSR2) 또는 이후 Windows 판으로 부팅할 때, SCANDISK 가 실행될 것입니다.

====================
현재 상태와 기능들:
====================

한계:
------------

- 논리적으로, FAT32 는 이제 2 테라바이트 크기의 파티션까지 지원합니다. 
하지만, MS 클러스터당 섹터 수와 섹터당 바이트 수의 또다른 조합을 사용하지 
않는다고 확신할 수 없습니다. 만일 그렇다면, 지원되는 크기는 더 작아질 수 
있습니다. FAT32 파티션은 4GB 크기까지의 파일을 포함할 수 있습니다. 4GB 는 
FAT32 파일 시스템 자체의 한계입니다. 2GB 보다 작은 파일들은 FAT32 파티션으로 
복사 또는 이동될 수 있습니다. 2GB 보다 큰 파일들은 XCOPY 같은 몇 몇 
프로그램이 읽을 수 없습니다. XCOPY 자체가 2GB 보다 큰 파일들을 지원하지 않는 
것 같습니다.

- 비-이동식 하드 디스크만을 지원합니다.

- 512 바이트 크기의 섹터를 사용하는 디스크만을 사용합니다( 이외의 것들이 
있습니까 ? )

- FAT32 파티션에서 부팅할 수 있습니다.

- SWAPPER.DAT 를 FAT32 파티션에 둘 수 없습니다.

- CHKDSK 는 디스크를 진단할 수 있지만, 잃어버린 클러스터와 잘못된 나은 공간 
계산만을 고칩니다. 다른 모든 오류들에 대해서는, Windows 를 실행시켜, SCANDISK 
를 시작하여 문제를 고칠 필요가 있습니다.

- CHKDSK 는 언제나 잃어버린 클러스터들을 파일로 변환하고, 디렉토리는 
그렇게하지 않습니다. 그렇게 하기를 원한다면, SCANDISK 를 사용하십시오.

- FORMAT, RECOVER 와 SYSINSTX 명령은 지원되지 않습니다.

- 오직 마지막 액세스 날짜(마지막 액세스 시간이 아님)는 FAT32.IFS 에 의해 
유지됩니다. 이것은 Win95(OSR2)와 비슷합니다.

- 긴 파일이름은 DOS 와 Win-OS/2 세션에서 기본적으로 지원되지는 않습니다. 이 
세션은 오직 짧은 파일이름만을 사용합니다. 'OS/2 와 DOS 세션에서의 긴 
파일이름' 을 보시기 바랍니다.

- 확장 아스키 문자들을 포함하고 있는 파일이름을 가진 파일을 열었다면, 
진행중에 코드페이지를 바꾸지 않는 것이 좋습니다.

- PARTFILT.FLT 를 사용하고 있다면, FDISK, 파티션 매직 또는 모든 파티션 관리 
도구들을 존재하지-않는 드라이브와 잘못된 다른 정보들을 보여줄 것입니다.

- 이 판은 OS/2 의 NLS 지원 기능이 필요합니다. 이것은 Warp 3 픽스팩 #26 또는 
그 이상 또는 Warp 4 를 의미합니다.( 반드시 LANGUAGE 디렉토리를 가지고 있어야 
합니다 )

이동 매체(REMOVEABLE MEDIA):
----------------------------
현재, FAT32 를 쓸 수 있는 유일한 "이동" 매체들은 USB 또는 내장 
하드디스크뿐입니다. FAT32 드라이버는, USB 드라이버가 지원한다면, USB 하드 
디스크 또는 USB 외장 장치에 들어있는 디스크를 인식하는 데 문제가 없습니다. 
LVM 시스템에서는, 드라이브에 볼륨 문자를 할당해야 할 필요가 있습니다.

플래시(Flash) 매체에서는 FAT32 드라이버가 결코 쓰이지 않습니다. 왜냐하면 모든 
매체가 M$ 의 FAT32 정의에 따라 FAT 로 포맷되기 때문입니다. FAT32 볼륨은 512 
MB 이상의 매체에 대해서만 *합법적으로* ( 곧, MS 가 주장하는대로 ) 만들어질 수 
있습니다. 따라서 플래시 매체는 분명 이에 해당되지 않습니다.

WINDOWS 와의 호환성:
---------------------------- 

처음 만든이인 Henk Kelder 씨 말에 따르면, FAT32.IFS 는 Windows 의 FAT32 
지원과 완전하게 호환됩니다. 그의 PC 에서 VFAT 긴 파일이름이 사용할 수 
있었습니다. Windows 는 FAT32.IFS 가 만든 긴 파일이름에 대해 (더이상!) 
불평하지 않았습니다. 숫자 꼬리가 있는 짧은 이름 역시 올바르게 작동했습니다. ( 
숫자 꼬리 옵션은 끌 수 없습니다! )

파일 이름은 Windows 에서처럼 (OS/2 세션에서) 대소문자가 보존됩니다. 소문자로 
된 이름을 만든다면, 8.3 을 만족시키는 이름이더라도 VFAT 긴 이름을 가지는 
파일이 생깁니다. 대소문자는 보존됩니다.

마지막 액세스 날짜는 FAT32.IFS 가 유지합니다. (하지만, 마지막 액세스 시간은 
유지하지 않습니다. 왜냐하면 Win95 가 지원하지 않기 때문입니다) 드라이브 
객체에 대해 자세히 보기를 적용할 때 이것을 알 수 있습니다.

Win2X 와 WinXP 같은 WinNT 계열의 시스템에서 만들어진 파일들을 FAT32 
드라이버가 확장 속성을 가진 것으로 인식할 가능성이 있습니다.

최신의 Netlabs 판(0.97)에서 수정되었지만, FAT32 드라이버가, 실제로는 EA 
파일이 아닐지라도, EA 필드(FIELD)에 0 이 아닌 값을 가진 파일을 EA 파일로서 
인식할 가능성은 여전히 있습니다. 왜 ? EA 필드에 0x40 과 0x80 을 가진 파일만이 
EA 파일로 인식되어야 합니다. 하지만 WinNT 계열에서 만들어진 파일들이 EA 
필드에 0x40 또는 0x80 을 가지지 않는다고 확신할 수 없습니다. 다행히, 이것은 
거의 일어나지 않습니다. 만일 그런 파일이 발견된다면, CHKDSK 가 이에 대해 
불평할 것입니다.

"표시 바이트" 를 보십시오.

WINDOWS OS/2 문자셋:
--------------------

OS/2 는 표준 문자셋을 사용합니다. 그런 문자셋을 코드페이지라고 부릅니다.

기본적으로 Windows 긴 파일이름(VFAT)는 유니코드로 저장됩니다.

Warp 3(픽스팩 26 ?) 부터 OS/2 는 NLS 지원 기능을 가지고 있습니다.

오직 하나의 코드페이지만을 위한 변환 테이블이 로드된다는 것을 명심하십시오. 
(CHCP 를 사용해서) 코드페이지를 바꾼다면, 새로운 테이블을 로드하기위해 반드시 
CACHEF32 를 다시 실행시켜야 합니다. 하지만 OS/2 는 세션마다 다른 코드페이지를 
유지하기 때문에, CP 를 바꾸기 위해 CHCP 를 사용한다면, 그 CP 는 그 세션에만 
적용이 된다는 것을 명심하십시오.

OS/2 와 DOS 세션:
-----------------

긴 파일이름은 오직 OS/2 세션에서만 보이고, 도스에서는 이에 상응하는 짧은 
파일이름이 입니다. 하지만, OS/2 세션에서 짧은 이름과 긴 이름을 섞은 형태로 
파일 
이름을 지정하여 파일을 지우거나, DOS 세션에서 긴 이름을 가진 파일을 지우면, 
WPS 
가 파일이 지워졌다는 것을 알지 못합니다.

랜을 통한 LFN(긴 파일이름) 전송:
--------------------------------

FAT32 드라이버는 랜을 통해 Windows 가 OS/2 에 짧은 파일 이름을 보여주는 것과 
아무런 관련이 없습니다. 그 문제는 분명히 있고, 그 원인은 Windows 의 랜 지원 
기능입니다.

짧게: 
만일 Windows 가 OS/2 에 있는 파일을 조작한다면, 아무런 문제가 없습니다. 
반대로 Windows 에 있는 파일을 OS/2 가 조작한다면, 긴 파일이름의 경우 문제가 
생길 수 있습니다. 

더 장확하게:
Windows NT, Windows 2000, Windows XP 또는 새로운 판을 가지고 있다면, 긴 파일 
이름(LFNs)는 네트워크를 통해 연결된 eCS/OS2 와 Windows 시스템사이에서 서로 
완전하게 조작할 수 있습니다.

Windows 시스템이 이보다 더 오래된 Windows 95, 98 그리고 ME 라면, Windows PC 
에서, 멀리 떨어진(REMOTE) eCS/OS2 컴퓨터에 있는 LFNs 에 아무 문제 없이 작업을 
할 수 있습니다. 하지만, 반대로는 작동하지 않습니다. 다시 말해서, 멀리 떨어진 
Windows 컴퓨터는 네트워크에 있는 다른 Windows 에는 LFNs 을 보여주지만, 
eCS/OS2 컴퓨터에는 대신 짧은 파일이름을 제공할 것입니다.

왜 ?

이것은 랜 상에서 각각의 PC 가 자신을 드러내는 방법과 네트워크에서 다른 PC 에 
대한 능력때문입니다. eCS/OS2 는 다른 컴퓨터에 호환성때문에 LM10 을 사용한다고 
합니다. 이것 때문에 Win9X 컴퓨터는 이것을 마치 DOS+W3.11(곧, LFNs 가 
없는)처럼 취급합니다. IBM 에 따르면, eCS/OS2 는 LM30 을 완전하게 수행할 수 
있습니다 - 하지만 바이너리 파일을 패치하려고 하지 마십시오, 그렇지 않으면 
트랩이 발생합니다. 네, 이것은 명백한 IBM 의 실수입니다.

좋습니다, eCS/OS2 는 자신이 LM10 이라고 합니다. 그리고 이에 대해 Microsoft 를 
탓할 수 없습니다. 하지만, 랜 상의 다른 eCS/OS2 는 'LM10' 레이블 뒤에 있는 
OS/2 를 찾아내어, 문제없이 LFN 조작을 허용하는데 아무런 어려움도 없습니다.

2003 년 2 분기에, Win9X 네트워킹을 위한 패치가 배포되었습니다.( 중요한 OS 
네트워크 서브시스템에 대한 패치로서, 아마도 OS/2 피어(PEER) 또는 다른 어떤 
것을 위한 IBM Windows 클라이언트 형태였을 것입니다. 곧, M$ 자신이 배포한 것이 
아닙니다).

확장 속성:
----------

0.70 부터, FAT32.IFS 는 확장 속성을 지원합니다.

FAT32.IFS 가 확장 속성을 지원하기 위해서는, CONFIG.SYS 에 NT IFS=... 뒤에 
/EAS 가 지정되어야 합니다.

확장 속성은 다음의 방식으로 구현됩니다:

확장 속성을 가지고 있는 각각의 파일 또는 디렉토리에 대해, 파일 또는 디렉토리 
이름과 ' EA. SF' 가 뒤에 붙는 EAs 으로 구성되는 이름을 가진 파일이 
만들어집니다. 그래서 만일 'FILE' 이라는 파일이 확장 속성을 가진다면, 이 
속성들은 'FILE EA. SF' 라는 파일에 저장됩니다.

이 확장 속성 파일들은 숨김, 읽기-전용, 시스템 속성을 갖습니다.

FAT32.IFS 는 디렉토리를 나열할 때 이 파일들을 보여주지 않을 것입니다. 하지만 
Win9X 와 이후의 것들은 이 파일들을 보여줄 수 있습니다.

표시 바이트: 
------------

속도를 조금 올리기 위해, FAT32.IFS 는 확장 속성이 있는 각각의 파일을 
표시합니다. 이 표시를 위해, 디렉토리 항목에서 분명히 사용되지 않는 바이트가 
사용됩니다. 이 바이트의 값은 보통의 EAs 을 가지는 파일들은 0x40 이고, 중요한 
EAs 를 가진 파일들은 0x80 이 됩니다. 그리고 EAs 가 없는 파일들은 0x00 이 
됩니다.

( 도스 프로그램처럼 EAs 를 처리할 수 없는 프로그램은 중요한 EAs 를 가지는 
파일들을 열 수 없다는 것을 주의하십시오 )

이 바이트 (직접적으로 파일 속성을 따르는) 는 Windows 를 실행하는 동안 바뀌지 
않고, SCANDISK 와 DEFRAG  모두 이 바이트를 바꾸지 않습니다. 하지만 
이론적으로, Windows 에서 실행되는 다른 프로그램들은 이 바이트를 수정할 수 
있습니다.

만일 또다른 프로그램이 EAs 를 가진 파일에 대해 그 값을 0x00 으로 설정한다면, 
이 EAs 는 DosFindFirst/Next 호줄만을 사용해서는 더 이상 발견할 수 없습니다. 
EAs 를 읽기 위한 다른 OS2 호출들은 이 바이트에 의존하지 않습니다.

또한, 다시 반대의 경우가 이론적으로 생길 수 있습니다. EAs 가 없는 파일들이 
EAs 를 가진 것으로 표시될 수 있습니다. 이런 경우에는 오직 디렉토리 검색 
성능만이 감소될 것입니다.

하지만, CHKDSK 는 두 경우 모두를 검사하고, 필요하면 고칩니다.

문제점:
-------

현재, 확장 속성을 사용할 때의 문제점은 디렉토리 검색 성능이 약간 떨어진다는 
것입니다.

개개의 파일을 열고 액세스하는 오버헤드는 거의 눈에 띄지 않습니다.

만일 정말 확장 속성이 필요하지 않는다면, 간단히 CONFIG.SYS 에서 IFS 줄 뒤에 
/EAS 를 지정하지 마십시오.

잇점:
-----

FAT32.IFS 가 확장 속성을 지원할 때 생기는 잇점들은:
- WPS 폴더와 파일 설정들을 저장하기 위해 EAs 를 매우 많이 사용합니다. EAS 가 
없다면, WPS 는 부트될 때마다 설정을 기억하지 못합니다.

- REXX .CMD 파일들은 실행될 때마다 토큰화됩니다, 그래서 성능이 감소됩니다.

- EAS 가 있다면 .CMD 의 토크화된 것이 EAs 에 저장됩니다.

디렉토리를 검색하는 동안, 약간의 성능 저하가 있더라도 문제가 없다면, 
CONFIG.SYS 에서 IFS 줄 다음에 /EAS 를 지정하기 바랍니다.

확장 속성 지원이 정말 필요 없고, 디렉토리 검색 성능이 저하되는 것을 참을 수 
없다면, 간단히 CONFIG.SYS 에서 IFS 줄 뒤에 /EAS 를 지정하지 마십시오.

====================
드라이버 인터페이스: 
====================

IOCTL 지원:
-------------- 

IOCTL 호출(범주 8)은 이제 OS2DASD 에 직접 전해집니다. 이제 OS2DASD.DMD 가 
지원하는 모든 호출은 IFS 에서도 지원됩니다.

지원되는 함수들:
---------------- 

FS_ALLOCATEPAGESPACE: 
No 

FS_ATTACH: 
No 

FS_CANCELLOCKREQUEST: 
No. 커널에서 구현됩니다

FS_CHDIR: 
Yes 

FS_CHGFILEPTR: 
Yes 

FS_CLOSE: 
Yes 

FS_COMMIT: 
Yes 

FS_COPY: 
부분적으로, 지원되지 않는 것들은 명령쉘이 시뮬레이트합니다.

FS_DELETE: 
Yes 

FS_DOPAGEIO: 
No 

FS_EXIT: 
Yes 

FS_FILEATTRIBUTE: 
Yes 

FS_FILEINFO: 
Yes 

FS_FILEIO: 
No 

FS_FILELOCKS: 
No. 커널에서 구현됩니다.

FS_FINDCLOSE: 
Yes 

FS_FINDFIRST: 
Yes 

FS_FINDFROMNAME: 
Yes 

FS_FINDNEXT: 
Yes 

FS_FINDNOTIFYCLOSE: 
OS/2 WARP 에서 쓰이지 않습니다.

FS_FINDNOTIFYFIRST: 
OS/2 WARP 에서 쓰이지 않습니다.

FS_FINDNOTIFYNEXT: 
OS/2 WARP 에서 쓰이지 않습니다.

FS_FLUSHBUF: 
Yes 

FS_FSCTL: 
Yes 

FS_FSINFO: 
Yes 

FS_INIT: 
Yes 

FS_IOCTL: 
Yes - LOCK & UNLOCK. 다른 것들은 OS2DASD 에 전달됩니다.

FS_MKDIR : 
Yes 

FS_MOUNT: 
Yes 

FS_MOVE: 
Yes 

FS_NEWSIZE: 
Yes 

FS_NMPIPE: 
No 

FS_OPENCREATE: 
Yes 

FS_OPENPAGEFILE: 
No 

FS_PATHINFO: 
Yes 

FS_PROCESSNAME: 
Yes 

FS_READ: 
Yes 

FS_RMDIR: 
Yes 

FS_SETSWAP: 
No 

FS_SHUTDOWN: 
Yes 

FS_VERIFYUNCNAME: 
No 

FS_WRITE: 
Yes 

성능: 
-----

모든 코드는 보통의 16 비트 C 입니다(OS/2 의 모든 IFS 는 16 비트입니다!). 
어셈블리어는 전혀 사용되지 않았습니다.

감시 기능이 많은 시간을 소모합니다. 감시 기능이 필요하지 않다면, 기능을 
껐는지 확인하십시오.

당신의 상황에 맞는 최적의 성늘을 얻기 위해 CACHEF32 옵션들을 실험적으로 
조절할 수 있습니다.

쓰기 캐시에 대한 기본 설정은 유휴시간 우선권(/P:1)입니다. 특히 FAT32.IFS 에 
성능 문제가 있다면, /P 옵션 또한 실험적으로 조절할 수 있습니다. 

최적의 성능을 내기 위해, 가능하면 디스크를 조각모음 상태로 유지하기 바랍니다.
디스크에 조각 모음을 수행하기 위해서는 Windows 9X 또는 이후의 것에 있는 
DEFRAG 를 사용하십시오.

==============
문제 해결하기: 
==============

FAT32.IFS 가 작동하지 않는다면, 다음을 확인하십시오:
----------------------------------------------------

- 드라이버를 적용하고나서 다시 부팅하셨습니까 ? CONFIG.SYS 에 항목이 
만들어졌기 때문에, 드라이버가 로드되기 위해서는 다시 부팅할 필요가 있습니다.

- LVM(논리 볼륨 관리자) 시스템에서, COMPATIBILITY VOLUME 을 만들어 드라이브 
문자를 할당하기 위해 LVM 을 사용하셨습니까 ? FDISK 는 이러한 시스템에서 더 
이상 쓰이지 않습니다.

- 비-LVM 시스템에서, 비-LVM 시스템을 위한 파티션 지원 패키지 중의 하나를 
사용하셨습니까 ? FAT32 파티션에 드라이브 문자를 할당하기 위해서는, 이 패키지 
중의 하나가 필요합니다.

- 새로운 드라이브 문자가 할당되었습니까 ? ( OS2DASD.DMD 가 잘못되지 않았다면 )

- 확실하지 않다면, FAT32.IFS 뒤에 /MONITOR 파라미터를 시도해 보십시오, 그리고 
다시 부팅한 후에 F32MON 을 이용해서 FS_MOUNT 호출을 찾으십시오. 그 결과를 
Netlabs 에 보내십시오.

- 새 드라이브 문자가 할당되었지만, FAT32.IFS 가 작동하지 않는다면, F32PARTS 
를 실행하시기 바랍니다.

- 트랩이 발생한다면, 트랩의 CS:EIP 값을 보내십시오.

작동하지 않거나 오류를 돌려주는 프로그램이 있다면, 그 프로그램을 실행하는 
동안 F32MON.EXE 를 실행하십시오. 에러가 발생한 후에, F32MON 을 끝내고, 
프로그램이 무엇인지 최대한 자세하게 설명하는 메세지와 F32MON 이 만들어낸 
FAT32.LOG 를 Netlabs 에 보내십시오.

LINALLOC FAILED RC=32776 와 다른 LINALLOC 오류 메세지
-----------------------------------------------------

몇몇 시스템에서 VFDisk(가상 디바이스 드라이버) 와 FAT32 IFS 사이에 문제가 
있다는 보고가 있습니다. 부팅될 때, 다음 오류 메세지가 나타납니다:

linalloc failed rc=32776 

결과적으로, FAT32 캐시가 로드되지 않습니다. 하지만, FAT32 파일 시스템의 
안정성에는 영향을 미치지 않는 것 같습니다.

당신이 할 수 있는 세 가지 방법이 있습니다:

- 그냥 오류 메세지를 무시합니다.
- VFDisk 를 사용하지 않습니다.
- 다음 VFDISK 설정을 CONFIG.SYS 에 추가합니다.

DEVICE=<PATH>\VFDISK.SYS 0 

이 설정으로, VFDISK 는 드라이버를 메모리로 로드합니다. 하지만 가상 플로피를 
위한 메모리를 예약하지는 않습니다. 가상 플로피가 필요하다면, 제어 객체 
"VFCTRLPM.EXE" 를 이용해서 가상 플로피를 만드십시오.

시작할 때, 가상 디스크를 자동으로 시작하기 위해, "VFCTRLPM.EXE" 의 프로그램 
객체를 만듭니다. 그리고 그 프로그램 객체를 '시작' 폴더에 옮기십시오.
"VFCTRLPM" 프로그램 객체에서 오른쪽 클릭을 하고, 매개변수 입력란에 <플로피 
디스크 종류> 를 써 넣으십시오.

또 다른 방법은 VFCTRL.EXE <할당된 드라이브:> <플로피 디스크 종류> 를 부트 
드라이브의 루트 디렉토리에 있는 STARTUP.CMD 에 추가하는 것입니다.

또는 CALL=<경로>\VFCTRL.EXE <할당된 드라이브:> <플로피 디스크 종류> 를 
CONFIG.SYS 에 추가할 수 있습니다.

<플로피 디스크 종류>
0 빈 드라이브
1 1.44 Mb 3.5" 플로피
2 1.20 Mb 5.25" 플로피
3 720  Kb 3.5" 플로피
4 2.88 Mb 3.5" 플로피 
5 360  Kb 5.25" 플로피
6 1.84 Mb 3.5" 플로피

VFDisk 를 쓰지 않는 다른 이들이 이와 같은 오류를 겪었다는 보고가 있습니다. 
CONFIG.SYS 에서 캐시 크기를 1024 로 낮춤으로써, 오류 메세지를 날려 버릴 수 
있었습니다.

중요: 다음 설정을 CONFIG.SYS 에 추가하면 

EARLYMEMINIT=TRUE 

LINALLOC FAILED RC=32776 오류와 관련된 메모리 문제가 해결되는 것 같습니다.
이 설정을 통해, 디바이스 드라이버따위가 부팅 초기에 16MB 이상의 메모리를 
액세스할 수 있습니다. 이전에, 이것은 디바이스 드라이버와 IFS 의 초기화가 끝난 
후에만 가능했었습니다. 이 설정은 2002 년 이후 날짜의 OS2KRNL 이 필요합니다.

경고: 이 설정은 활성화되었을 때, 많은 관련 사항들이 있습니다. (버스마스터) 
DMA 기능을 가진 ISA 카드가 없는지 확인하십시오. 게다가 UNIAUD 드라이버는 이 
설정이 있으면 작동하지 않습니다.

========
판보기:
======== 

이전의 것은 FAT32.INF 또는 FAT32.TXT 를 보시기 바랍니다.

0.95 판: 

- 이제 FAT32.IFS 가 DBCS, 특히 한국어를 제대로 지원합니다.

- 'unsigned' 오버플로우 문제를 고쳤습니다.

- /FS 와 /EAS 가 함께 사용될 때, MOVE 와 REN 명령이 EA 파일을 올바르게 
처리하지 않았습니다. 해결.

- /FL(기본)이 사용될 때, FillDirEntry 에서 8.3 이름과 긴 이름이 같은 파일을 
가리킨다는 것을 알지 못합니다. 해결.

- /EAS 가 사용되지 않으면, 이제 FAT32.IFS 는 빈 EA 를 를 넘겨줍니다.

- UFAT32 는 볼륨 레이블을 부트 섹터가 아니라 루트 디렉토리에서 찾습니다.

- UFAT32 는 'file allocation error' 를 긴 이름으로 보고합니다.

- 긴이름으로부터 짧은 이름을 얻기위한 FSCTL 함수가 추가되었습니다.

- /FS 가 사용되고, 대상 파일이 이미 존재한다면, COPY 와 MOVE 명령은 대상 
파일의 이름을 이미 존재하는 파일의 짧은 이름으로 바꿉니다. 해결.

- FS_COPY 에서 '대상을 검사하는 부분' 의 벌레를 잡았습니다.

- FS_MOVE 에서 문제 있는 부분을 고쳤습니다.

- CMD.EXE 에서 CACHEF32.EXE 를 끝낸 후에 '쓰기 캐시' 데몬을 다시 시작할 때 
문제가 있었습니다. 해결.

- CACHEF32.EXE 에 'Yes' 를 가정하기 위한 /Y 옵션을 추가했습니다.

- CACHEF32.EXE 가 정상적인 메세지를 출력하지 않게하는 /S 옵션을 추가했습니다.

0.96 판: 

- RASECTORS 의 최대값을 클러스터당 섹터 수의 4 배에서 128 로 바꾸었습니다.

- 32K 크기의 클러스터를 가진 FAT32 파티션에 액세스할 때 트랩이 발생하는 
문제를 고쳤습니다.

- 이제 FAT32.IFS 는 32K 보다 큰 크기의 클러스터를 가진 FAT32 파티션을 
마운트하지 않습니다.

- DBCS [0xHH5C ] 코드와 [1 바이트-카타카나] 가 올바르게 변환되지 않았습니다. 
SBCS 에 포함된 DBCS 첫번째 바이트가 올바르게 변환되지 않았습니다. 해결. 
(이전에 문서화되지 않았습니다.)

0.97 판: 

- 비-LVM 시스템을 위한 파티션 지원 패키지, PARTFILT.FLT 와 OS2DASD.F32 를 
FAT32.IFS 드라이버 패키지에서 뺐습니다.

- MONITOR.EXE 를 F32MON.EXE 로 바꾸었습니다.

- DISKINFO.EXE 를 F32PARTS.EXE 로 바꾸었습니다.

왜 ? 이 파일들의 이름을 바꿈으로써, 이것들이 FAT32 배포본의 일부라는 것을 알 
수 있고, 시스템을 찾아보기 위해 무엇을 사용하든지, 이것들이 함께 무리지어 
있는 것을 볼 수 있습니다.

- FAT32.INF 가 다른 형식으로 수정되었고, 더 많은 정보를 담고 있습니다.

- FAT32 의 종료 부분에 문제가 있었습니다. DBCS 지원이 추가되었을 때 실수가 
있었습니다. 해결.

- FAT32 드라이버가, Win2X 와 WinXP 같은 WinNT 계열의 시스템에서 만들어진 
파일들을 확장 속성을 가진 것으로 인식할 수 있는 가능성이 있었습니다. 해결.

- WinNT 계열과의 호환성을 위해 EA 표시 바이트가 바뀌었습니다. 0xEA 는 0x40, 
0xEC 는 0x80 으로.
  
중요: 0.97 판부터, EA 표시 바이트가 바뀌었습니다. 그래서 이전 판에서 확장 
속성을 사용했던 분들은 각 파티션에 대해 CHKDSK /F 를 반드시 해주셔야 합니다.
하지만 F32STAT.EXE 를 이용하여 다음 부팅때 CHKDSK 가 자동으로 실행되게 하는 
것을 권장합니다. 다음처럼 하십시오:

F32STAT 드라이브: /DIRTY

0.98 판:

- WinNT 계열에서 사용하는 FAT32 변종을 지원하도록 TranslateName() 를 
고쳤습니다.

- Level7 을 올바르게 지원하도록 FS_PATHINFO 를 고쳤습니다.

- 이제 더이상 /FS 과 /FL 옵션은 지원되지 않습니다.

- 짧은 이름과 긴 이름이 섞여 있는 경로에 대한 '디렉토리 순환 검사' 를 FS_COPY 
  와 FS_MOVE 에 추가했습니다.

- 코드페이지를 파라미터에서 지정할 수 있도록, /CP 옵션을 CACHEF32.EXE 에 
  추가했습니다.

0.99 판:

- CACHEF32.EXE 가 백그라운드로 실행될 때, FAT32.IFS 의 CP 와 현재 CP 가 다를 
때, 계속해서 '삐-' 소리가 나는 것을 고쳤습니다.

- CACHEF32.EXE 의 /CP 옵션이 제대로 동작하지 않는 것을 고쳤습니다.

- 0.98 판에서 대소문자 변환이 128 보다 작은 ASCII 코드에 대해서만 이루어지는 
것을 고쳤습니다.

- 때때로, 쓰기 캐시(LAZY WRITE) 기능이 켜져 있을 때, 파일을 복사하고 나서 FAT 
사본이 일치하지 않거나 '잃어버린 클러스터' 가 나타나는 문제를 고쳤습니다.

- 이제 DBCS APIs 대신에 ULS APIs 를 사용합니다.

- CACHEF32.EXE 에 '/N' 옵션을 사용하면 'fForceLoad' 플래그를 지웁니다.

- 상위 메모리(high memory, > 16MB) 에 캐시 메모리를 할당하기 위해 /H 옵션을 
FAT32.IFS 에 추가했습니다.
'linalloc' 문제가 해결될 수 있을 것입니다.

- FAT32 파티션이 없더라도, 쓰기 캐시(LAZY WRITE) 데몬을 로드하기 위해 /F 
옵션을 CACHEF32.EXE 에 추가했습니다.

- 이제 FAT32.IFS 는 인자들의 대소문자를 가리지 않습니다.

0.99.10 판:

- 판번호 형태를 x.y.z(major.minor.patch level) 형태로 바꾸었습니다.

- 베타 기호를 뺐습니다.

- OS/2 에서 유니코드로 바꿀 수 없는 NLS 문자를 포함한 파일이름때문에 
  'lost cluster' 문제가 발생합니다. 고침.

- 섹터 모드로 쓸 수 있는 IOCTL 함수를 추가했습니다.

0.9.11 판(일명 2005 크리스마스판):

- 'Free Space' 가 일치하지 않는 문제를 고쳤습니다.

- USB 저장 장치를 바꾸었음에도 불구하고 이를 제대로 인식하지 못해서 발생하는 
  문제를 고쳤습니다.

- 현재 드라이브가 부트 드라이브가 아니라면, CACHEF32.EXE 가 CHKDSK.COM 을 
  실행시킬 수 없습니다.
  
- 소스를 컴파일할 때 발생하는 사소한 경고들을 고쳤습니다.

*** 알려진 문제들 ***

- 때때로 몇 개의 섹터에서 쓰기 대기 상태가 해제되지 않습니다. 'CACHEF32.EXE' 
  를 통해 확인할 수 있습니다. 기록되지 않은 섹터가 없지만, 쓰기 대기 상태의
  섹터는 존재합니다. 왜 그럴까요 ? ^^ 하지만, 이것은 FAT32.IFS 의 기능에는 
  영향을 미치지 않습니다.

=============
최신 파일들: 
=============

최근에 컴파일된 것:
--------------------  

FAT32 IFS: ftp://ftp.netlabs.org/pub/FAT32 


연락:
-----  


Adrian Gschwend, ktk@netlabs.org. 
FAT32 패치를 가진 분들은 이메일을 이용하거나 또는 atirc.anduin.net(IRC) 
#netlabs 채널에 참여하실 수 있습니다. 저의 별명은 ktk 이고, Brian Smith 씨는 
nuke 입니다.

고명훈, komh@chollian.net. 
FAT32 코드와 관련된 문제에 대해.

Alfredo Fernandez Diaz, alfredo@netropolis-si.com. 
WarpIN 스크립트와 FAT32 코드와 관련된 문제에 대해.

David Graser, dwgras@swbell.net.
FAT32.INF 파일과 관련된 문제에 대해.


=======================================
소스를 가지고 FAT32 만들기 (개발자만):
=======================================

요구사항:
--------------

- IFS DDK Build Environment 

- IBM VAC++ 3 

- OS/2 Toolkit 4.5 (OS/2 CP 와 eCS 에 포함되어 있습니다)

- IBM DDK sources and tools (IBM 의 DDK 사이트에서 무료로 받을 수 있습니다)

- 시스템 유틸리티(LINK.EXE 를 포함해서)

주의: IBM DDK 소스와 도구들이 무료이지만, 아직 등록되어 있지 않다면 일단 IBM 
DDK 사이트(http://www3.software.ibm.com/regsvs/ddk/)에서 등록을 해야 합니다.



소스 코드: 
------------

ftp://ftp.netlabs.org/pub/snapshots/FAT32/ 

최신판은 CVS 에 있습니다. 다음 CVSROOT 를 사용하십시오:

CVSROOT=:pserver:guest@www.netlabs.org:/netlabs.cvs/FAT32 
Password: readonly 

소스를 얻기 위해 NOSA 클라이언트를 쓸 수 있습니다.
http://nosa.netlabs.org 

소스 코드는 GNU LGPL 라이센스 아래 배포됩니다.

컴파일하기:
-----------

만들기 위해, 몇 가지가 필요합니다:

Visual Age 를 설치해야 하고, 환경 변수들을 설정해야 합니다. 그리고 다음 세 
개의 변수를 설정하십시오.

SET DDK=d:\ddk 
SET DDKTOOLS=d:\ddktools 
SET IBMC=d:\ibmc 

필요에 따라 경로들을 수정하십시오.

그런 후에, MAKE.CMD 스크립트를 실행하십시오. 잘 된다면, 새로운 FAT32.IFS 가 
만들어질 것입니다.

주의: FAT32.IFS 를 컴파일할 때 많은 경고가 있습니다. 대부분은 
'최적화(optimizing)' 경고이거나 '참조되지 않은 변수(unreference varaible)' 
경고입니다. 이 경고들은 무시될 수 있습니다.

===========
덧말:
===========

덧말
-------

CACHEF32.EXE 명령:  /D: 파라미터

캐시 메로리에서 데이터를 받기 전에 디스크가 반드시 쉬어야하는 시간을 (밀리초 
단위로) 설정합니다. 디스크 유휴 시간의 최소 크기는 BUFFERIDLE 파라미터에 
지정된 값보다 커야합니다.

디스크 유휴 시간을 2000 밀리초(2초)로 설정하기 위해, CONFIG.SYS 에 다음을 
입력하십시오.

CALL=X:\TOOLS\SYSTEM\BIN\CACHEF32.EXE /D:2000
 
덧말
-------

CACHEF32.EXE 명령:  /B: 파라미터

캐시가 가지고 있는 데이터가 디스크에 쓰여지기 전에 캐시 버퍼가 쉴 수 있는 
시간을 (밀리초 단위로) 설정합니다.

캐시 버퍼 유휴 시간을 1000 밀리초(1초)로 설정하기 위해, CONFIG.SYS 에 다음을 
입력하십시오.

CALL=X:\TOOLS\SYSTEM\BIN\CACHEF32.EXE /B:1000 


덧말
-------

CACHEF32.EXE 명령:   /M: 파라미터

자주 쓰여지는 데이터가 디스크에 전송되기까지 캐시 메모리에 있을 수 있는 최대 
시간을 지정합니다.

4000 밀리초(4초) 이상 캐시 메모리에 있는 자주 쓰여지는 데이터를 디스크에 
기록하려면, CONFIG.SYS 에 다음을 입력하십시오.

CALL=X:\TOOLS\SYSTEM\BIN\CACHEF32.EXE /M:4000 


덧말
-------

CACHEF32.EXE 명령:  /L: 파라미터

캐시 메모리의 내용이 디스크에 바로 쓰여질지 또는 디스크 유휴 시간 동안에만 
쓰여질지를 지정합니다. 이 명령은 오직 FAT32 파일 시스템으로 포맷된 디스크에만 
영향을 미칩니다. ON 은 디스크 유휴 시간동안 캐시 메모리의 내용을 쓰고, OFF 는 
바로 디스크에 쓸 것을 지정합니다. 기본 상태는 쓰기-캐시가 ON 입니다. 
기본적으로 쓰기-캐시가 OFF 가 되게하려면, CONFIG.SYS 에 다음 문장을 추가해야 
합니다:

CALL=X:\TOOLS\SYSTEM\BIN\CACHEF32.EXE /L:OFF 


덧말
-------

예: jCVS(Java CVS Client)를 사용하는 설정

http://www.jcvs.org/download/jcvs/jcvsii-5.3.2.zip 

"Checkout" 탭에서:

Selections User Added Info 

Server PServer 

User Name guest 

Password readonly 

CVS Module: 
. 

주의:  이것은 점(.)입니다.

CVS Server: www.netlabs.org 

CVS Repository: /netlabs.cvs/fat32 

Checkout Directory: X:\temp 

주의: X 는 임시 디렉토리가 위치한 드라이브입니다.

Arguments: 

주의 : Arguments 는 빈 칸으로 두어도 됩니다.


덧말
-------

License.txt

이 소스 코드는 원래 Henk Kelder <henk.kelder@cgey.nl> 씨가 만들었습니다.

Henk Kelder 씨는 소스 코드에 대한 저작권을 2002 년 1 월에 netlabs.org 에 

이양했습니다. 그가 이 소스 코드에 할애했던 작업량때문에, 어떤 회사나 개인도 

이것을 이용해서 이익을 챙길 수 없도록하는 라이센스를 가지고 싶어했습니다. 이 

때문에, 우리는 GNU LESSER GENERAL PUBLIC LICENSE (LGPL) 아래 이 소스코드를 

배포합니다.

원본 라이센스는 http://www.gnu.org/copyleft/lesser.txt 에 있습니다.

GNU 소프트웨어에 대한 더 자세한 것은 http://www.gnu.org 를 보십시오.

2002 년 1 월 6 일

Adrian Gschwend <ktk@netlabs.org>

http://www.netlabs.org
